import threading
from _typeshed import Incomplete
from telebot import types
from telebot.service_utils import chunks as chunks, generate_random_token as generate_random_token, is_bytes as is_bytes, is_dict as is_dict, is_pil_image as is_pil_image, is_string as is_string, pil_image_to_file as pil_image_to_file
from typing import Any, Callable, Dict, List, Optional, Union

content_type_media: Incomplete
content_type_service: Incomplete
update_types: Incomplete

class WorkerThread(threading.Thread):
    count: int
    queue: Incomplete
    daemon: bool
    received_task_event: Incomplete
    done_event: Incomplete
    exception_event: Incomplete
    continue_event: Incomplete
    exception_callback: Incomplete
    exception_info: Incomplete
    def __init__(self, exception_callback: Incomplete | None = ..., queue: Incomplete | None = ..., name: Incomplete | None = ...) -> None: ...
    def run(self) -> None: ...
    def put(self, task, *args, **kwargs) -> None: ...
    def raise_exceptions(self) -> None: ...
    def clear_exceptions(self) -> None: ...
    def stop(self) -> None: ...

class ThreadPool:
    telebot: Incomplete
    tasks: Incomplete
    workers: Incomplete
    num_threads: Incomplete
    exception_event: Incomplete
    exception_info: Incomplete
    def __init__(self, telebot, num_threads: int = ...) -> None: ...
    def put(self, func, *args, **kwargs) -> None: ...
    def on_exception(self, worker_thread, exc_info) -> None: ...
    def raise_exceptions(self) -> None: ...
    def clear_exceptions(self) -> None: ...
    def close(self) -> None: ...

class AsyncTask:
    target: Incomplete
    args: Incomplete
    kwargs: Incomplete
    done: bool
    thread: Incomplete
    def __init__(self, target, *args, **kwargs) -> None: ...
    def wait(self): ...

class CustomRequestResponse:
    status_code: Incomplete
    text: Incomplete
    reason: Incomplete
    def __init__(self, json_text, status_code: int = ..., reason: str = ...) -> None: ...
    def json(self): ...

def async_dec(): ...
def is_command(text: str) -> bool: ...
def extract_command(text: str) -> Union[str, None]: ...
def extract_arguments(text: str) -> None: ...
def split_string(text: str, chars_per_string: int) -> List[str]: ...
def smart_split(text: str, chars_per_string: int = ...) -> List[str]: ...
def escape(text: str) -> str: ...
def user_link(user: types.User, include_id: bool = ...) -> str: ...
def quick_markup(values: Dict[str, Dict[str, Any]], row_width: int = ...) -> types.InlineKeyboardMarkup: ...
def or_set(self) -> None: ...
def or_clear(self) -> None: ...
def orify(e, changed_callback): ...
def OrEvent(*events): ...
def per_thread(key, construct_value, reset: bool = ...): ...
def deprecated(warn: bool = ..., alternative: Optional[Callable] = ..., deprecation_text: Incomplete | None = ...): ...
def webhook_google_functions(bot, request): ...
def antiflood(function: Callable, *args, number_retries: int = ..., **kwargs): ...
def parse_web_app_data(token: str, raw_init_data: str): ...
def validate_web_app_data(token: str, raw_init_data: str): ...
