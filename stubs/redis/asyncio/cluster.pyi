import abc
from _typeshed import Incomplete
from redis._parsers import AsyncCommandsParser as AsyncCommandsParser, Encoder as Encoder
from redis.asyncio.client import ResponseCallbackT as ResponseCallbackT
from redis.asyncio.connection import Connection as Connection, DefaultParser as DefaultParser, SSLConnection as SSLConnection, parse_url as parse_url
from redis.asyncio.lock import Lock as Lock
from redis.asyncio.retry import Retry as Retry
from redis.backoff import default_backoff as default_backoff
from redis.client import AbstractRedis as AbstractRedis, EMPTY_RESPONSE as EMPTY_RESPONSE, NEVER_DECODE as NEVER_DECODE
from redis.cluster import AbstractRedisCluster as AbstractRedisCluster, LoadBalancer as LoadBalancer, PIPELINE_BLOCKED_COMMANDS as PIPELINE_BLOCKED_COMMANDS, PRIMARY as PRIMARY, REPLICA as REPLICA, SLOT_ID as SLOT_ID, block_pipeline_command as block_pipeline_command, get_node_name as get_node_name, parse_cluster_slots as parse_cluster_slots
from redis.commands import AsyncRedisClusterCommands as AsyncRedisClusterCommands, READ_COMMANDS as READ_COMMANDS
from redis.crc import REDIS_CLUSTER_HASH_SLOTS as REDIS_CLUSTER_HASH_SLOTS, key_slot as key_slot
from redis.credentials import CredentialProvider as CredentialProvider
from redis.exceptions import AskError as AskError, BusyLoadingError as BusyLoadingError, ClusterCrossSlotError as ClusterCrossSlotError, ClusterDownError as ClusterDownError, ClusterError as ClusterError, ConnectionError as ConnectionError, DataError as DataError, MasterDownError as MasterDownError, MaxConnectionsError as MaxConnectionsError, MovedError as MovedError, RedisClusterException as RedisClusterException, ResponseError as ResponseError, SlotNotCoveredError as SlotNotCoveredError, TimeoutError as TimeoutError, TryAgainError as TryAgainError
from redis.typing import AnyKeyT as AnyKeyT, EncodableT as EncodableT, KeyT as KeyT
from redis.utils import deprecated_function as deprecated_function, dict_merge as dict_merge, get_lib_version as get_lib_version, safe_str as safe_str, str_if_bytes as str_if_bytes
from typing import Any, Callable, Dict, Generator, List, Mapping, Optional, Tuple, Type, TypeVar, Union

TargetNodesT = TypeVar('TargetNodesT', str, 'ClusterNode', List['ClusterNode'], Dict[Any, 'ClusterNode'])

class ClusterParser(DefaultParser):
    EXCEPTION_CLASSES: Incomplete

class RedisCluster(AbstractRedis, AbstractRedisCluster, AsyncRedisClusterCommands, metaclass=abc.ABCMeta):
    @classmethod
    def from_url(cls, url: str, **kwargs: Any) -> RedisCluster: ...
    retry: Incomplete
    connection_kwargs: Incomplete
    nodes_manager: Incomplete
    encoder: Incomplete
    read_from_replicas: Incomplete
    reinitialize_steps: Incomplete
    cluster_error_retry_attempts: Incomplete
    connection_error_retry_attempts: Incomplete
    reinitialize_counter: int
    commands_parser: Incomplete
    node_flags: Incomplete
    command_flags: Incomplete
    response_callbacks: Incomplete
    result_callbacks: Incomplete
    def __init__(self, host: Optional[str] = ..., port: Union[str, int] = ..., startup_nodes: Optional[List['ClusterNode']] = ..., require_full_coverage: bool = ..., read_from_replicas: bool = ..., reinitialize_steps: int = ..., cluster_error_retry_attempts: int = ..., connection_error_retry_attempts: int = ..., max_connections: int = ..., db: Union[str, int] = ..., path: Optional[str] = ..., credential_provider: Optional[CredentialProvider] = ..., username: Optional[str] = ..., password: Optional[str] = ..., client_name: Optional[str] = ..., lib_name: Optional[str] = ..., lib_version: Optional[str] = ..., encoding: str = ..., encoding_errors: str = ..., decode_responses: bool = ..., health_check_interval: float = ..., socket_connect_timeout: Optional[float] = ..., socket_keepalive: bool = ..., socket_keepalive_options: Optional[Mapping[int, Union[int, bytes]]] = ..., socket_timeout: Optional[float] = ..., retry: Optional['Retry'] = ..., retry_on_error: Optional[List[Type[Exception]]] = ..., ssl: bool = ..., ssl_ca_certs: Optional[str] = ..., ssl_ca_data: Optional[str] = ..., ssl_cert_reqs: str = ..., ssl_certfile: Optional[str] = ..., ssl_check_hostname: bool = ..., ssl_keyfile: Optional[str] = ..., protocol: Optional[int] = ..., address_remap: Optional[Callable[[str, int], Tuple[str, int]]] = ...) -> None: ...
    async def initialize(self) -> RedisCluster: ...
    async def aclose(self) -> None: ...
    async def close(self) -> None: ...
    async def __aenter__(self) -> RedisCluster: ...
    async def __aexit__(self, exc_type: None, exc_value: None, traceback: None) -> None: ...
    def __await__(self) -> Generator[Any, None, 'RedisCluster']: ...
    def __del__(self, _warn: Any = ..., _grl: Any = ...) -> None: ...
    async def on_connect(self, connection: Connection) -> None: ...
    def get_nodes(self) -> List['ClusterNode']: ...
    def get_primaries(self) -> List['ClusterNode']: ...
    def get_replicas(self) -> List['ClusterNode']: ...
    def get_random_node(self) -> ClusterNode: ...
    def get_default_node(self) -> ClusterNode: ...
    def set_default_node(self, node: ClusterNode) -> None: ...
    def get_node(self, host: Optional[str] = ..., port: Optional[int] = ..., node_name: Optional[str] = ...) -> Optional['ClusterNode']: ...
    def get_node_from_key(self, key: str, replica: bool = ...) -> Optional['ClusterNode']: ...
    def keyslot(self, key: EncodableT) -> int: ...
    def get_encoder(self) -> Encoder: ...
    def get_connection_kwargs(self) -> Dict[str, Optional[Any]]: ...
    def get_retry(self) -> Optional['Retry']: ...
    def set_retry(self, retry: Retry) -> None: ...
    def set_response_callback(self, command: str, callback: ResponseCallbackT) -> None: ...
    async def execute_command(self, *args: EncodableT, **kwargs: Any) -> Any: ...
    def pipeline(self, transaction: Optional[Any] = ..., shard_hint: Optional[Any] = ...) -> ClusterPipeline: ...
    def lock(self, name: KeyT, timeout: Optional[float] = ..., sleep: float = ..., blocking: bool = ..., blocking_timeout: Optional[float] = ..., lock_class: Optional[Type[Lock]] = ..., thread_local: bool = ...) -> Lock: ...

class ClusterNode:
    host: Incomplete
    port: Incomplete
    name: Incomplete
    server_type: Incomplete
    max_connections: Incomplete
    connection_class: Incomplete
    connection_kwargs: Incomplete
    response_callbacks: Incomplete
    def __init__(self, host: str, port: Union[str, int], server_type: Optional[str] = ..., *, max_connections: int = ..., connection_class: Type[Connection] = ..., **connection_kwargs: Any) -> None: ...
    def __eq__(self, obj: Any) -> bool: ...
    def __del__(self, _warn: Any = ..., _grl: Any = ...) -> None: ...
    async def disconnect(self) -> None: ...
    def acquire_connection(self) -> Connection: ...
    async def parse_response(self, connection: Connection, command: str, **kwargs: Any) -> Any: ...
    async def execute_command(self, *args: Any, **kwargs: Any) -> Any: ...
    async def execute_pipeline(self, commands: List['PipelineCommand']) -> bool: ...

class NodesManager:
    startup_nodes: Incomplete
    require_full_coverage: Incomplete
    connection_kwargs: Incomplete
    address_remap: Incomplete
    default_node: Incomplete
    nodes_cache: Incomplete
    slots_cache: Incomplete
    read_load_balancer: Incomplete
    def __init__(self, startup_nodes: List['ClusterNode'], require_full_coverage: bool, connection_kwargs: Dict[str, Any], address_remap: Optional[Callable[[str, int], Tuple[str, int]]] = ...) -> None: ...
    def get_node(self, host: Optional[str] = ..., port: Optional[int] = ..., node_name: Optional[str] = ...) -> Optional['ClusterNode']: ...
    def set_nodes(self, old: Dict[str, 'ClusterNode'], new: Dict[str, 'ClusterNode'], remove_old: bool = ...) -> None: ...
    def get_node_from_slot(self, slot: int, read_from_replicas: bool = ...) -> ClusterNode: ...
    def get_nodes_by_server_type(self, server_type: str) -> List['ClusterNode']: ...
    async def initialize(self) -> None: ...
    async def aclose(self, attr: str = ...) -> None: ...
    def remap_host_port(self, host: str, port: int) -> Tuple[str, int]: ...

class ClusterPipeline(AbstractRedis, AbstractRedisCluster, AsyncRedisClusterCommands, metaclass=abc.ABCMeta):
    def __init__(self, client: RedisCluster) -> None: ...
    async def initialize(self) -> ClusterPipeline: ...
    async def __aenter__(self) -> ClusterPipeline: ...
    async def __aexit__(self, exc_type: None, exc_value: None, traceback: None) -> None: ...
    def __await__(self) -> Generator[Any, None, 'ClusterPipeline']: ...
    def __enter__(self) -> ClusterPipeline: ...
    def __exit__(self, exc_type: None, exc_value: None, traceback: None) -> None: ...
    def __bool__(self) -> bool: ...
    def __len__(self) -> int: ...
    def execute_command(self, *args: Union[KeyT, EncodableT], **kwargs: Any) -> ClusterPipeline: ...
    async def execute(self, raise_on_error: bool = ..., allow_redirections: bool = ...) -> List[Any]: ...
    def mset_nonatomic(self, mapping: Mapping[AnyKeyT, EncodableT]) -> ClusterPipeline: ...

command: Incomplete

class PipelineCommand:
    args: Incomplete
    kwargs: Incomplete
    position: Incomplete
    result: Incomplete
    def __init__(self, position: int, *args: Any, **kwargs: Any) -> None: ...
