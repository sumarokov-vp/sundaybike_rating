from _typeshed import Incomplete
from redis._parsers.helpers import bool_ok as bool_ok
from redis.asyncio.connection import Connection as Connection, ConnectionPool as ConnectionPool, SSLConnection as SSLConnection, UnixDomainSocketConnection as UnixDomainSocketConnection
from redis.asyncio.lock import Lock as Lock
from redis.asyncio.retry import Retry as Retry
from redis.client import AbstractRedis as AbstractRedis, CaseInsensitiveDict as CaseInsensitiveDict, EMPTY_RESPONSE as EMPTY_RESPONSE, NEVER_DECODE as NEVER_DECODE
from redis.commands import AsyncCoreCommands as AsyncCoreCommands, AsyncRedisModuleCommands as AsyncRedisModuleCommands, AsyncSentinelCommands as AsyncSentinelCommands, list_or_args as list_or_args
from redis.commands.core import Script as Script
from redis.compat import Protocol as Protocol, TypedDict as TypedDict
from redis.credentials import CredentialProvider as CredentialProvider
from redis.exceptions import ConnectionError as ConnectionError, ExecAbortError as ExecAbortError, PubSubError as PubSubError, RedisError as RedisError, ResponseError as ResponseError, TimeoutError as TimeoutError, WatchError as WatchError
from redis.typing import ChannelT as ChannelT, EncodableT as EncodableT, KeyT as KeyT
from redis.utils import HIREDIS_AVAILABLE as HIREDIS_AVAILABLE, deprecated_function as deprecated_function, get_lib_version as get_lib_version, safe_str as safe_str, str_if_bytes as str_if_bytes
from typing import Any, AsyncIterator, Awaitable, Callable, Dict, Iterable, List, Mapping, MutableMapping, Optional, Tuple, Type, Union

PubSubHandler = Callable[[Dict[str, str]], Awaitable[None]]

class ResponseCallbackProtocol(Protocol):
    def __call__(self, response: Any, **kwargs): ...

class AsyncResponseCallbackProtocol(Protocol):
    async def __call__(self, response: Any, **kwargs): ...
ResponseCallbackT = Union[ResponseCallbackProtocol, AsyncResponseCallbackProtocol]

class Redis(AbstractRedis, AsyncRedisModuleCommands, AsyncCoreCommands, AsyncSentinelCommands):
    response_callbacks: MutableMapping[Union[str, bytes], ResponseCallbackT]
    @classmethod
    def from_url(cls, url: str, single_connection_client: bool = ..., auto_close_connection_pool: Optional[bool] = ..., **kwargs): ...
    @classmethod
    def from_pool(cls, connection_pool: ConnectionPool) -> Redis: ...
    auto_close_connection_pool: Incomplete
    connection_pool: Incomplete
    single_connection_client: Incomplete
    connection: Incomplete
    def __init__(self, *, host: str = ..., port: int = ..., db: Union[str, int] = ..., password: Optional[str] = ..., socket_timeout: Optional[float] = ..., socket_connect_timeout: Optional[float] = ..., socket_keepalive: Optional[bool] = ..., socket_keepalive_options: Optional[Mapping[int, Union[int, bytes]]] = ..., connection_pool: Optional[ConnectionPool] = ..., unix_socket_path: Optional[str] = ..., encoding: str = ..., encoding_errors: str = ..., decode_responses: bool = ..., retry_on_timeout: bool = ..., retry_on_error: Optional[list] = ..., ssl: bool = ..., ssl_keyfile: Optional[str] = ..., ssl_certfile: Optional[str] = ..., ssl_cert_reqs: str = ..., ssl_ca_certs: Optional[str] = ..., ssl_ca_data: Optional[str] = ..., ssl_check_hostname: bool = ..., max_connections: Optional[int] = ..., single_connection_client: bool = ..., health_check_interval: int = ..., client_name: Optional[str] = ..., lib_name: Optional[str] = ..., lib_version: Optional[str] = ..., username: Optional[str] = ..., retry: Optional[Retry] = ..., auto_close_connection_pool: Optional[bool] = ..., redis_connect_func: Incomplete | None = ..., credential_provider: Optional[CredentialProvider] = ..., protocol: Optional[int] = ...) -> None: ...
    def __await__(self): ...
    async def initialize(self) -> _RedisT: ...
    def set_response_callback(self, command: str, callback: ResponseCallbackT): ...
    def get_encoder(self): ...
    def get_connection_kwargs(self): ...
    def get_retry(self) -> Optional['Retry']: ...
    def set_retry(self, retry: Retry) -> None: ...
    def load_external_module(self, funcname, func) -> None: ...
    def pipeline(self, transaction: bool = ..., shard_hint: Optional[str] = ...) -> Pipeline: ...
    async def transaction(self, func: Callable[[Pipeline], Union[Any, Awaitable[Any]]], *watches: KeyT, shard_hint: Optional[str] = ..., value_from_callable: bool = ..., watch_delay: Optional[float] = ...): ...
    def lock(self, name: KeyT, timeout: Optional[float] = ..., sleep: float = ..., blocking: bool = ..., blocking_timeout: Optional[float] = ..., lock_class: Optional[Type[Lock]] = ..., thread_local: bool = ...) -> Lock: ...
    def pubsub(self, **kwargs) -> PubSub: ...
    def monitor(self) -> Monitor: ...
    def client(self) -> Redis: ...
    async def __aenter__(self) -> _RedisT: ...
    async def __aexit__(self, exc_type, exc_value, traceback) -> None: ...
    def __del__(self, _warn: Any = ..., _grl: Any = ...) -> None: ...
    async def aclose(self, close_connection_pool: Optional[bool] = ...) -> None: ...
    async def close(self, close_connection_pool: Optional[bool] = ...) -> None: ...
    async def execute_command(self, *args, **options): ...
    async def parse_response(self, connection: Connection, command_name: Union[str, bytes], **options): ...
StrictRedis = Redis

class MonitorCommandInfo(TypedDict):
    time: float
    db: int
    client_address: str
    client_port: str
    client_type: str
    command: str

class Monitor:
    monitor_re: Incomplete
    command_re: Incomplete
    connection_pool: Incomplete
    connection: Incomplete
    def __init__(self, connection_pool: ConnectionPool) -> None: ...
    async def connect(self) -> None: ...
    async def __aenter__(self): ...
    async def __aexit__(self, *args) -> None: ...
    async def next_command(self) -> MonitorCommandInfo: ...
    async def listen(self) -> AsyncIterator[MonitorCommandInfo]: ...

class PubSub:
    PUBLISH_MESSAGE_TYPES: Incomplete
    UNSUBSCRIBE_MESSAGE_TYPES: Incomplete
    HEALTH_CHECK_MESSAGE: str
    connection_pool: Incomplete
    shard_hint: Incomplete
    ignore_subscribe_messages: Incomplete
    connection: Incomplete
    encoder: Incomplete
    push_handler_func: Incomplete
    health_check_response: Incomplete
    channels: Incomplete
    pending_unsubscribe_channels: Incomplete
    patterns: Incomplete
    pending_unsubscribe_patterns: Incomplete
    def __init__(self, connection_pool: ConnectionPool, shard_hint: Optional[str] = ..., ignore_subscribe_messages: bool = ..., encoder: Incomplete | None = ..., push_handler_func: Optional[Callable] = ...) -> None: ...
    async def __aenter__(self): ...
    async def __aexit__(self, exc_type, exc_value, traceback) -> None: ...
    def __del__(self) -> None: ...
    async def aclose(self) -> None: ...
    async def close(self) -> None: ...
    async def reset(self) -> None: ...
    async def on_connect(self, connection: Connection): ...
    @property
    def subscribed(self): ...
    async def execute_command(self, *args: EncodableT): ...
    async def connect(self) -> None: ...
    async def parse_response(self, block: bool = ..., timeout: float = ...): ...
    async def check_health(self) -> None: ...
    async def psubscribe(self, *args: ChannelT, **kwargs: PubSubHandler): ...
    def punsubscribe(self, *args: ChannelT) -> Awaitable: ...
    async def subscribe(self, *args: ChannelT, **kwargs: Callable): ...
    def unsubscribe(self, *args) -> Awaitable: ...
    async def listen(self) -> AsyncIterator: ...
    async def get_message(self, ignore_subscribe_messages: bool = ..., timeout: Optional[float] = ...): ...
    def ping(self, message: Incomplete | None = ...) -> Awaitable: ...
    async def handle_message(self, response, ignore_subscribe_messages: bool = ...): ...
    async def run(self, *, exception_handler: Optional['PSWorkerThreadExcHandlerT'] = ..., poll_timeout: float = ...) -> None: ...

class PubsubWorkerExceptionHandler(Protocol):
    def __call__(self, e: BaseException, pubsub: PubSub): ...

class AsyncPubsubWorkerExceptionHandler(Protocol):
    async def __call__(self, e: BaseException, pubsub: PubSub): ...
PSWorkerThreadExcHandlerT = Union[PubsubWorkerExceptionHandler, AsyncPubsubWorkerExceptionHandler]
CommandT = Tuple[Tuple[Union[str, bytes], ...], Mapping[str, Any]]
CommandStackT = List[CommandT]

class Pipeline(Redis):
    UNWATCH_COMMANDS: Incomplete
    connection_pool: Incomplete
    connection: Incomplete
    response_callbacks: Incomplete
    is_transaction: Incomplete
    shard_hint: Incomplete
    watching: bool
    command_stack: Incomplete
    scripts: Incomplete
    explicit_transaction: bool
    def __init__(self, connection_pool: ConnectionPool, response_callbacks: MutableMapping[Union[str, bytes], ResponseCallbackT], transaction: bool, shard_hint: Optional[str]) -> None: ...
    async def __aenter__(self) -> _RedisT: ...
    async def __aexit__(self, exc_type, exc_value, traceback) -> None: ...
    def __await__(self): ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    async def reset(self) -> None: ...
    async def aclose(self) -> None: ...
    def multi(self) -> None: ...
    def execute_command(self, *args, **kwargs) -> Union['Pipeline', Awaitable['Pipeline']]: ...
    async def immediate_execute_command(self, *args, **options): ...
    def pipeline_execute_command(self, *args, **options): ...
    def raise_first_error(self, commands: CommandStackT, response: Iterable[Any]): ...
    def annotate_exception(self, exception: Exception, number: int, command: Iterable[object]) -> None: ...
    async def parse_response(self, connection: Connection, command_name: Union[str, bytes], **options): ...
    async def load_scripts(self) -> None: ...
    async def execute(self, raise_on_error: bool = ...): ...
    async def discard(self) -> None: ...
    async def watch(self, *names: KeyT): ...
    async def unwatch(self): ...
