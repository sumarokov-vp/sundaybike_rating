import abc
from ._parsers import Encoder as Encoder, _HiredisParser, _RESP2Parser, _RESP3Parser
from .backoff import NoBackoff as NoBackoff
from .credentials import CredentialProvider as CredentialProvider, UsernamePasswordCredentialProvider as UsernamePasswordCredentialProvider
from .exceptions import AuthenticationError as AuthenticationError, AuthenticationWrongNumberOfArgsError as AuthenticationWrongNumberOfArgsError, ChildDeadlockedError as ChildDeadlockedError, ConnectionError as ConnectionError, DataError as DataError, RedisError as RedisError, ResponseError as ResponseError, TimeoutError as TimeoutError
from .retry import Retry as Retry
from .utils import CRYPTOGRAPHY_AVAILABLE as CRYPTOGRAPHY_AVAILABLE, HIREDIS_AVAILABLE as HIREDIS_AVAILABLE, HIREDIS_PACK_AVAILABLE as HIREDIS_PACK_AVAILABLE, SSL_AVAILABLE as SSL_AVAILABLE, get_lib_version as get_lib_version, str_if_bytes as str_if_bytes
from _typeshed import Incomplete
from abc import abstractmethod
from typing import Any, Callable, List, Optional, Type, Union

SYM_STAR: bytes
SYM_DOLLAR: bytes
SYM_CRLF: bytes
SYM_EMPTY: bytes
DEFAULT_RESP_VERSION: int
SENTINEL: Incomplete
DefaultParser: Type[Union[_RESP2Parser, _RESP3Parser, _HiredisParser]]

class HiredisRespSerializer:
    def pack(self, *args: List): ...

class PythonRespSerializer:
    encode: Incomplete
    def __init__(self, buffer_cutoff, encode) -> None: ...
    def pack(self, *args): ...

class AbstractConnection(metaclass=abc.ABCMeta):
    pid: Incomplete
    db: Incomplete
    client_name: Incomplete
    lib_name: Incomplete
    lib_version: Incomplete
    credential_provider: Incomplete
    password: Incomplete
    username: Incomplete
    socket_timeout: Incomplete
    socket_connect_timeout: Incomplete
    retry_on_timeout: Incomplete
    retry_on_error: Incomplete
    retry: Incomplete
    health_check_interval: Incomplete
    next_health_check: int
    redis_connect_func: Incomplete
    encoder: Incomplete
    protocol: Incomplete
    def __init__(self, db: int = ..., password: Optional[str] = ..., socket_timeout: Optional[float] = ..., socket_connect_timeout: Optional[float] = ..., retry_on_timeout: bool = ..., retry_on_error=..., encoding: str = ..., encoding_errors: str = ..., decode_responses: bool = ..., parser_class=..., socket_read_size: int = ..., health_check_interval: int = ..., client_name: Optional[str] = ..., lib_name: Optional[str] = ..., lib_version: Optional[str] = ..., username: Optional[str] = ..., retry: Union[Any, None] = ..., redis_connect_func: Optional[Callable[[], None]] = ..., credential_provider: Optional[CredentialProvider] = ..., protocol: Optional[int] = ..., command_packer: Optional[Callable[[], None]] = ...) -> None: ...
    @abstractmethod
    def repr_pieces(self): ...
    def __del__(self) -> None: ...
    def set_parser(self, parser_class) -> None: ...
    def connect(self): ...
    def on_connect(self) -> None: ...
    def disconnect(self, *args) -> None: ...
    def check_health(self) -> None: ...
    def send_packed_command(self, command, check_health: bool = ...) -> None: ...
    def send_command(self, *args, **kwargs) -> None: ...
    def can_read(self, timeout: int = ...): ...
    def read_response(self, disable_decoding: bool = ..., *, disconnect_on_error: bool = ..., push_request: bool = ...): ...
    def pack_command(self, *args): ...
    def pack_commands(self, commands): ...

class Connection(AbstractConnection):
    host: Incomplete
    port: Incomplete
    socket_keepalive: Incomplete
    socket_keepalive_options: Incomplete
    socket_type: Incomplete
    def __init__(self, host: str = ..., port: int = ..., socket_keepalive: bool = ..., socket_keepalive_options: Incomplete | None = ..., socket_type: int = ..., **kwargs) -> None: ...
    def repr_pieces(self): ...

class SSLConnection(Connection):
    keyfile: Incomplete
    certfile: Incomplete
    cert_reqs: Incomplete
    ca_certs: Incomplete
    ca_data: Incomplete
    ca_path: Incomplete
    check_hostname: Incomplete
    certificate_password: Incomplete
    ssl_validate_ocsp: Incomplete
    ssl_validate_ocsp_stapled: Incomplete
    ssl_ocsp_context: Incomplete
    ssl_ocsp_expected_cert: Incomplete
    def __init__(self, ssl_keyfile: Incomplete | None = ..., ssl_certfile: Incomplete | None = ..., ssl_cert_reqs: str = ..., ssl_ca_certs: Incomplete | None = ..., ssl_ca_data: Incomplete | None = ..., ssl_check_hostname: bool = ..., ssl_ca_path: Incomplete | None = ..., ssl_password: Incomplete | None = ..., ssl_validate_ocsp: bool = ..., ssl_validate_ocsp_stapled: bool = ..., ssl_ocsp_context: Incomplete | None = ..., ssl_ocsp_expected_cert: Incomplete | None = ..., **kwargs) -> None: ...

class UnixDomainSocketConnection(AbstractConnection):
    path: Incomplete
    socket_timeout: Incomplete
    def __init__(self, path: str = ..., socket_timeout: Incomplete | None = ..., **kwargs) -> None: ...
    def repr_pieces(self): ...

FALSE_STRINGS: Incomplete

def to_bool(value): ...

URL_QUERY_ARGUMENT_PARSERS: Incomplete

def parse_url(url): ...

class ConnectionPool:
    @classmethod
    def from_url(cls, url, **kwargs): ...
    connection_class: Incomplete
    connection_kwargs: Incomplete
    max_connections: Incomplete
    def __init__(self, connection_class=..., max_connections: Optional[int] = ..., **connection_kwargs) -> None: ...
    pid: Incomplete
    def reset(self) -> None: ...
    def get_connection(self, command_name: str, *keys, **options) -> Connection: ...
    def get_encoder(self) -> Encoder: ...
    def make_connection(self) -> Connection: ...
    def release(self, connection: Connection) -> None: ...
    def owns_connection(self, connection: Connection) -> int: ...
    def disconnect(self, inuse_connections: bool = ...) -> None: ...
    def close(self) -> None: ...
    def set_retry(self, retry: Retry) -> None: ...

class BlockingConnectionPool(ConnectionPool):
    queue_class: Incomplete
    timeout: Incomplete
    def __init__(self, max_connections: int = ..., timeout: int = ..., connection_class=..., queue_class=..., **connection_kwargs) -> None: ...
    pool: Incomplete
    pid: Incomplete
    def reset(self) -> None: ...
    def make_connection(self): ...
    def get_connection(self, command_name, *keys, **options): ...
    def release(self, connection) -> None: ...
    def disconnect(self) -> None: ...
