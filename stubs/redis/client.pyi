import threading
from _typeshed import Incomplete
from collections.abc import Generator
from redis._parsers.encoders import Encoder as Encoder
from redis._parsers.helpers import bool_ok as bool_ok
from redis.commands import CoreCommands as CoreCommands, RedisModuleCommands as RedisModuleCommands, SentinelCommands as SentinelCommands, list_or_args as list_or_args
from redis.connection import ConnectionPool as ConnectionPool, SSLConnection as SSLConnection, UnixDomainSocketConnection as UnixDomainSocketConnection
from redis.credentials import CredentialProvider as CredentialProvider
from redis.exceptions import ConnectionError as ConnectionError, ExecAbortError as ExecAbortError, PubSubError as PubSubError, RedisError as RedisError, ResponseError as ResponseError, TimeoutError as TimeoutError, WatchError as WatchError
from redis.lock import Lock as Lock
from redis.retry import Retry as Retry
from redis.utils import HIREDIS_AVAILABLE as HIREDIS_AVAILABLE, get_lib_version as get_lib_version, safe_str as safe_str, str_if_bytes as str_if_bytes
from typing import Any, Callable, Dict, Optional, Union

SYM_EMPTY: bytes
EMPTY_RESPONSE: str
NEVER_DECODE: str

class CaseInsensitiveDict(dict):
    def __init__(self, data: Dict[str, str]) -> None: ...
    def __contains__(self, k) -> bool: ...
    def __delitem__(self, k) -> None: ...
    def __getitem__(self, k): ...
    def get(self, k, default: Incomplete | None = ...): ...
    def __setitem__(self, k, v) -> None: ...
    def update(self, data) -> None: ...

class AbstractRedis: ...

class Redis(RedisModuleCommands, CoreCommands, SentinelCommands):
    @classmethod
    def from_url(cls, url: str, **kwargs) -> None: ...
    @classmethod
    def from_pool(cls, connection_pool: ConnectionPool) -> Redis: ...
    auto_close_connection_pool: bool
    connection_pool: Incomplete
    connection: Incomplete
    response_callbacks: Incomplete
    def __init__(self, host: str = ..., port: int = ..., db: int = ..., password: Incomplete | None = ..., socket_timeout: Incomplete | None = ..., socket_connect_timeout: Incomplete | None = ..., socket_keepalive: Incomplete | None = ..., socket_keepalive_options: Incomplete | None = ..., connection_pool: Incomplete | None = ..., unix_socket_path: Incomplete | None = ..., encoding: str = ..., encoding_errors: str = ..., charset: Incomplete | None = ..., errors: Incomplete | None = ..., decode_responses: bool = ..., retry_on_timeout: bool = ..., retry_on_error: Incomplete | None = ..., ssl: bool = ..., ssl_keyfile: Incomplete | None = ..., ssl_certfile: Incomplete | None = ..., ssl_cert_reqs: str = ..., ssl_ca_certs: Incomplete | None = ..., ssl_ca_path: Incomplete | None = ..., ssl_ca_data: Incomplete | None = ..., ssl_check_hostname: bool = ..., ssl_password: Incomplete | None = ..., ssl_validate_ocsp: bool = ..., ssl_validate_ocsp_stapled: bool = ..., ssl_ocsp_context: Incomplete | None = ..., ssl_ocsp_expected_cert: Incomplete | None = ..., max_connections: Incomplete | None = ..., single_connection_client: bool = ..., health_check_interval: int = ..., client_name: Incomplete | None = ..., lib_name: str = ..., lib_version=..., username: Incomplete | None = ..., retry: Incomplete | None = ..., redis_connect_func: Incomplete | None = ..., credential_provider: Optional[CredentialProvider] = ..., protocol: Optional[int] = ...) -> None: ...
    def get_encoder(self) -> Encoder: ...
    def get_connection_kwargs(self) -> Dict: ...
    def get_retry(self) -> Optional['Retry']: ...
    def set_retry(self, retry: Retry) -> None: ...
    def set_response_callback(self, command: str, callback: Callable) -> None: ...
    def load_external_module(self, funcname, func) -> None: ...
    def pipeline(self, transaction: bool = ..., shard_hint: Incomplete | None = ...) -> Pipeline: ...
    def transaction(self, func: Callable[[Pipeline], None], *watches, **kwargs) -> None: ...
    def lock(self, name: str, timeout: Optional[float] = ..., sleep: float = ..., blocking: bool = ..., blocking_timeout: Optional[float] = ..., lock_class: Union[None, Any] = ..., thread_local: bool = ...): ...
    def pubsub(self, **kwargs): ...
    def monitor(self): ...
    def client(self): ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
    def __del__(self) -> None: ...
    def close(self) -> None: ...
    def execute_command(self, *args, **options): ...
    def parse_response(self, connection, command_name, **options): ...
StrictRedis = Redis

class Monitor:
    monitor_re: Incomplete
    command_re: Incomplete
    connection_pool: Incomplete
    connection: Incomplete
    def __init__(self, connection_pool) -> None: ...
    def __enter__(self): ...
    def __exit__(self, *args) -> None: ...
    def next_command(self): ...
    def listen(self) -> Generator[Incomplete, None, None]: ...

class PubSub:
    PUBLISH_MESSAGE_TYPES: Incomplete
    UNSUBSCRIBE_MESSAGE_TYPES: Incomplete
    HEALTH_CHECK_MESSAGE: str
    connection_pool: Incomplete
    shard_hint: Incomplete
    ignore_subscribe_messages: Incomplete
    connection: Incomplete
    subscribed_event: Incomplete
    encoder: Incomplete
    push_handler_func: Incomplete
    health_check_response_b: Incomplete
    health_check_response: Incomplete
    def __init__(self, connection_pool, shard_hint: Incomplete | None = ..., ignore_subscribe_messages: bool = ..., encoder: Optional['Encoder'] = ..., push_handler_func: Union[None, Callable[[str], None]] = ...) -> None: ...
    def __enter__(self) -> PubSub: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
    def __del__(self) -> None: ...
    health_check_response_counter: int
    channels: Incomplete
    pending_unsubscribe_channels: Incomplete
    shard_channels: Incomplete
    pending_unsubscribe_shard_channels: Incomplete
    patterns: Incomplete
    pending_unsubscribe_patterns: Incomplete
    def reset(self) -> None: ...
    def close(self) -> None: ...
    def on_connect(self, connection) -> None: ...
    @property
    def subscribed(self) -> bool: ...
    def execute_command(self, *args) -> None: ...
    def clean_health_check_responses(self) -> None: ...
    def parse_response(self, block: bool = ..., timeout: int = ...): ...
    def is_health_check_response(self, response) -> bool: ...
    def check_health(self) -> None: ...
    def psubscribe(self, *args, **kwargs): ...
    def punsubscribe(self, *args): ...
    def subscribe(self, *args, **kwargs): ...
    def unsubscribe(self, *args): ...
    def ssubscribe(self, *args, target_node: Incomplete | None = ..., **kwargs): ...
    def sunsubscribe(self, *args, target_node: Incomplete | None = ...): ...
    def listen(self) -> Generator[Incomplete, None, None]: ...
    def get_message(self, ignore_subscribe_messages: bool = ..., timeout: float = ...): ...
    get_sharded_message = get_message
    def ping(self, message: Union[str, None] = ...) -> bool: ...
    def handle_message(self, response, ignore_subscribe_messages: bool = ...): ...
    def run_in_thread(self, sleep_time: int = ..., daemon: bool = ..., exception_handler: Optional[Callable] = ...) -> PubSubWorkerThread: ...

class PubSubWorkerThread(threading.Thread):
    daemon: Incomplete
    pubsub: Incomplete
    sleep_time: Incomplete
    exception_handler: Incomplete
    def __init__(self, pubsub, sleep_time: float, daemon: bool = ..., exception_handler: Union[Callable[[Exception, PubSub, PubSubWorkerThread], None], None] = ...) -> None: ...
    def run(self) -> None: ...
    def stop(self) -> None: ...

class Pipeline(Redis):
    UNWATCH_COMMANDS: Incomplete
    connection_pool: Incomplete
    connection: Incomplete
    response_callbacks: Incomplete
    transaction: Incomplete
    shard_hint: Incomplete
    watching: bool
    def __init__(self, connection_pool, response_callbacks, transaction, shard_hint) -> None: ...
    def __enter__(self) -> Pipeline: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
    def __del__(self) -> None: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    command_stack: Incomplete
    scripts: Incomplete
    explicit_transaction: bool
    def reset(self) -> None: ...
    def close(self) -> None: ...
    def multi(self) -> None: ...
    def execute_command(self, *args, **kwargs): ...
    def immediate_execute_command(self, *args, **options): ...
    def pipeline_execute_command(self, *args, **options) -> Pipeline: ...
    def raise_first_error(self, commands, response) -> None: ...
    def annotate_exception(self, exception, number, command) -> None: ...
    def parse_response(self, connection, command_name, **options): ...
    def load_scripts(self) -> None: ...
    def execute(self, raise_on_error: bool = ...): ...
    def discard(self) -> None: ...
    def watch(self, *names): ...
    def unwatch(self) -> bool: ...
