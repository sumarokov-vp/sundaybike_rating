import abc
from _typeshed import Incomplete
from redis._parsers import CommandsParser as CommandsParser, Encoder as Encoder
from redis._parsers.helpers import parse_scan as parse_scan
from redis.backoff import default_backoff as default_backoff
from redis.client import CaseInsensitiveDict as CaseInsensitiveDict, PubSub as PubSub, Redis as Redis
from redis.commands import READ_COMMANDS as READ_COMMANDS, RedisClusterCommands as RedisClusterCommands
from redis.commands.helpers import list_or_args as list_or_args
from redis.connection import ConnectionPool as ConnectionPool, DefaultParser as DefaultParser, parse_url as parse_url
from redis.crc import REDIS_CLUSTER_HASH_SLOTS as REDIS_CLUSTER_HASH_SLOTS, key_slot as key_slot
from redis.exceptions import AskError as AskError, AuthenticationError as AuthenticationError, ClusterCrossSlotError as ClusterCrossSlotError, ClusterDownError as ClusterDownError, ClusterError as ClusterError, ConnectionError as ConnectionError, DataError as DataError, MasterDownError as MasterDownError, MovedError as MovedError, RedisClusterException as RedisClusterException, RedisError as RedisError, ResponseError as ResponseError, SlotNotCoveredError as SlotNotCoveredError, TimeoutError as TimeoutError, TryAgainError as TryAgainError
from redis.lock import Lock as Lock
from redis.retry import Retry as Retry
from redis.utils import HIREDIS_AVAILABLE as HIREDIS_AVAILABLE, dict_merge as dict_merge, list_keys_to_dict as list_keys_to_dict, merge_result as merge_result, safe_str as safe_str, str_if_bytes as str_if_bytes
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

def get_node_name(host: str, port: Union[str, int]) -> str: ...
def get_connection(redis_node, *args, **options): ...
def parse_scan_result(command, res, **options): ...
def parse_pubsub_numsub(command, res, **options): ...
def parse_cluster_slots(resp: Any, **options: Any) -> Dict[Tuple[int, int], Dict[str, Any]]: ...
def parse_cluster_shards(resp, **options): ...
def parse_cluster_myshardid(resp, **options): ...

PRIMARY: str
REPLICA: str
SLOT_ID: str
REDIS_ALLOWED_KEYS: Incomplete
KWARGS_DISABLED_KEYS: Incomplete

def cleanup_kwargs(**kwargs): ...

class ClusterParser(DefaultParser):
    EXCEPTION_CLASSES: Incomplete

class AbstractRedisCluster:
    RedisClusterRequestTTL: int
    PRIMARIES: str
    REPLICAS: str
    ALL_NODES: str
    RANDOM: str
    DEFAULT_NODE: str
    NODE_FLAGS: Incomplete
    COMMAND_FLAGS: Incomplete
    SEARCH_COMMANDS: Incomplete
    CLUSTER_COMMANDS_RESPONSE_CALLBACKS: Incomplete
    RESULT_CALLBACKS: Incomplete
    ERRORS_ALLOW_RETRY: Incomplete
    def replace_default_node(self, target_node: ClusterNode = ...) -> None: ...

class RedisCluster(AbstractRedisCluster, RedisClusterCommands, metaclass=abc.ABCMeta):
    @classmethod
    def from_url(cls, url, **kwargs): ...
    user_on_connect_func: Incomplete
    retry: Incomplete
    encoder: Incomplete
    cluster_error_retry_attempts: Incomplete
    command_flags: Incomplete
    node_flags: Incomplete
    read_from_replicas: Incomplete
    reinitialize_counter: int
    reinitialize_steps: Incomplete
    nodes_manager: Incomplete
    cluster_response_callbacks: Incomplete
    result_callbacks: Incomplete
    commands_parser: Incomplete
    def __init__(self, host: Optional[str] = ..., port: int = ..., startup_nodes: Optional[List['ClusterNode']] = ..., cluster_error_retry_attempts: int = ..., retry: Optional['Retry'] = ..., require_full_coverage: bool = ..., reinitialize_steps: int = ..., read_from_replicas: bool = ..., dynamic_startup_nodes: bool = ..., url: Optional[str] = ..., address_remap: Optional[Callable[[str, int], Tuple[str, int]]] = ..., **kwargs) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
    def __del__(self) -> None: ...
    def disconnect_connection_pools(self) -> None: ...
    def on_connect(self, connection) -> None: ...
    def get_redis_connection(self, node): ...
    def get_node(self, host: Incomplete | None = ..., port: Incomplete | None = ..., node_name: Incomplete | None = ...): ...
    def get_primaries(self): ...
    def get_replicas(self): ...
    def get_random_node(self): ...
    def get_nodes(self): ...
    def get_node_from_key(self, key, replica: bool = ...): ...
    def get_default_node(self): ...
    def set_default_node(self, node): ...
    def get_retry(self) -> Optional['Retry']: ...
    def set_retry(self, retry: Retry) -> None: ...
    def monitor(self, target_node: Incomplete | None = ...): ...
    def pubsub(self, node: Incomplete | None = ..., host: Incomplete | None = ..., port: Incomplete | None = ..., **kwargs): ...
    def pipeline(self, transaction: Incomplete | None = ..., shard_hint: Incomplete | None = ...): ...
    def lock(self, name, timeout: Incomplete | None = ..., sleep: float = ..., blocking: bool = ..., blocking_timeout: Incomplete | None = ..., lock_class: Incomplete | None = ..., thread_local: bool = ...): ...
    def set_response_callback(self, command, callback) -> None: ...
    def keyslot(self, key): ...
    def determine_slot(self, *args): ...
    def get_encoder(self): ...
    def get_connection_kwargs(self): ...
    def execute_command(self, *args, **kwargs): ...
    def close(self) -> None: ...
    def load_external_module(self, funcname, func) -> None: ...

class ClusterNode:
    host: Incomplete
    port: Incomplete
    name: Incomplete
    server_type: Incomplete
    redis_connection: Incomplete
    def __init__(self, host, port, server_type: Incomplete | None = ..., redis_connection: Incomplete | None = ...) -> None: ...
    def __eq__(self, obj): ...
    def __del__(self) -> None: ...

class LoadBalancer:
    primary_to_idx: Incomplete
    start_index: Incomplete
    def __init__(self, start_index: int = ...) -> None: ...
    def get_server_index(self, primary: str, list_size: int) -> int: ...
    def reset(self) -> None: ...

class NodesManager:
    nodes_cache: Incomplete
    slots_cache: Incomplete
    startup_nodes: Incomplete
    default_node: Incomplete
    from_url: Incomplete
    connection_pool_class: Incomplete
    address_remap: Incomplete
    connection_kwargs: Incomplete
    read_load_balancer: Incomplete
    def __init__(self, startup_nodes, from_url: bool = ..., require_full_coverage: bool = ..., lock: Incomplete | None = ..., dynamic_startup_nodes: bool = ..., connection_pool_class=..., address_remap: Optional[Callable[[str, int], Tuple[str, int]]] = ..., **kwargs) -> None: ...
    def get_node(self, host: Incomplete | None = ..., port: Incomplete | None = ..., node_name: Incomplete | None = ...): ...
    def update_moved_exception(self, exception) -> None: ...
    def get_node_from_slot(self, slot, read_from_replicas: bool = ..., server_type: Incomplete | None = ...): ...
    def get_nodes_by_server_type(self, server_type): ...
    def populate_startup_nodes(self, nodes) -> None: ...
    def check_slots_coverage(self, slots_cache): ...
    def create_redis_connections(self, nodes) -> None: ...
    def create_redis_node(self, host, port, **kwargs): ...
    def initialize(self) -> None: ...
    def close(self) -> None: ...
    def reset(self) -> None: ...
    def remap_host_port(self, host: str, port: int) -> Tuple[str, int]: ...

class ClusterPubSub(PubSub):
    node: Incomplete
    cluster: Incomplete
    node_pubsub_mapping: Incomplete
    def __init__(self, redis_cluster, node: Incomplete | None = ..., host: Incomplete | None = ..., port: Incomplete | None = ..., push_handler_func: Incomplete | None = ..., **kwargs) -> None: ...
    def set_pubsub_node(self, cluster, node: Incomplete | None = ..., host: Incomplete | None = ..., port: Incomplete | None = ...) -> None: ...
    def get_pubsub_node(self): ...
    connection_pool: Incomplete
    connection: Incomplete
    def execute_command(self, *args) -> None: ...
    def get_sharded_message(self, ignore_subscribe_messages: bool = ..., timeout: float = ..., target_node: Incomplete | None = ...): ...
    health_check_response_counter: int
    def ssubscribe(self, *args, **kwargs) -> None: ...
    def sunsubscribe(self, *args) -> None: ...
    def get_redis_connection(self): ...
    def disconnect(self) -> None: ...

class ClusterPipeline(RedisCluster, metaclass=abc.ABCMeta):
    ERRORS_ALLOW_RETRY: Incomplete
    command_stack: Incomplete
    nodes_manager: Incomplete
    commands_parser: Incomplete
    refresh_table_asap: bool
    result_callbacks: Incomplete
    startup_nodes: Incomplete
    read_from_replicas: Incomplete
    command_flags: Incomplete
    cluster_response_callbacks: Incomplete
    cluster_error_retry_attempts: Incomplete
    reinitialize_counter: int
    reinitialize_steps: Incomplete
    encoder: Incomplete
    def __init__(self, nodes_manager: NodesManager, commands_parser: CommandsParser, result_callbacks: Optional[Dict[str, Callable]] = ..., cluster_response_callbacks: Optional[Dict[str, Callable]] = ..., startup_nodes: Optional[List['ClusterNode']] = ..., read_from_replicas: bool = ..., cluster_error_retry_attempts: int = ..., reinitialize_steps: int = ..., lock: Incomplete | None = ..., **kwargs) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
    def __del__(self) -> None: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def execute_command(self, *args, **kwargs): ...
    def pipeline_execute_command(self, *args, **options): ...
    def raise_first_error(self, stack) -> None: ...
    def annotate_exception(self, exception, number, command) -> None: ...
    def execute(self, raise_on_error: bool = ...): ...
    scripts: Incomplete
    watching: bool
    explicit_transaction: bool
    def reset(self) -> None: ...
    def send_cluster_commands(self, stack, raise_on_error: bool = ..., allow_redirections: bool = ...): ...
    def exists(self, *keys): ...
    def eval(self) -> None: ...
    def multi(self) -> None: ...
    def immediate_execute_command(self, *args, **options) -> None: ...
    def load_scripts(self) -> None: ...
    def watch(self, *names) -> None: ...
    def unwatch(self) -> None: ...
    def script_load_for_pipeline(self, *args, **kwargs) -> None: ...
    def delete(self, *names): ...
    def unlink(self, *names): ...

def block_pipeline_command(name: str) -> Callable[..., Any]: ...

PIPELINE_BLOCKED_COMMANDS: Incomplete
command: Incomplete

class PipelineCommand:
    args: Incomplete
    options: Incomplete
    position: Incomplete
    result: Incomplete
    node: Incomplete
    asking: bool
    def __init__(self, args, options: Incomplete | None = ..., position: Incomplete | None = ...) -> None: ...

class NodeCommands:
    parse_response: Incomplete
    connection_pool: Incomplete
    connection: Incomplete
    commands: Incomplete
    def __init__(self, parse_response, connection_pool, connection) -> None: ...
    def append(self, c) -> None: ...
    def write(self) -> None: ...
    def read(self) -> None: ...
