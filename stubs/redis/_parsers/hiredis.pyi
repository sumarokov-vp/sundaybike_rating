from ..exceptions import ConnectionError as ConnectionError, InvalidResponse as InvalidResponse, RedisError as RedisError
from ..typing import EncodableT as EncodableT
from ..utils import HIREDIS_AVAILABLE as HIREDIS_AVAILABLE
from .base import AsyncBaseParser as AsyncBaseParser, BaseParser as BaseParser
from .socket import NONBLOCKING_EXCEPTIONS as NONBLOCKING_EXCEPTIONS, NONBLOCKING_EXCEPTION_ERROR_NUMBERS as NONBLOCKING_EXCEPTION_ERROR_NUMBERS, SENTINEL as SENTINEL, SERVER_CLOSED_CONNECTION_ERROR as SERVER_CLOSED_CONNECTION_ERROR
from _typeshed import Incomplete
from redis.compat import TypedDict as TypedDict
from typing import Callable, List, Optional, Union

class _HiredisReaderArgs(TypedDict, total=False):
    protocolError: Callable[[str], Exception]
    replyError: Callable[[str], Exception]
    encoding: Optional[str]
    errors: Optional[str]

class _HiredisParser(BaseParser):
    socket_read_size: Incomplete
    def __init__(self, socket_read_size) -> None: ...
    def __del__(self) -> None: ...
    def on_connect(self, connection, **kwargs) -> None: ...
    def on_disconnect(self) -> None: ...
    def can_read(self, timeout): ...
    def read_from_socket(self, timeout=..., raise_on_timeout: bool = ...): ...
    def read_response(self, disable_decoding: bool = ...): ...

class _AsyncHiredisParser(AsyncBaseParser):
    def __init__(self, socket_read_size: int) -> None: ...
    def on_connect(self, connection) -> None: ...
    def on_disconnect(self) -> None: ...
    async def can_read_destructive(self): ...
    async def read_from_socket(self): ...
    async def read_response(self, disable_decoding: bool = ...) -> Union[EncodableT, List[EncodableT]]: ...
