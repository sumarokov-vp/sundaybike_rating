from _typeshed import Incomplete
from redis.exceptions import LockError as LockError, LockNotOwnedError as LockNotOwnedError
from redis.typing import Number as Number
from types import TracebackType
from typing import Optional, Type

class Lock:
    lua_release: Incomplete
    lua_extend: Incomplete
    lua_reacquire: Incomplete
    LUA_RELEASE_SCRIPT: str
    LUA_EXTEND_SCRIPT: str
    LUA_REACQUIRE_SCRIPT: str
    redis: Incomplete
    name: Incomplete
    timeout: Incomplete
    sleep: Incomplete
    blocking: Incomplete
    blocking_timeout: Incomplete
    thread_local: Incomplete
    local: Incomplete
    def __init__(self, redis, name: str, timeout: Optional[Number] = ..., sleep: Number = ..., blocking: bool = ..., blocking_timeout: Optional[Number] = ..., thread_local: bool = ...) -> None: ...
    def register_scripts(self) -> None: ...
    def __enter__(self) -> Lock: ...
    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]) -> None: ...
    def acquire(self, sleep: Optional[Number] = ..., blocking: Optional[bool] = ..., blocking_timeout: Optional[Number] = ..., token: Optional[str] = ...): ...
    def do_acquire(self, token: str) -> bool: ...
    def locked(self) -> bool: ...
    def owned(self) -> bool: ...
    def release(self) -> None: ...
    def do_release(self, expected_token: str) -> None: ...
    def extend(self, additional_time: int, replace_ttl: bool = ...) -> bool: ...
    def do_extend(self, additional_time: int, replace_ttl: bool) -> bool: ...
    def reacquire(self) -> bool: ...
    def do_reacquire(self) -> bool: ...
