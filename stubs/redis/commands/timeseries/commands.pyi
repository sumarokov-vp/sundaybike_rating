from redis.exceptions import DataError as DataError
from redis.typing import KeyT as KeyT, Number as Number
from typing import Dict, List, Optional, Tuple, Union

ADD_CMD: str
ALTER_CMD: str
CREATERULE_CMD: str
CREATE_CMD: str
DECRBY_CMD: str
DELETERULE_CMD: str
DEL_CMD: str
GET_CMD: str
INCRBY_CMD: str
INFO_CMD: str
MADD_CMD: str
MGET_CMD: str
MRANGE_CMD: str
MREVRANGE_CMD: str
QUERYINDEX_CMD: str
RANGE_CMD: str
REVRANGE_CMD: str

class TimeSeriesCommands:
    def create(self, key: KeyT, retention_msecs: Optional[int] = ..., uncompressed: Optional[bool] = ..., labels: Optional[Dict[str, str]] = ..., chunk_size: Optional[int] = ..., duplicate_policy: Optional[str] = ...): ...
    def alter(self, key: KeyT, retention_msecs: Optional[int] = ..., labels: Optional[Dict[str, str]] = ..., chunk_size: Optional[int] = ..., duplicate_policy: Optional[str] = ...): ...
    def add(self, key: KeyT, timestamp: Union[int, str], value: Number, retention_msecs: Optional[int] = ..., uncompressed: Optional[bool] = ..., labels: Optional[Dict[str, str]] = ..., chunk_size: Optional[int] = ..., duplicate_policy: Optional[str] = ...): ...
    def madd(self, ktv_tuples: List[Tuple[KeyT, Union[int, str], Number]]): ...
    def incrby(self, key: KeyT, value: Number, timestamp: Optional[Union[int, str]] = ..., retention_msecs: Optional[int] = ..., uncompressed: Optional[bool] = ..., labels: Optional[Dict[str, str]] = ..., chunk_size: Optional[int] = ...): ...
    def decrby(self, key: KeyT, value: Number, timestamp: Optional[Union[int, str]] = ..., retention_msecs: Optional[int] = ..., uncompressed: Optional[bool] = ..., labels: Optional[Dict[str, str]] = ..., chunk_size: Optional[int] = ...): ...
    def delete(self, key: KeyT, from_time: int, to_time: int): ...
    def createrule(self, source_key: KeyT, dest_key: KeyT, aggregation_type: str, bucket_size_msec: int, align_timestamp: Optional[int] = ...): ...
    def deleterule(self, source_key: KeyT, dest_key: KeyT): ...
    def range(self, key: KeyT, from_time: Union[int, str], to_time: Union[int, str], count: Optional[int] = ..., aggregation_type: Optional[str] = ..., bucket_size_msec: Optional[int] = ..., filter_by_ts: Optional[List[int]] = ..., filter_by_min_value: Optional[int] = ..., filter_by_max_value: Optional[int] = ..., align: Optional[Union[int, str]] = ..., latest: Optional[bool] = ..., bucket_timestamp: Optional[str] = ..., empty: Optional[bool] = ...): ...
    def revrange(self, key: KeyT, from_time: Union[int, str], to_time: Union[int, str], count: Optional[int] = ..., aggregation_type: Optional[str] = ..., bucket_size_msec: Optional[int] = ..., filter_by_ts: Optional[List[int]] = ..., filter_by_min_value: Optional[int] = ..., filter_by_max_value: Optional[int] = ..., align: Optional[Union[int, str]] = ..., latest: Optional[bool] = ..., bucket_timestamp: Optional[str] = ..., empty: Optional[bool] = ...): ...
    def mrange(self, from_time: Union[int, str], to_time: Union[int, str], filters: List[str], count: Optional[int] = ..., aggregation_type: Optional[str] = ..., bucket_size_msec: Optional[int] = ..., with_labels: Optional[bool] = ..., filter_by_ts: Optional[List[int]] = ..., filter_by_min_value: Optional[int] = ..., filter_by_max_value: Optional[int] = ..., groupby: Optional[str] = ..., reduce: Optional[str] = ..., select_labels: Optional[List[str]] = ..., align: Optional[Union[int, str]] = ..., latest: Optional[bool] = ..., bucket_timestamp: Optional[str] = ..., empty: Optional[bool] = ...): ...
    def mrevrange(self, from_time: Union[int, str], to_time: Union[int, str], filters: List[str], count: Optional[int] = ..., aggregation_type: Optional[str] = ..., bucket_size_msec: Optional[int] = ..., with_labels: Optional[bool] = ..., filter_by_ts: Optional[List[int]] = ..., filter_by_min_value: Optional[int] = ..., filter_by_max_value: Optional[int] = ..., groupby: Optional[str] = ..., reduce: Optional[str] = ..., select_labels: Optional[List[str]] = ..., align: Optional[Union[int, str]] = ..., latest: Optional[bool] = ..., bucket_timestamp: Optional[str] = ..., empty: Optional[bool] = ...): ...
    def get(self, key: KeyT, latest: Optional[bool] = ...): ...
    def mget(self, filters: List[str], with_labels: Optional[bool] = ..., select_labels: Optional[List[str]] = ..., latest: Optional[bool] = ...): ...
    def info(self, key: KeyT): ...
    def queryindex(self, filters: List[str]): ...
