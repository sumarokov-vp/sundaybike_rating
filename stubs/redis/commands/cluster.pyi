import abc
from .core import ACLCommands as ACLCommands, AsyncACLCommands as AsyncACLCommands, AsyncDataAccessCommands as AsyncDataAccessCommands, AsyncFunctionCommands as AsyncFunctionCommands, AsyncGearsCommands as AsyncGearsCommands, AsyncManagementCommands as AsyncManagementCommands, AsyncModuleCommands as AsyncModuleCommands, AsyncScriptCommands as AsyncScriptCommands, DataAccessCommands as DataAccessCommands, FunctionCommands as FunctionCommands, GearsCommands as GearsCommands, ManagementCommands as ManagementCommands, ModuleCommands as ModuleCommands, PubSubCommands as PubSubCommands, ResponseT as ResponseT, ScriptCommands as ScriptCommands
from .helpers import list_or_args as list_or_args
from .redismodules import RedisModuleCommands as RedisModuleCommands
from _typeshed import Incomplete
from redis.asyncio.cluster import TargetNodesT as TargetNodesT
from redis.compat import Literal as Literal
from redis.crc import key_slot as key_slot
from redis.exceptions import RedisClusterException as RedisClusterException, RedisError as RedisError
from redis.typing import AnyKeyT as AnyKeyT, ClusterCommandsProtocol as ClusterCommandsProtocol, EncodableT as EncodableT, KeyT as KeyT, KeysT as KeysT, PatternT as PatternT
from typing import Any, AsyncIterator, Iterator, List, Mapping, NoReturn, Optional, Union

READ_COMMANDS: Incomplete

class ClusterMultiKeyCommands(ClusterCommandsProtocol, metaclass=abc.ABCMeta):
    def mget_nonatomic(self, keys: KeysT, *args: KeyT) -> List[Optional[Any]]: ...
    def mset_nonatomic(self, mapping: Mapping[AnyKeyT, EncodableT]) -> List[bool]: ...
    def exists(self, *keys: KeyT) -> ResponseT: ...
    def delete(self, *keys: KeyT) -> ResponseT: ...
    def touch(self, *keys: KeyT) -> ResponseT: ...
    def unlink(self, *keys: KeyT) -> ResponseT: ...

class AsyncClusterMultiKeyCommands(ClusterMultiKeyCommands, metaclass=abc.ABCMeta):
    async def mget_nonatomic(self, keys: KeysT, *args: KeyT) -> List[Optional[Any]]: ...
    async def mset_nonatomic(self, mapping: Mapping[AnyKeyT, EncodableT]) -> List[bool]: ...

class ClusterManagementCommands(ManagementCommands, metaclass=abc.ABCMeta):
    def slaveof(self, *args, **kwargs) -> NoReturn: ...
    def replicaof(self, *args, **kwargs) -> NoReturn: ...
    def swapdb(self, *args, **kwargs) -> NoReturn: ...
    def cluster_myid(self, target_node: TargetNodesT) -> ResponseT: ...
    def cluster_addslots(self, target_node: TargetNodesT, *slots: EncodableT) -> ResponseT: ...
    def cluster_addslotsrange(self, target_node: TargetNodesT, *slots: EncodableT) -> ResponseT: ...
    def cluster_countkeysinslot(self, slot_id: int) -> ResponseT: ...
    def cluster_count_failure_report(self, node_id: str) -> ResponseT: ...
    def cluster_delslots(self, *slots: EncodableT) -> List[bool]: ...
    def cluster_delslotsrange(self, *slots: EncodableT) -> ResponseT: ...
    def cluster_failover(self, target_node: TargetNodesT, option: Optional[str] = ...) -> ResponseT: ...
    def cluster_info(self, target_nodes: Optional['TargetNodesT'] = ...) -> ResponseT: ...
    def cluster_keyslot(self, key: str) -> ResponseT: ...
    def cluster_meet(self, host: str, port: int, target_nodes: Optional['TargetNodesT'] = ...) -> ResponseT: ...
    def cluster_nodes(self) -> ResponseT: ...
    def cluster_replicate(self, target_nodes: TargetNodesT, node_id: str) -> ResponseT: ...
    def cluster_reset(self, soft: bool = ..., target_nodes: Optional['TargetNodesT'] = ...) -> ResponseT: ...
    def cluster_save_config(self, target_nodes: Optional['TargetNodesT'] = ...) -> ResponseT: ...
    def cluster_get_keys_in_slot(self, slot: int, num_keys: int) -> ResponseT: ...
    def cluster_set_config_epoch(self, epoch: int, target_nodes: Optional['TargetNodesT'] = ...) -> ResponseT: ...
    def cluster_setslot(self, target_node: TargetNodesT, node_id: str, slot_id: int, state: str) -> ResponseT: ...
    def cluster_setslot_stable(self, slot_id: int) -> ResponseT: ...
    def cluster_replicas(self, node_id: str, target_nodes: Optional['TargetNodesT'] = ...) -> ResponseT: ...
    def cluster_slots(self, target_nodes: Optional['TargetNodesT'] = ...) -> ResponseT: ...
    def cluster_shards(self, target_nodes: Incomplete | None = ...): ...
    def cluster_myshardid(self, target_nodes: Incomplete | None = ...): ...
    def cluster_links(self, target_node: TargetNodesT) -> ResponseT: ...
    def cluster_flushslots(self, target_nodes: Optional['TargetNodesT'] = ...) -> None: ...
    def cluster_bumpepoch(self, target_nodes: Optional['TargetNodesT'] = ...) -> None: ...
    read_from_replicas: bool
    def readonly(self, target_nodes: Optional['TargetNodesT'] = ...) -> ResponseT: ...
    def readwrite(self, target_nodes: Optional['TargetNodesT'] = ...) -> ResponseT: ...
    def gears_refresh_cluster(self, **kwargs) -> ResponseT: ...

class AsyncClusterManagementCommands(ClusterManagementCommands, AsyncManagementCommands, metaclass=abc.ABCMeta):
    async def cluster_delslots(self, *slots: EncodableT) -> List[bool]: ...

class ClusterDataAccessCommands(DataAccessCommands, metaclass=abc.ABCMeta):
    def stralgo(self, algo: Literal['LCS'], value1: KeyT, value2: KeyT, specific_argument: Union[Literal['strings'], Literal['keys']] = ..., len: bool = ..., idx: bool = ..., minmatchlen: Optional[int] = ..., withmatchlen: bool = ..., **kwargs) -> ResponseT: ...
    def scan_iter(self, match: Optional[PatternT] = ..., count: Optional[int] = ..., _type: Optional[str] = ..., **kwargs) -> Iterator: ...

class AsyncClusterDataAccessCommands(ClusterDataAccessCommands, AsyncDataAccessCommands, metaclass=abc.ABCMeta):
    async def scan_iter(self, match: Optional[PatternT] = ..., count: Optional[int] = ..., _type: Optional[str] = ..., **kwargs) -> AsyncIterator: ...

class RedisClusterCommands(ClusterMultiKeyCommands, ClusterManagementCommands, ACLCommands, PubSubCommands, ClusterDataAccessCommands, ScriptCommands, FunctionCommands, GearsCommands, ModuleCommands, RedisModuleCommands, metaclass=abc.ABCMeta): ...
class AsyncRedisClusterCommands(AsyncClusterMultiKeyCommands, AsyncClusterManagementCommands, AsyncACLCommands, AsyncClusterDataAccessCommands, AsyncScriptCommands, AsyncFunctionCommands, AsyncGearsCommands, AsyncModuleCommands, metaclass=abc.ABCMeta): ...
