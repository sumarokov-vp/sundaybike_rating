import abc
from .helpers import list_or_args as list_or_args
from _typeshed import Incomplete
from redis.asyncio.client import Redis as AsyncRedis
from redis.client import Redis as Redis
from redis.compat import Literal as Literal
from redis.exceptions import ConnectionError as ConnectionError, DataError as DataError, NoScriptError as NoScriptError, RedisError as RedisError
from redis.typing import AbsExpiryT as AbsExpiryT, AnyKeyT as AnyKeyT, BitfieldOffsetT as BitfieldOffsetT, ChannelT as ChannelT, CommandsProtocol as CommandsProtocol, ConsumerT as ConsumerT, EncodableT as EncodableT, ExpiryT as ExpiryT, FieldT as FieldT, GroupT as GroupT, KeyT as KeyT, KeysT as KeysT, PatternT as PatternT, ScriptTextT as ScriptTextT, StreamIdT as StreamIdT, TimeoutSecT as TimeoutSecT, ZScoreBoundT as ZScoreBoundT
from typing import Any, AsyncIterator, Awaitable, Callable, Dict, Iterable, Iterator, List, Mapping, Optional, Sequence, Set, Tuple, Union

ResponseT = Union[Awaitable, Any]

class ACLCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def acl_cat(self, category: Union[str, None] = ..., **kwargs) -> ResponseT: ...
    def acl_dryrun(self, username, *args, **kwargs): ...
    def acl_deluser(self, *username: str, **kwargs) -> ResponseT: ...
    def acl_genpass(self, bits: Union[int, None] = ..., **kwargs) -> ResponseT: ...
    def acl_getuser(self, username: str, **kwargs) -> ResponseT: ...
    def acl_help(self, **kwargs) -> ResponseT: ...
    def acl_list(self, **kwargs) -> ResponseT: ...
    def acl_log(self, count: Union[int, None] = ..., **kwargs) -> ResponseT: ...
    def acl_log_reset(self, **kwargs) -> ResponseT: ...
    def acl_load(self, **kwargs) -> ResponseT: ...
    def acl_save(self, **kwargs) -> ResponseT: ...
    def acl_setuser(self, username: str, enabled: bool = ..., nopass: bool = ..., passwords: Union[str, Iterable[str], None] = ..., hashed_passwords: Union[str, Iterable[str], None] = ..., categories: Optional[Iterable[str]] = ..., commands: Optional[Iterable[str]] = ..., keys: Optional[Iterable[KeyT]] = ..., channels: Optional[Iterable[ChannelT]] = ..., selectors: Optional[Iterable[Tuple[str, KeyT]]] = ..., reset: bool = ..., reset_keys: bool = ..., reset_channels: bool = ..., reset_passwords: bool = ..., **kwargs) -> ResponseT: ...
    def acl_users(self, **kwargs) -> ResponseT: ...
    def acl_whoami(self, **kwargs) -> ResponseT: ...
AsyncACLCommands = ACLCommands

class ManagementCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def auth(self, password: str, username: Optional[str] = ..., **kwargs): ...
    def bgrewriteaof(self, **kwargs): ...
    def bgsave(self, schedule: bool = ..., **kwargs) -> ResponseT: ...
    def role(self) -> ResponseT: ...
    def client_kill(self, address: str, **kwargs) -> ResponseT: ...
    def client_kill_filter(self, _id: Union[str, None] = ..., _type: Union[str, None] = ..., addr: Union[str, None] = ..., skipme: Union[bool, None] = ..., laddr: Union[bool, None] = ..., user: str = ..., **kwargs) -> ResponseT: ...
    def client_info(self, **kwargs) -> ResponseT: ...
    def client_list(self, _type: Union[str, None] = ..., client_id: List[EncodableT] = ..., **kwargs) -> ResponseT: ...
    def client_getname(self, **kwargs) -> ResponseT: ...
    def client_getredir(self, **kwargs) -> ResponseT: ...
    def client_reply(self, reply: Union[Literal['ON'], Literal['OFF'], Literal['SKIP']], **kwargs) -> ResponseT: ...
    def client_id(self, **kwargs) -> ResponseT: ...
    def client_tracking_on(self, clientid: Union[int, None] = ..., prefix: Sequence[KeyT] = ..., bcast: bool = ..., optin: bool = ..., optout: bool = ..., noloop: bool = ...) -> ResponseT: ...
    def client_tracking_off(self, clientid: Union[int, None] = ..., prefix: Sequence[KeyT] = ..., bcast: bool = ..., optin: bool = ..., optout: bool = ..., noloop: bool = ...) -> ResponseT: ...
    def client_tracking(self, on: bool = ..., clientid: Union[int, None] = ..., prefix: Sequence[KeyT] = ..., bcast: bool = ..., optin: bool = ..., optout: bool = ..., noloop: bool = ..., **kwargs) -> ResponseT: ...
    def client_trackinginfo(self, **kwargs) -> ResponseT: ...
    def client_setname(self, name: str, **kwargs) -> ResponseT: ...
    def client_setinfo(self, attr: str, value: str, **kwargs) -> ResponseT: ...
    def client_unblock(self, client_id: int, error: bool = ..., **kwargs) -> ResponseT: ...
    def client_pause(self, timeout: int, all: bool = ..., **kwargs) -> ResponseT: ...
    def client_unpause(self, **kwargs) -> ResponseT: ...
    def client_no_evict(self, mode: str) -> Union[Awaitable[str], str]: ...
    def client_no_touch(self, mode: str) -> Union[Awaitable[str], str]: ...
    def command(self, **kwargs): ...
    def command_info(self, **kwargs) -> None: ...
    def command_count(self, **kwargs) -> ResponseT: ...
    def command_list(self, module: Optional[str] = ..., category: Optional[str] = ..., pattern: Optional[str] = ...) -> ResponseT: ...
    def command_getkeysandflags(self, *args: List[str]) -> List[Union[str, List[str]]]: ...
    def command_docs(self, *args) -> None: ...
    def config_get(self, pattern: PatternT = ..., *args: List[PatternT], **kwargs) -> ResponseT: ...
    def config_set(self, name: KeyT, value: EncodableT, *args: List[Union[KeyT, EncodableT]], **kwargs) -> ResponseT: ...
    def config_resetstat(self, **kwargs) -> ResponseT: ...
    def config_rewrite(self, **kwargs) -> ResponseT: ...
    def dbsize(self, **kwargs) -> ResponseT: ...
    def debug_object(self, key: KeyT, **kwargs) -> ResponseT: ...
    def debug_segfault(self, **kwargs) -> None: ...
    def echo(self, value: EncodableT, **kwargs) -> ResponseT: ...
    def flushall(self, asynchronous: bool = ..., **kwargs) -> ResponseT: ...
    def flushdb(self, asynchronous: bool = ..., **kwargs) -> ResponseT: ...
    def sync(self) -> ResponseT: ...
    def psync(self, replicationid: str, offset: int): ...
    def swapdb(self, first: int, second: int, **kwargs) -> ResponseT: ...
    def select(self, index: int, **kwargs) -> ResponseT: ...
    def info(self, section: Union[str, None] = ..., *args: List[str], **kwargs) -> ResponseT: ...
    def lastsave(self, **kwargs) -> ResponseT: ...
    def latency_doctor(self) -> None: ...
    def latency_graph(self) -> None: ...
    def lolwut(self, *version_numbers: Union[str, float], **kwargs) -> ResponseT: ...
    def reset(self) -> ResponseT: ...
    def migrate(self, host: str, port: int, keys: KeysT, destination_db: int, timeout: int, copy: bool = ..., replace: bool = ..., auth: Union[str, None] = ..., **kwargs) -> ResponseT: ...
    def object(self, infotype: str, key: KeyT, **kwargs) -> ResponseT: ...
    def memory_doctor(self, **kwargs) -> None: ...
    def memory_help(self, **kwargs) -> None: ...
    def memory_stats(self, **kwargs) -> ResponseT: ...
    def memory_malloc_stats(self, **kwargs) -> ResponseT: ...
    def memory_usage(self, key: KeyT, samples: Union[int, None] = ..., **kwargs) -> ResponseT: ...
    def memory_purge(self, **kwargs) -> ResponseT: ...
    def latency_histogram(self, *args) -> None: ...
    def latency_history(self, event: str) -> ResponseT: ...
    def latency_latest(self) -> ResponseT: ...
    def latency_reset(self, *events: str) -> ResponseT: ...
    def ping(self, **kwargs) -> ResponseT: ...
    def quit(self, **kwargs) -> ResponseT: ...
    def replicaof(self, *args, **kwargs) -> ResponseT: ...
    def save(self, **kwargs) -> ResponseT: ...
    def shutdown(self, save: bool = ..., nosave: bool = ..., now: bool = ..., force: bool = ..., abort: bool = ..., **kwargs) -> None: ...
    def slaveof(self, host: Union[str, None] = ..., port: Union[int, None] = ..., **kwargs) -> ResponseT: ...
    def slowlog_get(self, num: Union[int, None] = ..., **kwargs) -> ResponseT: ...
    def slowlog_len(self, **kwargs) -> ResponseT: ...
    def slowlog_reset(self, **kwargs) -> ResponseT: ...
    def time(self, **kwargs) -> ResponseT: ...
    def wait(self, num_replicas: int, timeout: int, **kwargs) -> ResponseT: ...
    def waitaof(self, num_local: int, num_replicas: int, timeout: int, **kwargs) -> ResponseT: ...
    def hello(self) -> None: ...
    def failover(self) -> None: ...
AsyncManagementCommands = ManagementCommands

class AsyncManagementCommands(ManagementCommands, metaclass=abc.ABCMeta):
    async def command_info(self, **kwargs) -> None: ...
    async def debug_segfault(self, **kwargs) -> None: ...
    async def memory_doctor(self, **kwargs) -> None: ...
    async def memory_help(self, **kwargs) -> None: ...
    async def shutdown(self, save: bool = ..., nosave: bool = ..., now: bool = ..., force: bool = ..., abort: bool = ..., **kwargs) -> None: ...

class BitFieldOperation:
    client: Incomplete
    key: Incomplete
    operations: Incomplete
    def __init__(self, client: Union['Redis', 'AsyncRedis'], key: str, default_overflow: Union[str, None] = ...) -> None: ...
    def reset(self) -> None: ...
    def overflow(self, overflow: str): ...
    def incrby(self, fmt: str, offset: BitfieldOffsetT, increment: int, overflow: Union[str, None] = ...): ...
    def get(self, fmt: str, offset: BitfieldOffsetT): ...
    def set(self, fmt: str, offset: BitfieldOffsetT, value: int): ...
    @property
    def command(self): ...
    def execute(self) -> ResponseT: ...

class BasicKeyCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def append(self, key: KeyT, value: EncodableT) -> ResponseT: ...
    def bitcount(self, key: KeyT, start: Union[int, None] = ..., end: Union[int, None] = ..., mode: Optional[str] = ...) -> ResponseT: ...
    def bitfield(self, key: KeyT, default_overflow: Union[str, None] = ...) -> BitFieldOperation: ...
    def bitfield_ro(self, key: KeyT, encoding: str, offset: BitfieldOffsetT, items: Optional[list] = ...) -> ResponseT: ...
    def bitop(self, operation: str, dest: KeyT, *keys: KeyT) -> ResponseT: ...
    def bitpos(self, key: KeyT, bit: int, start: Union[int, None] = ..., end: Union[int, None] = ..., mode: Optional[str] = ...) -> ResponseT: ...
    def copy(self, source: str, destination: str, destination_db: Union[str, None] = ..., replace: bool = ...) -> ResponseT: ...
    def decrby(self, name: KeyT, amount: int = ...) -> ResponseT: ...
    decr = decrby
    def delete(self, *names: KeyT) -> ResponseT: ...
    def __delitem__(self, name: KeyT): ...
    def dump(self, name: KeyT) -> ResponseT: ...
    def exists(self, *names: KeyT) -> ResponseT: ...
    __contains__ = exists
    def expire(self, name: KeyT, time: ExpiryT, nx: bool = ..., xx: bool = ..., gt: bool = ..., lt: bool = ...) -> ResponseT: ...
    def expireat(self, name: KeyT, when: AbsExpiryT, nx: bool = ..., xx: bool = ..., gt: bool = ..., lt: bool = ...) -> ResponseT: ...
    def expiretime(self, key: str) -> int: ...
    def get(self, name: KeyT) -> ResponseT: ...
    def getdel(self, name: KeyT) -> ResponseT: ...
    def getex(self, name: KeyT, ex: Union[ExpiryT, None] = ..., px: Union[ExpiryT, None] = ..., exat: Union[AbsExpiryT, None] = ..., pxat: Union[AbsExpiryT, None] = ..., persist: bool = ...) -> ResponseT: ...
    def __getitem__(self, name: KeyT): ...
    def getbit(self, name: KeyT, offset: int) -> ResponseT: ...
    def getrange(self, key: KeyT, start: int, end: int) -> ResponseT: ...
    def getset(self, name: KeyT, value: EncodableT) -> ResponseT: ...
    def incrby(self, name: KeyT, amount: int = ...) -> ResponseT: ...
    incr = incrby
    def incrbyfloat(self, name: KeyT, amount: float = ...) -> ResponseT: ...
    def keys(self, pattern: PatternT = ..., **kwargs) -> ResponseT: ...
    def lmove(self, first_list: str, second_list: str, src: str = ..., dest: str = ...) -> ResponseT: ...
    def blmove(self, first_list: str, second_list: str, timeout: int, src: str = ..., dest: str = ...) -> ResponseT: ...
    def mget(self, keys: KeysT, *args: EncodableT) -> ResponseT: ...
    def mset(self, mapping: Mapping[AnyKeyT, EncodableT]) -> ResponseT: ...
    def msetnx(self, mapping: Mapping[AnyKeyT, EncodableT]) -> ResponseT: ...
    def move(self, name: KeyT, db: int) -> ResponseT: ...
    def persist(self, name: KeyT) -> ResponseT: ...
    def pexpire(self, name: KeyT, time: ExpiryT, nx: bool = ..., xx: bool = ..., gt: bool = ..., lt: bool = ...) -> ResponseT: ...
    def pexpireat(self, name: KeyT, when: AbsExpiryT, nx: bool = ..., xx: bool = ..., gt: bool = ..., lt: bool = ...) -> ResponseT: ...
    def pexpiretime(self, key: str) -> int: ...
    def psetex(self, name: KeyT, time_ms: ExpiryT, value: EncodableT): ...
    def pttl(self, name: KeyT) -> ResponseT: ...
    def hrandfield(self, key: str, count: int = ..., withvalues: bool = ...) -> ResponseT: ...
    def randomkey(self, **kwargs) -> ResponseT: ...
    def rename(self, src: KeyT, dst: KeyT) -> ResponseT: ...
    def renamenx(self, src: KeyT, dst: KeyT): ...
    def restore(self, name: KeyT, ttl: float, value: EncodableT, replace: bool = ..., absttl: bool = ..., idletime: Union[int, None] = ..., frequency: Union[int, None] = ...) -> ResponseT: ...
    def set(self, name: KeyT, value: EncodableT, ex: Union[ExpiryT, None] = ..., px: Union[ExpiryT, None] = ..., nx: bool = ..., xx: bool = ..., keepttl: bool = ..., get: bool = ..., exat: Union[AbsExpiryT, None] = ..., pxat: Union[AbsExpiryT, None] = ...) -> ResponseT: ...
    def __setitem__(self, name: KeyT, value: EncodableT): ...
    def setbit(self, name: KeyT, offset: int, value: int) -> ResponseT: ...
    def setex(self, name: KeyT, time: ExpiryT, value: EncodableT) -> ResponseT: ...
    def setnx(self, name: KeyT, value: EncodableT) -> ResponseT: ...
    def setrange(self, name: KeyT, offset: int, value: EncodableT) -> ResponseT: ...
    def stralgo(self, algo: Literal['LCS'], value1: KeyT, value2: KeyT, specific_argument: Union[Literal['strings'], Literal['keys']] = ..., len: bool = ..., idx: bool = ..., minmatchlen: Union[int, None] = ..., withmatchlen: bool = ..., **kwargs) -> ResponseT: ...
    def strlen(self, name: KeyT) -> ResponseT: ...
    def substr(self, name: KeyT, start: int, end: int = ...) -> ResponseT: ...
    def touch(self, *args: KeyT) -> ResponseT: ...
    def ttl(self, name: KeyT) -> ResponseT: ...
    def type(self, name: KeyT) -> ResponseT: ...
    def watch(self, *names: KeyT) -> None: ...
    def unwatch(self) -> None: ...
    def unlink(self, *names: KeyT) -> ResponseT: ...
    def lcs(self, key1: str, key2: str, len: Optional[bool] = ..., idx: Optional[bool] = ..., minmatchlen: Optional[int] = ..., withmatchlen: Optional[bool] = ...) -> Union[str, int, list]: ...

class AsyncBasicKeyCommands(BasicKeyCommands, metaclass=abc.ABCMeta):
    def __delitem__(self, name: KeyT): ...
    def __contains__(self, name: KeyT): ...
    def __getitem__(self, name: KeyT): ...
    def __setitem__(self, name: KeyT, value: EncodableT): ...
    async def watch(self, *names: KeyT) -> None: ...
    async def unwatch(self) -> None: ...

class ListCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def blpop(self, keys: List, timeout: Optional[int] = ...) -> Union[Awaitable[list], list]: ...
    def brpop(self, keys: List, timeout: Optional[int] = ...) -> Union[Awaitable[list], list]: ...
    def brpoplpush(self, src: str, dst: str, timeout: Optional[int] = ...) -> Union[Awaitable[Optional[str]], Optional[str]]: ...
    def blmpop(self, timeout: float, numkeys: int, *args: List[str], direction: str, count: Optional[int] = ...) -> Optional[list]: ...
    def lmpop(self, num_keys: int, *args: List[str], direction: str, count: Optional[int] = ...) -> Union[Awaitable[list], list]: ...
    def lindex(self, name: str, index: int) -> Union[Awaitable[Optional[str]], Optional[str]]: ...
    def linsert(self, name: str, where: str, refvalue: str, value: str) -> Union[Awaitable[int], int]: ...
    def llen(self, name: str) -> Union[Awaitable[int], int]: ...
    def lpop(self, name: str, count: Optional[int] = ...) -> Union[Awaitable[Union[str, List, None]], Union[str, List, None]]: ...
    def lpush(self, name: str, *values: FieldT) -> Union[Awaitable[int], int]: ...
    def lpushx(self, name: str, *values: FieldT) -> Union[Awaitable[int], int]: ...
    def lrange(self, name: str, start: int, end: int) -> Union[Awaitable[list], list]: ...
    def lrem(self, name: str, count: int, value: str) -> Union[Awaitable[int], int]: ...
    def lset(self, name: str, index: int, value: str) -> Union[Awaitable[str], str]: ...
    def ltrim(self, name: str, start: int, end: int) -> Union[Awaitable[str], str]: ...
    def rpop(self, name: str, count: Optional[int] = ...) -> Union[Awaitable[Union[str, List, None]], Union[str, List, None]]: ...
    def rpoplpush(self, src: str, dst: str) -> Union[Awaitable[str], str]: ...
    def rpush(self, name: str, *values: FieldT) -> Union[Awaitable[int], int]: ...
    def rpushx(self, name: str, *values: str) -> Union[Awaitable[int], int]: ...
    def lpos(self, name: str, value: str, rank: Optional[int] = ..., count: Optional[int] = ..., maxlen: Optional[int] = ...) -> Union[str, List, None]: ...
    def sort(self, name: str, start: Optional[int] = ..., num: Optional[int] = ..., by: Optional[str] = ..., get: Optional[List[str]] = ..., desc: bool = ..., alpha: bool = ..., store: Optional[str] = ..., groups: Optional[bool] = ...) -> Union[List, int]: ...
    def sort_ro(self, key: str, start: Optional[int] = ..., num: Optional[int] = ..., by: Optional[str] = ..., get: Optional[List[str]] = ..., desc: bool = ..., alpha: bool = ...) -> list: ...
AsyncListCommands = ListCommands

class ScanCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def scan(self, cursor: int = ..., match: Union[PatternT, None] = ..., count: Union[int, None] = ..., _type: Union[str, None] = ..., **kwargs) -> ResponseT: ...
    def scan_iter(self, match: Union[PatternT, None] = ..., count: Union[int, None] = ..., _type: Union[str, None] = ..., **kwargs) -> Iterator: ...
    def sscan(self, name: KeyT, cursor: int = ..., match: Union[PatternT, None] = ..., count: Union[int, None] = ...) -> ResponseT: ...
    def sscan_iter(self, name: KeyT, match: Union[PatternT, None] = ..., count: Union[int, None] = ...) -> Iterator: ...
    def hscan(self, name: KeyT, cursor: int = ..., match: Union[PatternT, None] = ..., count: Union[int, None] = ...) -> ResponseT: ...
    def hscan_iter(self, name: str, match: Union[PatternT, None] = ..., count: Union[int, None] = ...) -> Iterator: ...
    def zscan(self, name: KeyT, cursor: int = ..., match: Union[PatternT, None] = ..., count: Union[int, None] = ..., score_cast_func: Union[type, Callable] = ...) -> ResponseT: ...
    def zscan_iter(self, name: KeyT, match: Union[PatternT, None] = ..., count: Union[int, None] = ..., score_cast_func: Union[type, Callable] = ...) -> Iterator: ...

class AsyncScanCommands(ScanCommands, metaclass=abc.ABCMeta):
    async def scan_iter(self, match: Union[PatternT, None] = ..., count: Union[int, None] = ..., _type: Union[str, None] = ..., **kwargs) -> AsyncIterator: ...
    async def sscan_iter(self, name: KeyT, match: Union[PatternT, None] = ..., count: Union[int, None] = ...) -> AsyncIterator: ...
    async def hscan_iter(self, name: str, match: Union[PatternT, None] = ..., count: Union[int, None] = ...) -> AsyncIterator: ...
    async def zscan_iter(self, name: KeyT, match: Union[PatternT, None] = ..., count: Union[int, None] = ..., score_cast_func: Union[type, Callable] = ...) -> AsyncIterator: ...

class SetCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def sadd(self, name: str, *values: FieldT) -> Union[Awaitable[int], int]: ...
    def scard(self, name: str) -> Union[Awaitable[int], int]: ...
    def sdiff(self, keys: List, *args: List) -> Union[Awaitable[list], list]: ...
    def sdiffstore(self, dest: str, keys: List, *args: List) -> Union[Awaitable[int], int]: ...
    def sinter(self, keys: List, *args: List) -> Union[Awaitable[list], list]: ...
    def sintercard(self, numkeys: int, keys: List[str], limit: int = ...) -> Union[Awaitable[int], int]: ...
    def sinterstore(self, dest: str, keys: List, *args: List) -> Union[Awaitable[int], int]: ...
    def sismember(self, name: str, value: str) -> Union[Awaitable[Union[Literal[0], Literal[1]]], Union[Literal[0], Literal[1]]]: ...
    def smembers(self, name: str) -> Union[Awaitable[Set], Set]: ...
    def smismember(self, name: str, values: List, *args: List) -> Union[Awaitable[List[Union[Literal[0], Literal[1]]]], List[Union[Literal[0], Literal[1]]]]: ...
    def smove(self, src: str, dst: str, value: str) -> Union[Awaitable[bool], bool]: ...
    def spop(self, name: str, count: Optional[int] = ...) -> Union[str, List, None]: ...
    def srandmember(self, name: str, number: Optional[int] = ...) -> Union[str, List, None]: ...
    def srem(self, name: str, *values: FieldT) -> Union[Awaitable[int], int]: ...
    def sunion(self, keys: List, *args: List) -> Union[Awaitable[List], List]: ...
    def sunionstore(self, dest: str, keys: List, *args: List) -> Union[Awaitable[int], int]: ...
AsyncSetCommands = SetCommands

class StreamCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def xack(self, name: KeyT, groupname: GroupT, *ids: StreamIdT) -> ResponseT: ...
    def xadd(self, name: KeyT, fields: Dict[FieldT, EncodableT], id: StreamIdT = ..., maxlen: Union[int, None] = ..., approximate: bool = ..., nomkstream: bool = ..., minid: Union[StreamIdT, None] = ..., limit: Union[int, None] = ...) -> ResponseT: ...
    def xautoclaim(self, name: KeyT, groupname: GroupT, consumername: ConsumerT, min_idle_time: int, start_id: StreamIdT = ..., count: Union[int, None] = ..., justid: bool = ...) -> ResponseT: ...
    def xclaim(self, name: KeyT, groupname: GroupT, consumername: ConsumerT, min_idle_time: int, message_ids: Union[List[StreamIdT], Tuple[StreamIdT]], idle: Union[int, None] = ..., time: Union[int, None] = ..., retrycount: Union[int, None] = ..., force: bool = ..., justid: bool = ...) -> ResponseT: ...
    def xdel(self, name: KeyT, *ids: StreamIdT) -> ResponseT: ...
    def xgroup_create(self, name: KeyT, groupname: GroupT, id: StreamIdT = ..., mkstream: bool = ..., entries_read: Optional[int] = ...) -> ResponseT: ...
    def xgroup_delconsumer(self, name: KeyT, groupname: GroupT, consumername: ConsumerT) -> ResponseT: ...
    def xgroup_destroy(self, name: KeyT, groupname: GroupT) -> ResponseT: ...
    def xgroup_createconsumer(self, name: KeyT, groupname: GroupT, consumername: ConsumerT) -> ResponseT: ...
    def xgroup_setid(self, name: KeyT, groupname: GroupT, id: StreamIdT, entries_read: Optional[int] = ...) -> ResponseT: ...
    def xinfo_consumers(self, name: KeyT, groupname: GroupT) -> ResponseT: ...
    def xinfo_groups(self, name: KeyT) -> ResponseT: ...
    def xinfo_stream(self, name: KeyT, full: bool = ...) -> ResponseT: ...
    def xlen(self, name: KeyT) -> ResponseT: ...
    def xpending(self, name: KeyT, groupname: GroupT) -> ResponseT: ...
    def xpending_range(self, name: KeyT, groupname: GroupT, min: StreamIdT, max: StreamIdT, count: int, consumername: Union[ConsumerT, None] = ..., idle: Union[int, None] = ...) -> ResponseT: ...
    def xrange(self, name: KeyT, min: StreamIdT = ..., max: StreamIdT = ..., count: Union[int, None] = ...) -> ResponseT: ...
    def xread(self, streams: Dict[KeyT, StreamIdT], count: Union[int, None] = ..., block: Union[int, None] = ...) -> ResponseT: ...
    def xreadgroup(self, groupname: str, consumername: str, streams: Dict[KeyT, StreamIdT], count: Union[int, None] = ..., block: Union[int, None] = ..., noack: bool = ...) -> ResponseT: ...
    def xrevrange(self, name: KeyT, max: StreamIdT = ..., min: StreamIdT = ..., count: Union[int, None] = ...) -> ResponseT: ...
    def xtrim(self, name: KeyT, maxlen: Union[int, None] = ..., approximate: bool = ..., minid: Union[StreamIdT, None] = ..., limit: Union[int, None] = ...) -> ResponseT: ...
AsyncStreamCommands = StreamCommands

class SortedSetCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def zadd(self, name: KeyT, mapping: Mapping[AnyKeyT, EncodableT], nx: bool = ..., xx: bool = ..., ch: bool = ..., incr: bool = ..., gt: bool = ..., lt: bool = ...) -> ResponseT: ...
    def zcard(self, name: KeyT) -> ResponseT: ...
    def zcount(self, name: KeyT, min: ZScoreBoundT, max: ZScoreBoundT) -> ResponseT: ...
    def zdiff(self, keys: KeysT, withscores: bool = ...) -> ResponseT: ...
    def zdiffstore(self, dest: KeyT, keys: KeysT) -> ResponseT: ...
    def zincrby(self, name: KeyT, amount: float, value: EncodableT) -> ResponseT: ...
    def zinter(self, keys: KeysT, aggregate: Union[str, None] = ..., withscores: bool = ...) -> ResponseT: ...
    def zinterstore(self, dest: KeyT, keys: Union[Sequence[KeyT], Mapping[AnyKeyT, float]], aggregate: Union[str, None] = ...) -> ResponseT: ...
    def zintercard(self, numkeys: int, keys: List[str], limit: int = ...) -> Union[Awaitable[int], int]: ...
    def zlexcount(self, name, min, max): ...
    def zpopmax(self, name: KeyT, count: Union[int, None] = ...) -> ResponseT: ...
    def zpopmin(self, name: KeyT, count: Union[int, None] = ...) -> ResponseT: ...
    def zrandmember(self, key: KeyT, count: int = ..., withscores: bool = ...) -> ResponseT: ...
    def bzpopmax(self, keys: KeysT, timeout: TimeoutSecT = ...) -> ResponseT: ...
    def bzpopmin(self, keys: KeysT, timeout: TimeoutSecT = ...) -> ResponseT: ...
    def zmpop(self, num_keys: int, keys: List[str], min: Optional[bool] = ..., max: Optional[bool] = ..., count: Optional[int] = ...) -> Union[Awaitable[list], list]: ...
    def bzmpop(self, timeout: float, numkeys: int, keys: List[str], min: Optional[bool] = ..., max: Optional[bool] = ..., count: Optional[int] = ...) -> Optional[list]: ...
    def zrange(self, name: KeyT, start: int, end: int, desc: bool = ..., withscores: bool = ..., score_cast_func: Union[type, Callable] = ..., byscore: bool = ..., bylex: bool = ..., offset: int = ..., num: int = ...) -> ResponseT: ...
    def zrevrange(self, name: KeyT, start: int, end: int, withscores: bool = ..., score_cast_func: Union[type, Callable] = ...) -> ResponseT: ...
    def zrangestore(self, dest: KeyT, name: KeyT, start: int, end: int, byscore: bool = ..., bylex: bool = ..., desc: bool = ..., offset: Union[int, None] = ..., num: Union[int, None] = ...) -> ResponseT: ...
    def zrangebylex(self, name: KeyT, min: EncodableT, max: EncodableT, start: Union[int, None] = ..., num: Union[int, None] = ...) -> ResponseT: ...
    def zrevrangebylex(self, name: KeyT, max: EncodableT, min: EncodableT, start: Union[int, None] = ..., num: Union[int, None] = ...) -> ResponseT: ...
    def zrangebyscore(self, name: KeyT, min: ZScoreBoundT, max: ZScoreBoundT, start: Union[int, None] = ..., num: Union[int, None] = ..., withscores: bool = ..., score_cast_func: Union[type, Callable] = ...) -> ResponseT: ...
    def zrevrangebyscore(self, name: KeyT, max: ZScoreBoundT, min: ZScoreBoundT, start: Union[int, None] = ..., num: Union[int, None] = ..., withscores: bool = ..., score_cast_func: Union[type, Callable] = ...): ...
    def zrank(self, name: KeyT, value: EncodableT, withscore: bool = ...) -> ResponseT: ...
    def zrem(self, name: KeyT, *values: FieldT) -> ResponseT: ...
    def zremrangebylex(self, name: KeyT, min: EncodableT, max: EncodableT) -> ResponseT: ...
    def zremrangebyrank(self, name: KeyT, min: int, max: int) -> ResponseT: ...
    def zremrangebyscore(self, name: KeyT, min: ZScoreBoundT, max: ZScoreBoundT) -> ResponseT: ...
    def zrevrank(self, name: KeyT, value: EncodableT, withscore: bool = ...) -> ResponseT: ...
    def zscore(self, name: KeyT, value: EncodableT) -> ResponseT: ...
    def zunion(self, keys: Union[Sequence[KeyT], Mapping[AnyKeyT, float]], aggregate: Union[str, None] = ..., withscores: bool = ...) -> ResponseT: ...
    def zunionstore(self, dest: KeyT, keys: Union[Sequence[KeyT], Mapping[AnyKeyT, float]], aggregate: Union[str, None] = ...) -> ResponseT: ...
    def zmscore(self, key: KeyT, members: List[str]) -> ResponseT: ...
AsyncSortedSetCommands = SortedSetCommands

class HyperlogCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def pfadd(self, name: KeyT, *values: FieldT) -> ResponseT: ...
    def pfcount(self, *sources: KeyT) -> ResponseT: ...
    def pfmerge(self, dest: KeyT, *sources: KeyT) -> ResponseT: ...
AsyncHyperlogCommands = HyperlogCommands

class HashCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def hdel(self, name: str, *keys: List) -> Union[Awaitable[int], int]: ...
    def hexists(self, name: str, key: str) -> Union[Awaitable[bool], bool]: ...
    def hget(self, name: str, key: str) -> Union[Awaitable[Optional[str]], Optional[str]]: ...
    def hgetall(self, name: str) -> Union[Awaitable[dict], dict]: ...
    def hincrby(self, name: str, key: str, amount: int = ...) -> Union[Awaitable[int], int]: ...
    def hincrbyfloat(self, name: str, key: str, amount: float = ...) -> Union[Awaitable[float], float]: ...
    def hkeys(self, name: str) -> Union[Awaitable[List], List]: ...
    def hlen(self, name: str) -> Union[Awaitable[int], int]: ...
    def hset(self, name: str, key: Optional[str] = ..., value: Optional[str] = ..., mapping: Optional[dict] = ..., items: Optional[list] = ...) -> Union[Awaitable[int], int]: ...
    def hsetnx(self, name: str, key: str, value: str) -> Union[Awaitable[bool], bool]: ...
    def hmset(self, name: str, mapping: dict) -> Union[Awaitable[str], str]: ...
    def hmget(self, name: str, keys: List, *args: List) -> Union[Awaitable[List], List]: ...
    def hvals(self, name: str) -> Union[Awaitable[List], List]: ...
    def hstrlen(self, name: str, key: str) -> Union[Awaitable[int], int]: ...
AsyncHashCommands = HashCommands

class Script:
    registered_client: Incomplete
    script: Incomplete
    sha: Incomplete
    def __init__(self, registered_client: Redis, script: ScriptTextT) -> None: ...
    def __call__(self, keys: Union[Sequence[KeyT], None] = ..., args: Union[Iterable[EncodableT], None] = ..., client: Union['Redis', None] = ...): ...

class AsyncScript:
    registered_client: Incomplete
    script: Incomplete
    sha: Incomplete
    def __init__(self, registered_client: AsyncRedis, script: ScriptTextT) -> None: ...
    async def __call__(self, keys: Union[Sequence[KeyT], None] = ..., args: Union[Iterable[EncodableT], None] = ..., client: Union['AsyncRedis', None] = ...): ...

class PubSubCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def publish(self, channel: ChannelT, message: EncodableT, **kwargs) -> ResponseT: ...
    def spublish(self, shard_channel: ChannelT, message: EncodableT) -> ResponseT: ...
    def pubsub_channels(self, pattern: PatternT = ..., **kwargs) -> ResponseT: ...
    def pubsub_shardchannels(self, pattern: PatternT = ..., **kwargs) -> ResponseT: ...
    def pubsub_numpat(self, **kwargs) -> ResponseT: ...
    def pubsub_numsub(self, *args: ChannelT, **kwargs) -> ResponseT: ...
    def pubsub_shardnumsub(self, *args: ChannelT, **kwargs) -> ResponseT: ...
AsyncPubSubCommands = PubSubCommands

class ScriptCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def eval(self, script: str, numkeys: int, *keys_and_args: list) -> Union[Awaitable[str], str]: ...
    def eval_ro(self, script: str, numkeys: int, *keys_and_args: list) -> Union[Awaitable[str], str]: ...
    def evalsha(self, sha: str, numkeys: int, *keys_and_args: list) -> Union[Awaitable[str], str]: ...
    def evalsha_ro(self, sha: str, numkeys: int, *keys_and_args: list) -> Union[Awaitable[str], str]: ...
    def script_exists(self, *args: str) -> ResponseT: ...
    def script_debug(self, *args) -> None: ...
    def script_flush(self, sync_type: Union[Literal['SYNC'], Literal['ASYNC']] = ...) -> ResponseT: ...
    def script_kill(self) -> ResponseT: ...
    def script_load(self, script: ScriptTextT) -> ResponseT: ...
    def register_script(self, script: ScriptTextT) -> Script: ...

class AsyncScriptCommands(ScriptCommands, metaclass=abc.ABCMeta):
    async def script_debug(self, *args) -> None: ...
    def register_script(self, script: ScriptTextT) -> AsyncScript: ...

class GeoCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def geoadd(self, name: KeyT, values: Sequence[EncodableT], nx: bool = ..., xx: bool = ..., ch: bool = ...) -> ResponseT: ...
    def geodist(self, name: KeyT, place1: FieldT, place2: FieldT, unit: Union[str, None] = ...) -> ResponseT: ...
    def geohash(self, name: KeyT, *values: FieldT) -> ResponseT: ...
    def geopos(self, name: KeyT, *values: FieldT) -> ResponseT: ...
    def georadius(self, name: KeyT, longitude: float, latitude: float, radius: float, unit: Union[str, None] = ..., withdist: bool = ..., withcoord: bool = ..., withhash: bool = ..., count: Union[int, None] = ..., sort: Union[str, None] = ..., store: Union[KeyT, None] = ..., store_dist: Union[KeyT, None] = ..., any: bool = ...) -> ResponseT: ...
    def georadiusbymember(self, name: KeyT, member: FieldT, radius: float, unit: Union[str, None] = ..., withdist: bool = ..., withcoord: bool = ..., withhash: bool = ..., count: Union[int, None] = ..., sort: Union[str, None] = ..., store: Union[KeyT, None] = ..., store_dist: Union[KeyT, None] = ..., any: bool = ...) -> ResponseT: ...
    def geosearch(self, name: KeyT, member: Union[FieldT, None] = ..., longitude: Union[float, None] = ..., latitude: Union[float, None] = ..., unit: str = ..., radius: Union[float, None] = ..., width: Union[float, None] = ..., height: Union[float, None] = ..., sort: Union[str, None] = ..., count: Union[int, None] = ..., any: bool = ..., withcoord: bool = ..., withdist: bool = ..., withhash: bool = ...) -> ResponseT: ...
    def geosearchstore(self, dest: KeyT, name: KeyT, member: Union[FieldT, None] = ..., longitude: Union[float, None] = ..., latitude: Union[float, None] = ..., unit: str = ..., radius: Union[float, None] = ..., width: Union[float, None] = ..., height: Union[float, None] = ..., sort: Union[str, None] = ..., count: Union[int, None] = ..., any: bool = ..., storedist: bool = ...) -> ResponseT: ...
AsyncGeoCommands = GeoCommands

class ModuleCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def module_load(self, path, *args) -> ResponseT: ...
    def module_loadex(self, path: str, options: Optional[List[str]] = ..., args: Optional[List[str]] = ...) -> ResponseT: ...
    def module_unload(self, name) -> ResponseT: ...
    def module_list(self) -> ResponseT: ...
    def command_info(self) -> None: ...
    def command_count(self) -> ResponseT: ...
    def command_getkeys(self, *args) -> ResponseT: ...
    def command(self) -> ResponseT: ...

class Script:
    registered_client: Incomplete
    script: Incomplete
    sha: Incomplete
    def __init__(self, registered_client, script) -> None: ...
    def __call__(self, keys=..., args=..., client: Incomplete | None = ...): ...
    def get_encoder(self): ...

class AsyncModuleCommands(ModuleCommands, metaclass=abc.ABCMeta):
    async def command_info(self) -> None: ...

class ClusterCommands(CommandsProtocol, metaclass=abc.ABCMeta):
    def cluster(self, cluster_arg, *args, **kwargs) -> ResponseT: ...
    def readwrite(self, **kwargs) -> ResponseT: ...
    def readonly(self, **kwargs) -> ResponseT: ...
AsyncClusterCommands = ClusterCommands

class FunctionCommands:
    def function_load(self, code: str, replace: Optional[bool] = ...) -> Union[Awaitable[str], str]: ...
    def function_delete(self, library: str) -> Union[Awaitable[str], str]: ...
    def function_flush(self, mode: str = ...) -> Union[Awaitable[str], str]: ...
    def function_list(self, library: Optional[str] = ..., withcode: Optional[bool] = ...) -> Union[Awaitable[List], List]: ...
    def fcall(self, function, numkeys: int, *keys_and_args: Optional[List]) -> Union[Awaitable[str], str]: ...
    def fcall_ro(self, function, numkeys: int, *keys_and_args: Optional[List]) -> Union[Awaitable[str], str]: ...
    def function_dump(self) -> Union[Awaitable[str], str]: ...
    def function_restore(self, payload: str, policy: Optional[str] = ...) -> Union[Awaitable[str], str]: ...
    def function_kill(self) -> Union[Awaitable[str], str]: ...
    def function_stats(self) -> Union[Awaitable[List], List]: ...
AsyncFunctionCommands = FunctionCommands

class GearsCommands:
    def tfunction_load(self, lib_code: str, replace: bool = ..., config: Union[str, None] = ...) -> ResponseT: ...
    def tfunction_delete(self, lib_name: str) -> ResponseT: ...
    def tfunction_list(self, with_code: bool = ..., verbose: int = ..., lib_name: Union[str, None] = ...) -> ResponseT: ...
    def tfcall(self, lib_name: str, func_name: str, keys: KeysT = ..., *args: List) -> ResponseT: ...
    def tfcall_async(self, lib_name: str, func_name: str, keys: KeysT = ..., *args: List) -> ResponseT: ...
AsyncGearsCommands = GearsCommands

class DataAccessCommands(BasicKeyCommands, HyperlogCommands, HashCommands, GeoCommands, ListCommands, ScanCommands, SetCommands, StreamCommands, SortedSetCommands, metaclass=abc.ABCMeta): ...
class AsyncDataAccessCommands(AsyncBasicKeyCommands, AsyncHyperlogCommands, AsyncHashCommands, AsyncGeoCommands, AsyncListCommands, AsyncScanCommands, AsyncSetCommands, AsyncStreamCommands, AsyncSortedSetCommands, metaclass=abc.ABCMeta): ...
class CoreCommands(ACLCommands, ClusterCommands, DataAccessCommands, ManagementCommands, ModuleCommands, PubSubCommands, ScriptCommands, FunctionCommands, GearsCommands, metaclass=abc.ABCMeta): ...
class AsyncCoreCommands(AsyncACLCommands, AsyncClusterCommands, AsyncDataAccessCommands, AsyncManagementCommands, AsyncModuleCommands, AsyncPubSubCommands, AsyncScriptCommands, AsyncFunctionCommands, AsyncGearsCommands, metaclass=abc.ABCMeta): ...
