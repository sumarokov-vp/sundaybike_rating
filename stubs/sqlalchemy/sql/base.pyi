from . import coercions as coercions, elements as elements, roles as roles, type_api as type_api, visitors as visitors
from .. import event as event, exc as exc, util as util
from ..engine import Connection as Connection, CursorResult as CursorResult
from ..engine.interfaces import CacheStats as CacheStats, Compiled as Compiled, CompiledCacheType as CompiledCacheType, CoreExecuteOptionsParameter as CoreExecuteOptionsParameter, Dialect as Dialect, IsolationLevel as IsolationLevel, SchemaTranslateMapType as SchemaTranslateMapType, _ExecuteOptions
from ..event import dispatcher as dispatcher
from ..util import HasMemoized as HasMemoized, hybridmethod as hybridmethod, typing as compat_typing
from ..util.typing import Protocol as Protocol, Self as Self, TypeGuard as TypeGuard
from ._orm_types import DMLStrategyArgument as DMLStrategyArgument, SynchronizeSessionArgument as SynchronizeSessionArgument
from .cache_key import HasCacheKey as HasCacheKey, MemoizedHasCacheKey as MemoizedHasCacheKey
from .elements import BindParameter as BindParameter, ClauseList as ClauseList, ColumnClause as ColumnClause, ColumnElement as ColumnElement, KeyedColumnElement as KeyedColumnElement, NamedColumn as NamedColumn, SQLCoreOperations as SQLCoreOperations, TextClause as TextClause
from .schema import Column as Column, DefaultGenerator as DefaultGenerator
from .selectable import FromClause as FromClause
from .traversals import HasCopyInternals as HasCopyInternals
from .visitors import ClauseVisitor as ClauseVisitor, ExtendedInternalTraversal as ExtendedInternalTraversal, ExternallyTraversible as ExternallyTraversible, InternalTraversal as InternalTraversal
from _typeshed import Incomplete
from enum import Enum
from typing import Any, Callable, Dict, FrozenSet, Generic, Iterable, Iterator, List, MutableMapping, NamedTuple, NoReturn, Optional, Sequence, Set, Tuple, Type, Union, overload

class _NoArg(Enum):
    NO_ARG: int

NO_ARG: Incomplete

class _NoneName(Enum):
    NONE_NAME: int

class _DefaultDescriptionTuple(NamedTuple):
    arg: Any
    is_scalar: Optional[bool]
    is_callable: Optional[bool]
    is_sentinel: Optional[bool]

class _EntityNamespace(Protocol):
    def __getattr__(self, key: str) -> SQLCoreOperations[Any]: ...

class _HasEntityNamespace(Protocol):
    def entity_namespace(self) -> _EntityNamespace: ...

class Immutable:
    def unique_params(self, *optionaldict, **kwargs) -> None: ...
    def params(self, *optionaldict, **kwargs) -> None: ...

class SingletonConstant(Immutable):
    def __new__(cls, *arg: Any, **kw: Any) -> _T: ...
    def proxy_set(self) -> FrozenSet[ColumnElement[Any]]: ...

class _GenerativeType(compat_typing.Protocol): ...

class _DialectArgView(MutableMapping[str, Any]):
    obj: Incomplete
    def __init__(self, obj) -> None: ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None: ...
    def __delitem__(self, key) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self): ...

class _DialectArgDict(MutableMapping[str, Any]):
    def __init__(self) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None: ...
    def __delitem__(self, key) -> None: ...

class DialectKWArgs:
    @classmethod
    def argument_for(cls, dialect_name, argument_name, default) -> None: ...
    def dialect_kwargs(self): ...
    @property
    def kwargs(self): ...
    def dialect_options(self): ...

class CompileState:
    plugins: Dict[Tuple[str, str], Type[CompileState]]
    @classmethod
    def create_for_statement(cls, statement, compiler, **kw): ...
    statement: Incomplete
    def __init__(self, statement, compiler, **kw) -> None: ...
    @classmethod
    def get_plugin_class(cls, statement: Executable) -> Optional[Type[CompileState]]: ...
    @classmethod
    def plugin_for(cls, plugin_name: str, visit_name: str) -> Callable[[_Fn], _Fn]: ...

class Generative(HasMemoized): ...
class InPlaceGenerative(HasMemoized): ...
class HasCompileState(Generative): ...

class _MetaOptions(type):
    def __add__(self, other): ...
    def __getattr__(self, key: str) -> Any: ...
    def __setattr__(self, key: str, value: Any) -> None: ...
    def __delattr__(self, key: str) -> None: ...

class Options(metaclass=_MetaOptions):
    def __init_subclass__(cls) -> None: ...
    def __init__(self, **kw) -> None: ...
    def __add__(self, other): ...
    def __eq__(self, other): ...
    @classmethod
    def isinstance(cls, klass: Type[Any]) -> bool: ...
    def add_to_element(self, name, value): ...
    @classmethod
    def safe_merge(cls, other): ...
    @classmethod
    def from_execution_options(cls, key, attrs, exec_options, statement_exec_options): ...
    def __getattr__(self, key: str) -> Any: ...
    def __setattr__(self, key: str, value: Any) -> None: ...
    def __delattr__(self, key: str) -> None: ...

class CacheableOptions(Options, HasCacheKey): ...

class ExecutableOption(HasCopyInternals):
    __visit_name__: str

class Executable(roles.StatementRole):
    supports_execution: bool
    is_select: bool
    is_update: bool
    is_insert: bool
    is_text: bool
    is_delete: bool
    is_dml: bool
    __visit_name__: str
    def options(self, *options: ExecutableOption) -> Self: ...
    @overload
    def execution_options(self, *, compiled_cache: Optional[CompiledCacheType] = ..., logging_token: str = ..., isolation_level: IsolationLevel = ..., no_parameters: bool = ..., stream_results: bool = ..., max_row_buffer: int = ..., yield_per: int = ..., insertmanyvalues_page_size: int = ..., schema_translate_map: Optional[SchemaTranslateMapType] = ..., populate_existing: bool = ..., autoflush: bool = ..., synchronize_session: SynchronizeSessionArgument = ..., dml_strategy: DMLStrategyArgument = ..., render_nulls: bool = ..., is_delete_using: bool = ..., is_update_from: bool = ..., **opt: Any) -> Self: ...
    @overload
    def execution_options(self, **opt: Any) -> Self: ...
    def get_execution_options(self) -> _ExecuteOptions: ...

class SchemaEventTarget(event.EventTarget):
    dispatch: dispatcher[SchemaEventTarget]

class SchemaVisitor(ClauseVisitor):
    __traverse_options__: Incomplete

class _SentinelDefaultCharacterization(Enum):
    NONE: str
    UNKNOWN: str
    CLIENTSIDE: str
    SENTINEL_DEFAULT: str
    SERVERSIDE: str
    IDENTITY: str
    SEQUENCE: str

class _SentinelColumnCharacterization(NamedTuple):
    columns: Optional[Sequence[Column[Any]]] = ...
    is_explicit: bool = ...
    is_autoinc: bool = ...
    default_characterization: _SentinelDefaultCharacterization = ...

class _ColumnMetrics(Generic[_COL_co]):
    column: _COL_co
    def __init__(self, collection: ColumnCollection[Any, _COL_co], col: _COL_co) -> None: ...
    def get_expanded_proxy_set(self): ...
    def dispose(self, collection) -> None: ...
    def embedded(self, target_set: Union[Set[ColumnElement[Any]], FrozenSet[ColumnElement[Any]]]) -> bool: ...

class ColumnCollection(Generic[_COLKEY, _COL_co]):
    def __init__(self, columns: Optional[Iterable[Tuple[_COLKEY, _COL_co]]] = ...) -> None: ...
    def __clause_element__(self) -> ClauseList: ...
    def keys(self) -> List[_COLKEY]: ...
    def values(self) -> List[_COL_co]: ...
    def items(self) -> List[Tuple[_COLKEY, _COL_co]]: ...
    def __bool__(self) -> bool: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_COL_co]: ...
    @overload
    def __getitem__(self, key: Union[str, int]) -> _COL_co: ...
    @overload
    def __getitem__(self, key: Tuple[Union[str, int], ...]) -> ReadOnlyColumnCollection[_COLKEY, _COL_co]: ...
    @overload
    def __getitem__(self, key: slice) -> ReadOnlyColumnCollection[_COLKEY, _COL_co]: ...
    def __getattr__(self, key: str) -> _COL_co: ...
    def __contains__(self, key: str) -> bool: ...
    def compare(self, other: ColumnCollection[Any, Any]) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def get(self, key: str, default: Optional[_COL_co] = ...) -> Optional[_COL_co]: ...
    def __setitem__(self, key: str, value: Any) -> NoReturn: ...
    def __delitem__(self, key: str) -> NoReturn: ...
    def __setattr__(self, key: str, obj: Any) -> NoReturn: ...
    def clear(self) -> NoReturn: ...
    def remove(self, column: Any) -> None: ...
    def update(self, iter_: Any) -> NoReturn: ...
    __hash__: Incomplete
    def add(self, column: ColumnElement[Any], key: Optional[_COLKEY] = ...) -> None: ...
    def contains_column(self, col: ColumnElement[Any]) -> bool: ...
    def as_readonly(self) -> ReadOnlyColumnCollection[_COLKEY, _COL_co]: ...
    def corresponding_column(self, column: _COL, require_embedded: bool = ...) -> Optional[Union[_COL, _COL_co]]: ...

class DedupeColumnCollection(ColumnCollection[str, _NAMEDCOL]):
    def add(self, column: ColumnElement[Any], key: Optional[str] = ...) -> None: ...
    def extend(self, iter_: Iterable[_NAMEDCOL]) -> None: ...
    def remove(self, column: _NAMEDCOL) -> None: ...
    def replace(self, column: _NAMEDCOL, extra_remove: Optional[Iterable[_NAMEDCOL]] = ...) -> None: ...

class ReadOnlyColumnCollection(util.ReadOnlyContainer, ColumnCollection[_COLKEY, _COL_co]):
    def __init__(self, collection) -> None: ...
    def add(self, column: Any, key: Any = ...) -> Any: ...
    def extend(self, elements: Any) -> NoReturn: ...
    def remove(self, item: Any) -> NoReturn: ...

class ColumnSet(util.OrderedSet['ColumnClause[Any]']):
    def contains_column(self, col): ...
    def extend(self, cols) -> None: ...
    def __eq__(self, other): ...
    def __hash__(self): ...
