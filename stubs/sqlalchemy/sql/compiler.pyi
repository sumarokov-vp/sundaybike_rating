from . import base as base, coercions as coercions, crud as crud, elements as elements, functions as functions, operators as operators, roles as roles, schema as schema, selectable as selectable, sqltypes as sqltypes
from .. import exc as exc, util as util
from ..engine.cursor import CursorResultMetaData as CursorResultMetaData
from ..engine.interfaces import Dialect as Dialect, SchemaTranslateMapType as SchemaTranslateMapType, _CoreSingleExecuteParams, _DBAPIAnyExecuteParams, _DBAPISingleExecuteParams, _ExecuteOptions, _GenericSetInputSizesType, _MutableCoreSingleExecuteParams
from ..util import FastIntFlag as FastIntFlag
from ..util.typing import Literal as Literal, Protocol as Protocol, TypedDict as TypedDict
from ._typing import is_column_element as is_column_element, is_dml as is_dml
from .base import CompileState as CompileState, Executable as Executable, NO_ARG as NO_ARG, _AmbiguousTableNameMap
from .cache_key import CacheKey as CacheKey
from .ddl import ExecutableDDLElement as ExecutableDDLElement
from .dml import Insert as Insert, UpdateBase as UpdateBase, ValuesBase as ValuesBase
from .elements import BindParameter as BindParameter, ClauseElement as ClauseElement, ColumnClause as ColumnClause, ColumnElement as ColumnElement, Label as Label, quoted_name as quoted_name
from .functions import Function as Function
from .schema import Column as Column, Table as Table
from .selectable import AliasedReturnsRows as AliasedReturnsRows, CTE as CTE, CompoundSelectState as CompoundSelectState, FromClause as FromClause, NamedFromClause as NamedFromClause, ReturnsRows as ReturnsRows, Select as Select, SelectState as SelectState
from .sqltypes import TupleType as TupleType
from .type_api import TypeEngine as TypeEngine, _BindProcessorType
from .visitors import Visitable as Visitable, prefix_anon_map as prefix_anon_map
from _typeshed import Incomplete
from enum import IntEnum
from typing import Any, ClassVar, Dict, FrozenSet, List, Mapping, MutableMapping, NamedTuple, NoReturn, Optional, Sequence, Set, Tuple, Type, Union

RESERVED_WORDS: Incomplete
LEGAL_CHARACTERS: Incomplete
LEGAL_CHARACTERS_PLUS_SPACE: Incomplete
ILLEGAL_INITIAL_CHARACTERS: Incomplete
FK_ON_DELETE: Incomplete
FK_ON_UPDATE: Incomplete
FK_INITIALLY: Incomplete
BIND_PARAMS: Incomplete
BIND_PARAMS_ESC: Incomplete
BIND_TEMPLATES: Incomplete
OPERATORS: Incomplete
FUNCTIONS: Dict[Type[Function[Any]], str]
EXTRACT_MAP: Incomplete
COMPOUND_KEYWORDS: Incomplete

class ResultColumnsEntry(NamedTuple):
    keyname: str
    name: str
    objects: Tuple[Any, ...]
    type: TypeEngine[Any]

class _ResultMapAppender(Protocol):
    def __call__(self, keyname: str, name: str, objects: Sequence[Any], type_: TypeEngine[Any]) -> None: ...

RM_RENDERED_NAME: Literal[0]
RM_NAME: Literal[1]
RM_OBJECTS: Literal[2]
RM_TYPE: Literal[3]

class _BaseCompilerStackEntry(TypedDict):
    asfrom_froms: Set[FromClause]
    correlate_froms: Set[FromClause]
    selectable: ReturnsRows

class _CompilerStackEntry(_BaseCompilerStackEntry, total=False):
    compile_state: CompileState
    need_result_map_for_nested: bool
    need_result_map_for_compound: bool
    select_0: ReturnsRows
    insert_from_select: Select[Any]

class ExpandedState(NamedTuple):
    statement: str
    parameters: _CoreSingleExecuteParams
    processors: Mapping[str, _BindProcessorType[Any]]
    positiontup: Optional[Sequence[str]]
    parameter_expansion: Mapping[str, List[str]]
    @property
    def positional_parameters(self) -> Tuple[Any, ...]: ...
    @property
    def additional_parameters(self) -> _CoreSingleExecuteParams: ...

class _InsertManyValues(NamedTuple):
    is_default_expr: bool
    single_values_expr: str
    insert_crud_params: List[crud._CrudParamElementStr]
    num_positional_params_counted: int
    sort_by_parameter_order: bool = ...
    includes_upsert_behaviors: bool = ...
    sentinel_columns: Optional[Sequence[Column[Any]]] = ...
    num_sentinel_columns: int = ...
    sentinel_param_keys: Optional[Sequence[Union[str, int]]] = ...
    implicit_sentinel: bool = ...
    embed_values_counter: bool = ...

class _InsertManyValuesBatch(NamedTuple):
    replaced_statement: str
    replaced_parameters: _DBAPIAnyExecuteParams
    processed_setinputsizes: Optional[_GenericSetInputSizesType]
    batch: Sequence[_DBAPISingleExecuteParams]
    batch_size: int
    batchnum: int
    total_batches: int
    rows_sorted: bool
    is_downgraded: bool

class InsertmanyvaluesSentinelOpts(FastIntFlag):
    NOT_SUPPORTED: int
    AUTOINCREMENT: int
    IDENTITY: int
    SEQUENCE: int
    ANY_AUTOINCREMENT: Incomplete
    USE_INSERT_FROM_SELECT: int
    RENDER_SELECT_COL_CASTS: int

class CompilerState(IntEnum):
    COMPILING: int
    STRING_APPLIED: int
    NO_STATEMENT: int

class Linting(IntEnum):
    NO_LINTING: int
    COLLECT_CARTESIAN_PRODUCTS: int
    WARN_LINTING: int
    FROM_LINTING: Incomplete

NO_LINTING: Incomplete
COLLECT_CARTESIAN_PRODUCTS: Incomplete
WARN_LINTING: Incomplete
FROM_LINTING: Incomplete

class FromLinter(NamedTuple('FromLinter', [('froms', Incomplete), ('edges', Incomplete)])):
    def lint(self, start: Incomplete | None = ...): ...
    def warn(self, stmt_type: str = ...) -> None: ...

class Compiled:
    statement: Optional[ClauseElement]
    string: str
    state: CompilerState
    is_sql: bool
    is_ddl: bool
    schema_translate_map: Optional[SchemaTranslateMapType]
    execution_options: _ExecuteOptions
    preparer: IdentifierPreparer
    compile_state: Optional[CompileState]
    dml_compile_state: Optional[CompileState]
    cache_key: Optional[CacheKey]
    dialect: Incomplete
    can_execute: Incomplete
    def __init__(self, dialect: Dialect, statement: Optional[ClauseElement], schema_translate_map: Optional[SchemaTranslateMapType] = ..., render_schema_translate: bool = ..., compile_kwargs: Mapping[str, Any] = ...) -> None: ...
    def __init_subclass__(cls) -> None: ...
    def visit_unsupported_compilation(self, element, err, **kw) -> None: ...
    @property
    def sql_compiler(self) -> None: ...
    def process(self, obj: Visitable, **kwargs: Any) -> str: ...
    def construct_params(self, params: Optional[_CoreSingleExecuteParams] = ..., extracted_parameters: Optional[Sequence[BindParameter[Any]]] = ..., escape_names: bool = ...) -> Optional[_MutableCoreSingleExecuteParams]: ...
    @property
    def params(self): ...

class TypeCompiler(util.EnsureKWArg):
    ensure_kwarg: str
    dialect: Incomplete
    def __init__(self, dialect: Dialect) -> None: ...
    def process(self, type_: TypeEngine[Any], **kw: Any) -> str: ...
    def visit_unsupported_compilation(self, element: Any, err: Exception, **kw: Any) -> NoReturn: ...

class _CompileLabel(roles.BinaryElementRole[Any], elements.CompilerColumnElement):
    __visit_name__: str
    element: Incomplete
    name: Incomplete
    def __init__(self, col, name, alt_names=...) -> None: ...
    @property
    def proxy_set(self): ...
    @property
    def type(self): ...
    def self_group(self, **kw): ...

class ilike_case_insensitive(roles.BinaryElementRole[Any], elements.CompilerColumnElement):
    __visit_name__: str
    element: Incomplete
    comparator: Incomplete
    def __init__(self, element) -> None: ...
    @property
    def proxy_set(self): ...
    @property
    def type(self): ...
    def self_group(self, **kw): ...

class SQLCompiler(Compiled):
    extract_map = EXTRACT_MAP
    bindname_escape_characters: ClassVar[Mapping[str, str]]
    is_sql: bool
    compound_keywords = COMPOUND_KEYWORDS
    isdelete: bool
    isinsert: bool
    isupdate: bool
    postfetch: Optional[List[Column[Any]]]
    insert_prefetch: Sequence[Column[Any]]
    update_prefetch: Sequence[Column[Any]]
    implicit_returning: Optional[Sequence[ColumnElement[Any]]]
    isplaintext: bool
    binds: Dict[str, BindParameter[Any]]
    bind_names: Dict[BindParameter[Any], str]
    stack: List[_CompilerStackEntry]
    returning_precedes_values: bool
    render_table_with_column_in_update_from: bool
    ansi_bind_rules: bool
    bindtemplate: str
    compilation_bindtemplate: str
    literal_execute_params: FrozenSet[BindParameter[Any]]
    post_compile_params: FrozenSet[BindParameter[Any]]
    escaped_bind_names: util.immutabledict[str, str]
    has_out_parameters: bool
    postfetch_lastrowid: bool
    positiontup: Optional[List[str]]
    inline: bool
    ctes: Optional[MutableMapping[CTE, str]]
    ctes_by_level_name: Dict[Tuple[int, str], CTE]
    level_name_by_cte: Dict[CTE, Tuple[int, str, selectable._CTEOpts]]
    ctes_recursive: bool
    column_keys: Incomplete
    cache_key: Incomplete
    for_executemany: Incomplete
    linting: Incomplete
    positional: Incomplete
    label_length: Incomplete
    anon_map: Incomplete
    truncated_names: Incomplete
    def __init__(self, dialect: Dialect, statement: Optional[ClauseElement], cache_key: Optional[CacheKey] = ..., column_keys: Optional[Sequence[str]] = ..., for_executemany: bool = ..., linting: Linting = ..., **kwargs: Any) -> None: ...
    @property
    def insert_single_values_expr(self) -> Optional[str]: ...
    def effective_returning(self) -> Optional[Sequence[ColumnElement[Any]]]: ...
    @property
    def returning(self): ...
    @property
    def current_executable(self): ...
    @property
    def prefetch(self): ...
    def is_subquery(self): ...
    @property
    def sql_compiler(self): ...
    def construct_expanded_state(self, params: Optional[_CoreSingleExecuteParams] = ..., escape_names: bool = ...) -> ExpandedState: ...
    def construct_params(self, params: Optional[_CoreSingleExecuteParams] = ..., extracted_parameters: Optional[Sequence[BindParameter[Any]]] = ..., escape_names: bool = ..., _group_number: Optional[int] = ..., _check: bool = ..., _no_postcompile: bool = ...) -> _MutableCoreSingleExecuteParams: ...
    @property
    def params(self): ...
    def default_from(self): ...
    def visit_grouping(self, grouping, asfrom: bool = ..., **kwargs): ...
    def visit_select_statement_grouping(self, grouping, **kwargs): ...
    def visit_label_reference(self, element, within_columns_clause: bool = ..., **kwargs): ...
    def visit_textual_label_reference(self, element, within_columns_clause: bool = ..., **kwargs): ...
    def visit_label(self, label, add_to_result_map: Incomplete | None = ..., within_label_clause: bool = ..., within_columns_clause: bool = ..., render_label_as_label: Incomplete | None = ..., result_map_targets=..., **kw): ...
    def visit_lambda_element(self, element, **kw): ...
    def visit_column(self, column: ColumnClause[Any], add_to_result_map: Optional[_ResultMapAppender] = ..., include_table: bool = ..., result_map_targets: Tuple[Any, ...] = ..., ambiguous_table_name_map: Optional[_AmbiguousTableNameMap] = ..., **kwargs: Any) -> str: ...
    def visit_collation(self, element, **kw): ...
    def visit_fromclause(self, fromclause, **kwargs): ...
    def visit_index(self, index, **kwargs): ...
    def visit_typeclause(self, typeclause, **kw): ...
    def post_process_text(self, text): ...
    def escape_literal_column(self, text): ...
    def visit_textclause(self, textclause, add_to_result_map: Incomplete | None = ..., **kw): ...
    def visit_textual_select(self, taf, compound_index: Incomplete | None = ..., asfrom: bool = ..., **kw): ...
    def visit_null(self, expr, **kw): ...
    def visit_true(self, expr, **kw): ...
    def visit_false(self, expr, **kw): ...
    def visit_tuple(self, clauselist, **kw): ...
    def visit_clauselist(self, clauselist, **kw): ...
    def visit_expression_clauselist(self, clauselist, **kw): ...
    def visit_case(self, clause, **kwargs): ...
    def visit_type_coerce(self, type_coerce, **kw): ...
    def visit_cast(self, cast, **kwargs): ...
    def visit_over(self, over, **kwargs): ...
    def visit_withingroup(self, withingroup, **kwargs): ...
    def visit_funcfilter(self, funcfilter, **kwargs): ...
    def visit_extract(self, extract, **kwargs): ...
    def visit_scalar_function_column(self, element, **kw): ...
    def visit_function(self, func: Function[Any], add_to_result_map: Optional[_ResultMapAppender] = ..., **kwargs: Any) -> str: ...
    def visit_next_value_func(self, next_value, **kw): ...
    def visit_sequence(self, sequence, **kw) -> None: ...
    def function_argspec(self, func, **kwargs): ...
    compile_state: Incomplete
    def visit_compound_select(self, cs, asfrom: bool = ..., compound_index: Incomplete | None = ..., **kwargs): ...
    def visit_unary(self, unary, add_to_result_map: Incomplete | None = ..., result_map_targets=..., **kw): ...
    def visit_truediv_binary(self, binary, operator, **kw): ...
    def visit_floordiv_binary(self, binary, operator, **kw): ...
    def visit_is_true_unary_operator(self, element, operator, **kw): ...
    def visit_is_false_unary_operator(self, element, operator, **kw): ...
    def visit_not_match_op_binary(self, binary, operator, **kw): ...
    def visit_not_in_op_binary(self, binary, operator, **kw): ...
    def visit_empty_set_op_expr(self, type_, expand_op, **kw): ...
    def visit_empty_set_expr(self, element_types, **kw) -> None: ...
    def visit_binary(self, binary, override_operator: Incomplete | None = ..., eager_grouping: bool = ..., from_linter: Incomplete | None = ..., lateral_from_linter: Incomplete | None = ..., **kw): ...
    def visit_function_as_comparison_op_binary(self, element, operator, **kw): ...
    def visit_mod_binary(self, binary, operator, **kw): ...
    def visit_custom_op_binary(self, element, operator, **kw): ...
    def visit_custom_op_unary_operator(self, element, operator, **kw): ...
    def visit_custom_op_unary_modifier(self, element, operator, **kw): ...
    def visit_ilike_case_insensitive_operand(self, element, **kw): ...
    def visit_contains_op_binary(self, binary, operator, **kw): ...
    def visit_not_contains_op_binary(self, binary, operator, **kw): ...
    def visit_icontains_op_binary(self, binary, operator, **kw): ...
    def visit_not_icontains_op_binary(self, binary, operator, **kw): ...
    def visit_startswith_op_binary(self, binary, operator, **kw): ...
    def visit_not_startswith_op_binary(self, binary, operator, **kw): ...
    def visit_istartswith_op_binary(self, binary, operator, **kw): ...
    def visit_not_istartswith_op_binary(self, binary, operator, **kw): ...
    def visit_endswith_op_binary(self, binary, operator, **kw): ...
    def visit_not_endswith_op_binary(self, binary, operator, **kw): ...
    def visit_iendswith_op_binary(self, binary, operator, **kw): ...
    def visit_not_iendswith_op_binary(self, binary, operator, **kw): ...
    def visit_like_op_binary(self, binary, operator, **kw): ...
    def visit_not_like_op_binary(self, binary, operator, **kw): ...
    def visit_ilike_op_binary(self, binary, operator, **kw): ...
    def visit_not_ilike_op_binary(self, binary, operator, **kw): ...
    def visit_between_op_binary(self, binary, operator, **kw): ...
    def visit_not_between_op_binary(self, binary, operator, **kw): ...
    def visit_regexp_match_op_binary(self, binary, operator, **kw) -> None: ...
    def visit_not_regexp_match_op_binary(self, binary, operator, **kw) -> None: ...
    def visit_regexp_replace_op_binary(self, binary, operator, **kw) -> None: ...
    def visit_bindparam(self, bindparam, within_columns_clause: bool = ..., literal_binds: bool = ..., skip_bind_expression: bool = ..., literal_execute: bool = ..., render_postcompile: bool = ..., **kwargs): ...
    def render_bind_cast(self, type_, dbapi_type, sqltext) -> None: ...
    def render_literal_bindparam(self, bindparam, render_literal_value=..., bind_expression_template: Incomplete | None = ..., **kw): ...
    def render_literal_value(self, value, type_): ...
    def bindparam_string(self, name: str, post_compile: bool = ..., expanding: bool = ..., escaped_from: Optional[str] = ..., bindparam_type: Optional[TypeEngine[Any]] = ..., accumulate_bind_names: Optional[Set[str]] = ..., visited_bindparam: Optional[List[str]] = ..., **kw: Any) -> str: ...
    def visit_cte(self, cte: CTE, asfrom: bool = ..., ashint: bool = ..., fromhints: Optional[_FromHintsType] = ..., visiting_cte: Optional[CTE] = ..., from_linter: Optional[FromLinter] = ..., cte_opts: selectable._CTEOpts = ..., **kwargs: Any) -> Optional[str]: ...
    def visit_table_valued_alias(self, element, **kw): ...
    def visit_table_valued_column(self, element, **kw): ...
    def visit_alias(self, alias, asfrom: bool = ..., ashint: bool = ..., iscrud: bool = ..., fromhints: Incomplete | None = ..., subquery: bool = ..., lateral: bool = ..., enclosing_alias: Incomplete | None = ..., from_linter: Incomplete | None = ..., **kwargs): ...
    def visit_subquery(self, subquery, **kw): ...
    def visit_lateral(self, lateral_, **kw): ...
    def visit_tablesample(self, tablesample, asfrom: bool = ..., **kw): ...
    def visit_values(self, element, asfrom: bool = ..., from_linter: Incomplete | None = ..., **kw): ...
    def visit_scalar_values(self, element, **kw): ...
    def get_render_as_alias_suffix(self, alias_name_text): ...
    def format_from_hint_text(self, sqltext, table, hint, iscrud): ...
    def get_select_hint_text(self, byfroms) -> None: ...
    def get_from_hint_text(self, table, text) -> None: ...
    def get_crud_hint_text(self, table, text) -> None: ...
    def get_statement_hint_text(self, hint_texts): ...
    translate_select_structure: Any
    def visit_select(self, select_stmt, asfrom: bool = ..., insert_into: bool = ..., fromhints: Incomplete | None = ..., compound_index: Incomplete | None = ..., select_wraps_for: Incomplete | None = ..., lateral: bool = ..., from_linter: Incomplete | None = ..., **kwargs): ...
    def get_cte_preamble(self, recursive): ...
    def get_select_precolumns(self, select, **kw): ...
    def group_by_clause(self, select, **kw): ...
    def order_by_clause(self, select, **kw): ...
    def for_update_clause(self, select, **kw): ...
    def returning_clause(self, stmt: UpdateBase, returning_cols: Sequence[ColumnElement[Any]], *, populate_result_map: bool, **kw: Any) -> str: ...
    def limit_clause(self, select, **kw): ...
    def fetch_clause(self, select, fetch_clause: Incomplete | None = ..., require_offset: bool = ..., use_literal_execute_for_simple_int: bool = ..., **kw): ...
    def visit_table(self, table, asfrom: bool = ..., iscrud: bool = ..., ashint: bool = ..., fromhints: Incomplete | None = ..., use_schema: bool = ..., from_linter: Incomplete | None = ..., ambiguous_table_name_map: Incomplete | None = ..., **kwargs): ...
    def visit_join(self, join, asfrom: bool = ..., from_linter: Incomplete | None = ..., **kwargs): ...
    dml_compile_state: Incomplete
    def visit_insert(self, insert_stmt, visited_bindparam: Incomplete | None = ..., **kw): ...
    def update_limit_clause(self, update_stmt) -> None: ...
    def update_tables_clause(self, update_stmt, from_table, extra_froms, **kw): ...
    def update_from_clause(self, update_stmt, from_table, extra_froms, from_hints, **kw) -> None: ...
    from_linter: Incomplete
    def visit_update(self, update_stmt, **kw): ...
    def delete_extra_from_clause(self, update_stmt, from_table, extra_froms, from_hints, **kw) -> None: ...
    def delete_table_clause(self, delete_stmt, from_table, extra_froms, **kw): ...
    def visit_delete(self, delete_stmt, **kw): ...
    def visit_savepoint(self, savepoint_stmt, **kw): ...
    def visit_rollback_to_savepoint(self, savepoint_stmt, **kw): ...
    def visit_release_savepoint(self, savepoint_stmt, **kw): ...

class StrSQLCompiler(SQLCompiler):
    def visit_unsupported_compilation(self, element, err, **kw): ...
    def visit_getitem_binary(self, binary, operator, **kw): ...
    def visit_json_getitem_op_binary(self, binary, operator, **kw): ...
    def visit_json_path_getitem_op_binary(self, binary, operator, **kw): ...
    def visit_sequence(self, seq, **kw): ...
    def returning_clause(self, stmt: UpdateBase, returning_cols: Sequence[ColumnElement[Any]], *, populate_result_map: bool, **kw: Any) -> str: ...
    def update_from_clause(self, update_stmt, from_table, extra_froms, from_hints, **kw): ...
    def delete_extra_from_clause(self, update_stmt, from_table, extra_froms, from_hints, **kw): ...
    def visit_empty_set_expr(self, type_, **kw): ...
    def get_from_hint_text(self, table, text): ...
    def visit_regexp_match_op_binary(self, binary, operator, **kw): ...
    def visit_not_regexp_match_op_binary(self, binary, operator, **kw): ...
    def visit_regexp_replace_op_binary(self, binary, operator, **kw): ...
    def visit_try_cast(self, cast, **kwargs): ...

class DDLCompiler(Compiled):
    is_ddl: bool
    def __init__(self, dialect: Dialect, statement: ExecutableDDLElement, schema_translate_map: Optional[SchemaTranslateMapType] = ..., render_schema_translate: bool = ..., compile_kwargs: Mapping[str, Any] = ...) -> None: ...
    def sql_compiler(self): ...
    def type_compiler(self): ...
    def construct_params(self, params: Optional[_CoreSingleExecuteParams] = ..., extracted_parameters: Optional[Sequence[BindParameter[Any]]] = ..., escape_names: bool = ...) -> Optional[_MutableCoreSingleExecuteParams]: ...
    def visit_ddl(self, ddl, **kwargs): ...
    def visit_create_schema(self, create, **kw): ...
    def visit_drop_schema(self, drop, **kw): ...
    def visit_create_table(self, create, **kw): ...
    def visit_create_column(self, create, first_pk: bool = ..., **kw): ...
    def create_table_constraints(self, table, _include_foreign_key_constraints: Incomplete | None = ..., **kw): ...
    def visit_drop_table(self, drop, **kw): ...
    def visit_drop_view(self, drop, **kw): ...
    def visit_create_index(self, create, include_schema: bool = ..., include_table_schema: bool = ..., **kw): ...
    def visit_drop_index(self, drop, **kw): ...
    def visit_add_constraint(self, create, **kw): ...
    def visit_set_table_comment(self, create, **kw): ...
    def visit_drop_table_comment(self, drop, **kw): ...
    def visit_set_column_comment(self, create, **kw): ...
    def visit_drop_column_comment(self, drop, **kw): ...
    def visit_set_constraint_comment(self, create, **kw) -> None: ...
    def visit_drop_constraint_comment(self, drop, **kw) -> None: ...
    def get_identity_options(self, identity_options): ...
    def visit_create_sequence(self, create, prefix: Incomplete | None = ..., **kw): ...
    def visit_drop_sequence(self, drop, **kw): ...
    def visit_drop_constraint(self, drop, **kw): ...
    def get_column_specification(self, column, **kwargs): ...
    def create_table_suffix(self, table): ...
    def post_create_table(self, table): ...
    def get_column_default_string(self, column): ...
    def render_default_string(self, default): ...
    def visit_table_or_column_check_constraint(self, constraint, **kw): ...
    def visit_check_constraint(self, constraint, **kw): ...
    def visit_column_check_constraint(self, constraint, **kw): ...
    def visit_primary_key_constraint(self, constraint, **kw): ...
    def visit_foreign_key_constraint(self, constraint, **kw): ...
    def define_constraint_remote_table(self, constraint, table, preparer): ...
    def visit_unique_constraint(self, constraint, **kw): ...
    def define_unique_constraint_distinct(self, constraint, **kw): ...
    def define_constraint_cascades(self, constraint): ...
    def define_constraint_deferrability(self, constraint): ...
    def define_constraint_match(self, constraint): ...
    def visit_computed_column(self, generated, **kw): ...
    def visit_identity_column(self, identity, **kw): ...

class GenericTypeCompiler(TypeCompiler):
    def visit_FLOAT(self, type_, **kw): ...
    def visit_DOUBLE(self, type_, **kw): ...
    def visit_DOUBLE_PRECISION(self, type_, **kw): ...
    def visit_REAL(self, type_, **kw): ...
    def visit_NUMERIC(self, type_, **kw): ...
    def visit_DECIMAL(self, type_, **kw): ...
    def visit_INTEGER(self, type_, **kw): ...
    def visit_SMALLINT(self, type_, **kw): ...
    def visit_BIGINT(self, type_, **kw): ...
    def visit_TIMESTAMP(self, type_, **kw): ...
    def visit_DATETIME(self, type_, **kw): ...
    def visit_DATE(self, type_, **kw): ...
    def visit_TIME(self, type_, **kw): ...
    def visit_CLOB(self, type_, **kw): ...
    def visit_NCLOB(self, type_, **kw): ...
    def visit_CHAR(self, type_, **kw): ...
    def visit_NCHAR(self, type_, **kw): ...
    def visit_VARCHAR(self, type_, **kw): ...
    def visit_NVARCHAR(self, type_, **kw): ...
    def visit_TEXT(self, type_, **kw): ...
    def visit_BLOB(self, type_, **kw): ...
    def visit_BINARY(self, type_, **kw): ...
    def visit_VARBINARY(self, type_, **kw): ...
    def visit_BOOLEAN(self, type_, **kw): ...
    def visit_uuid(self, type_, **kw): ...
    def visit_large_binary(self, type_, **kw): ...
    def visit_boolean(self, type_, **kw): ...
    def visit_time(self, type_, **kw): ...
    def visit_datetime(self, type_, **kw): ...
    def visit_date(self, type_, **kw): ...
    def visit_big_integer(self, type_, **kw): ...
    def visit_small_integer(self, type_, **kw): ...
    def visit_integer(self, type_, **kw): ...
    def visit_real(self, type_, **kw): ...
    def visit_float(self, type_, **kw): ...
    def visit_double(self, type_, **kw): ...
    def visit_numeric(self, type_, **kw): ...
    def visit_string(self, type_, **kw): ...
    def visit_unicode(self, type_, **kw): ...
    def visit_text(self, type_, **kw): ...
    def visit_unicode_text(self, type_, **kw): ...
    def visit_enum(self, type_, **kw): ...
    def visit_null(self, type_, **kw) -> None: ...
    def visit_type_decorator(self, type_, **kw): ...
    def visit_user_defined(self, type_, **kw): ...

class StrSQLTypeCompiler(GenericTypeCompiler):
    def process(self, type_, **kw): ...
    def __getattr__(self, key): ...
    def visit_null(self, type_, **kw): ...
    def visit_user_defined(self, type_, **kw): ...

class _SchemaForObjectCallable(Protocol):
    def __call__(self, obj: Any) -> str: ...

class _BindNameForColProtocol(Protocol):
    def __call__(self, col: ColumnClause[Any]) -> str: ...

class IdentifierPreparer:
    reserved_words = RESERVED_WORDS
    legal_characters = LEGAL_CHARACTERS
    illegal_initial_characters = ILLEGAL_INITIAL_CHARACTERS
    initial_quote: str
    final_quote: str
    schema_for_object: _SchemaForObjectCallable
    dialect: Incomplete
    escape_quote: Incomplete
    escape_to_quote: Incomplete
    omit_schema: Incomplete
    quote_case_sensitive_collations: Incomplete
    def __init__(self, dialect, initial_quote: str = ..., final_quote: Incomplete | None = ..., escape_quote: str = ..., quote_case_sensitive_collations: bool = ..., omit_schema: bool = ...) -> None: ...
    def validate_sql_phrase(self, element, reg): ...
    def quote_identifier(self, value: str) -> str: ...
    def quote_schema(self, schema: str, force: Any = ...) -> str: ...
    def quote(self, ident: str, force: Any = ...) -> str: ...
    def format_collation(self, collation_name): ...
    def format_sequence(self, sequence, use_schema: bool = ...): ...
    def format_label(self, label: Label[Any], name: Optional[str] = ...) -> str: ...
    def format_alias(self, alias: Optional[AliasedReturnsRows], name: Optional[str] = ...) -> str: ...
    def format_savepoint(self, savepoint, name: Incomplete | None = ...): ...
    def format_constraint(self, constraint, _alembic_quote: bool = ...): ...
    def truncate_and_render_index_name(self, name, _alembic_quote: bool = ...): ...
    def truncate_and_render_constraint_name(self, name, _alembic_quote: bool = ...): ...
    def format_index(self, index): ...
    def format_table(self, table, use_schema: bool = ..., name: Incomplete | None = ...): ...
    def format_schema(self, name): ...
    def format_label_name(self, name, anon_map: Incomplete | None = ...): ...
    def format_column(self, column, use_table: bool = ..., name: Incomplete | None = ..., table_name: Incomplete | None = ..., use_schema: bool = ..., anon_map: Incomplete | None = ...): ...
    def format_table_seq(self, table, use_schema: bool = ...): ...
    def unformat_identifiers(self, identifiers): ...
