from . import coercions as coercions, operators as operators, roles as roles, traversals as traversals, type_api as type_api
from .. import exc as exc, inspection as inspection, util as util
from ..engine import Connection as Connection, Dialect as Dialect, Engine as Engine
from ..engine.interfaces import CacheStats as CacheStats, CompiledCacheType as CompiledCacheType, CoreExecuteOptionsParameter as CoreExecuteOptionsParameter, SchemaTranslateMapType as SchemaTranslateMapType
from ..engine.result import Result as Result
from ..util import HasMemoized_ro_memoized_attribute as HasMemoized_ro_memoized_attribute, TypingOnly as TypingOnly
from ..util.typing import Literal as Literal, Self as Self
from ._typing import _ColumnExpressionArgument, _InfoType, _TypeEngineArgument, has_schema_attr as has_schema_attr, is_named_from_clause as is_named_from_clause, is_quoted_name as is_quoted_name, is_tuple_type as is_tuple_type
from .annotation import Annotated as Annotated, SupportsWrappingAnnotations as SupportsWrappingAnnotations
from .base import Executable as Executable, Generative as Generative, HasMemoized as HasMemoized, Immutable as Immutable, NO_ARG as NO_ARG, SingletonConstant as SingletonConstant, _NoArg
from .cache_key import CacheKey as CacheKey, MemoizedHasCacheKey as MemoizedHasCacheKey, NO_CACHE as NO_CACHE
from .compiler import Compiled as Compiled, SQLCompiler as SQLCompiler
from .functions import FunctionElement as FunctionElement
from .operators import ColumnOperators as ColumnOperators, OperatorType as OperatorType
from .schema import Column as Column, DefaultGenerator as DefaultGenerator, FetchedValue as FetchedValue, ForeignKey as ForeignKey
from .selectable import FromClause as FromClause, NamedFromClause as NamedFromClause, TextualSelect as TextualSelect
from .sqltypes import TupleType as TupleType
from .traversals import HasCopyInternals as HasCopyInternals
from .type_api import TypeEngine as TypeEngine
from .visitors import ExternallyTraversible as ExternallyTraversible, InternalTraversal as InternalTraversal, Visitable as Visitable, cloned_traverse as cloned_traverse, traverse as traverse
from _typeshed import Incomplete
from enum import IntEnum
from typing import AbstractSet, Any, Callable, Dict, FrozenSet, Generic, Iterable, Iterator, List, Mapping, Optional, Sequence, Tuple as typing_Tuple, Type, Union, overload

@overload
def literal(value: Any, type_: _TypeEngineArgument[_T], literal_execute: bool = ...) -> BindParameter[_T]: ...
@overload
def literal(value: _T, type_: None = ..., literal_execute: bool = ...) -> BindParameter[_T]: ...
@overload
def literal(value: Any, type_: Optional[_TypeEngineArgument[Any]] = ..., literal_execute: bool = ...) -> BindParameter[Any]: ...
def literal_column(text: str, type_: Optional[_TypeEngineArgument[_T]] = ...) -> ColumnClause[_T]: ...

class CompilerElement(Visitable):
    __visit_name__: str
    supports_execution: bool
    stringify_dialect: str
    def compile(self, bind: Optional[Union[Engine, Connection]] = ..., dialect: Optional[Dialect] = ..., **kw: Any) -> Compiled: ...

class ClauseElement(SupportsWrappingAnnotations, MemoizedHasCacheKey, HasCopyInternals, ExternallyTraversible, CompilerElement):
    __visit_name__: str
    def description(self) -> Optional[str]: ...
    is_clause_element: bool
    is_selectable: bool
    is_dml: bool
    negation_clause: ColumnElement[bool]
    def get_children(self, *, omit_attrs: typing_Tuple[str, ...] = ..., **kw: Any) -> Iterable[ClauseElement]: ...
    @property
    def entity_namespace(self) -> None: ...
    def unique_params(self, __optionaldict: Optional[Dict[str, Any]] = ..., **kwargs: Any) -> Self: ...
    def params(self, __optionaldict: Optional[Mapping[str, Any]] = ..., **kwargs: Any) -> Self: ...
    def compare(self, other: ClauseElement, **kw: Any) -> bool: ...
    def self_group(self, against: Optional[OperatorType] = ...) -> ClauseElement: ...
    def __invert__(self): ...
    def __bool__(self) -> bool: ...

class DQLDMLClauseElement(ClauseElement):
    def compile(self, bind: Optional[Union[Engine, Connection]] = ..., dialect: Optional[Dialect] = ..., **kw: Any) -> SQLCompiler: ...

class CompilerColumnElement(roles.DMLColumnRole, roles.DDLConstraintColumnRole, roles.ColumnsClauseRole, CompilerElement): ...

class SQLCoreOperations(ColumnOperators, TypingOnly, Generic[_T_co]):
    def operate(self, op: OperatorType, *other: Any, **kwargs: Any) -> ColumnElement[Any]: ...
    def reverse_operate(self, op: OperatorType, other: Any, **kwargs: Any) -> ColumnElement[Any]: ...
    @overload
    def op(self, opstring: str, precedence: int = ..., is_comparison: bool = ..., *, return_type: _TypeEngineArgument[_OPT], python_impl: Optional[Callable[..., Any]] = ...) -> Callable[[Any], BinaryExpression[_OPT]]: ...
    @overload
    def op(self, opstring: str, precedence: int = ..., is_comparison: bool = ..., return_type: Optional[_TypeEngineArgument[Any]] = ..., python_impl: Optional[Callable[..., Any]] = ...) -> Callable[[Any], BinaryExpression[Any]]: ...
    def bool_op(self, opstring: str, precedence: int = ..., python_impl: Optional[Callable[..., Any]] = ...) -> Callable[[Any], BinaryExpression[bool]]: ...
    def __and__(self, other: Any) -> BooleanClauseList: ...
    def __or__(self, other: Any) -> BooleanClauseList: ...
    def __invert__(self) -> ColumnElement[_T_co]: ...
    def __lt__(self, other: Any) -> ColumnElement[bool]: ...
    def __le__(self, other: Any) -> ColumnElement[bool]: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> ColumnElement[bool]: ...
    def __ne__(self, other: Any) -> ColumnElement[bool]: ...
    def is_distinct_from(self, other: Any) -> ColumnElement[bool]: ...
    def is_not_distinct_from(self, other: Any) -> ColumnElement[bool]: ...
    def __gt__(self, other: Any) -> ColumnElement[bool]: ...
    def __ge__(self, other: Any) -> ColumnElement[bool]: ...
    def __neg__(self) -> UnaryExpression[_T_co]: ...
    def __contains__(self, other: Any) -> ColumnElement[bool]: ...
    def __getitem__(self, index: Any) -> ColumnElement[Any]: ...
    @overload
    def __lshift__(self, other: Any) -> ColumnElement[int]: ...
    @overload
    def __lshift__(self, other: Any) -> ColumnElement[Any]: ...
    @overload
    def __rshift__(self, other: Any) -> ColumnElement[int]: ...
    @overload
    def __rshift__(self, other: Any) -> ColumnElement[Any]: ...
    @overload
    def concat(self, other: Any) -> ColumnElement[str]: ...
    @overload
    def concat(self, other: Any) -> ColumnElement[Any]: ...
    def like(self, other: Any, escape: Optional[str] = ...) -> BinaryExpression[bool]: ...
    def ilike(self, other: Any, escape: Optional[str] = ...) -> BinaryExpression[bool]: ...
    def bitwise_xor(self, other: Any) -> BinaryExpression[Any]: ...
    def bitwise_or(self, other: Any) -> BinaryExpression[Any]: ...
    def bitwise_and(self, other: Any) -> BinaryExpression[Any]: ...
    def bitwise_not(self) -> UnaryExpression[_T_co]: ...
    def bitwise_lshift(self, other: Any) -> BinaryExpression[Any]: ...
    def bitwise_rshift(self, other: Any) -> BinaryExpression[Any]: ...
    def in_(self, other: Union[Iterable[Any], BindParameter[Any], roles.InElementRole]) -> BinaryExpression[bool]: ...
    def not_in(self, other: Union[Iterable[Any], BindParameter[Any], roles.InElementRole]) -> BinaryExpression[bool]: ...
    def notin_(self, other: Union[Iterable[Any], BindParameter[Any], roles.InElementRole]) -> BinaryExpression[bool]: ...
    def not_like(self, other: Any, escape: Optional[str] = ...) -> BinaryExpression[bool]: ...
    def notlike(self, other: Any, escape: Optional[str] = ...) -> BinaryExpression[bool]: ...
    def not_ilike(self, other: Any, escape: Optional[str] = ...) -> BinaryExpression[bool]: ...
    def notilike(self, other: Any, escape: Optional[str] = ...) -> BinaryExpression[bool]: ...
    def is_(self, other: Any) -> BinaryExpression[bool]: ...
    def is_not(self, other: Any) -> BinaryExpression[bool]: ...
    def isnot(self, other: Any) -> BinaryExpression[bool]: ...
    def startswith(self, other: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> ColumnElement[bool]: ...
    def istartswith(self, other: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> ColumnElement[bool]: ...
    def endswith(self, other: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> ColumnElement[bool]: ...
    def iendswith(self, other: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> ColumnElement[bool]: ...
    def contains(self, other: Any, **kw: Any) -> ColumnElement[bool]: ...
    def icontains(self, other: Any, **kw: Any) -> ColumnElement[bool]: ...
    def match(self, other: Any, **kwargs: Any) -> ColumnElement[bool]: ...
    def regexp_match(self, pattern: Any, flags: Optional[str] = ...) -> ColumnElement[bool]: ...
    def regexp_replace(self, pattern: Any, replacement: Any, flags: Optional[str] = ...) -> ColumnElement[str]: ...
    def desc(self) -> UnaryExpression[_T_co]: ...
    def asc(self) -> UnaryExpression[_T_co]: ...
    def nulls_first(self) -> UnaryExpression[_T_co]: ...
    def nullsfirst(self) -> UnaryExpression[_T_co]: ...
    def nulls_last(self) -> UnaryExpression[_T_co]: ...
    def nullslast(self) -> UnaryExpression[_T_co]: ...
    def collate(self, collation: str) -> CollationClause: ...
    def between(self, cleft: Any, cright: Any, symmetric: bool = ...) -> BinaryExpression[bool]: ...
    def distinct(self) -> UnaryExpression[_T_co]: ...
    def any_(self) -> CollectionAggregate[Any]: ...
    def all_(self) -> CollectionAggregate[Any]: ...
    @overload
    def __add__(self, other: Any) -> ColumnElement[_NMT]: ...
    @overload
    def __add__(self, other: Any) -> ColumnElement[str]: ...
    @overload
    def __radd__(self, other: Any) -> ColumnElement[_NMT]: ...
    @overload
    def __radd__(self, other: Any) -> ColumnElement[str]: ...
    @overload
    def __sub__(self, other: Any) -> ColumnElement[_NMT]: ...
    @overload
    def __sub__(self, other: Any) -> ColumnElement[Any]: ...
    @overload
    def __rsub__(self, other: Any) -> ColumnElement[_NMT]: ...
    @overload
    def __rsub__(self, other: Any) -> ColumnElement[Any]: ...
    @overload
    def __mul__(self, other: Any) -> ColumnElement[_NMT]: ...
    @overload
    def __mul__(self, other: Any) -> ColumnElement[Any]: ...
    @overload
    def __rmul__(self, other: Any) -> ColumnElement[_NMT]: ...
    @overload
    def __rmul__(self, other: Any) -> ColumnElement[Any]: ...
    @overload
    def __mod__(self, other: Any) -> ColumnElement[_NMT]: ...
    @overload
    def __mod__(self, other: Any) -> ColumnElement[Any]: ...
    @overload
    def __rmod__(self, other: Any) -> ColumnElement[_NMT]: ...
    @overload
    def __rmod__(self, other: Any) -> ColumnElement[Any]: ...
    @overload
    def __truediv__(self, other: Any) -> ColumnElement[_NUMERIC]: ...
    @overload
    def __truediv__(self, other: Any) -> ColumnElement[_NT]: ...
    @overload
    def __truediv__(self, other: Any) -> ColumnElement[Any]: ...
    @overload
    def __rtruediv__(self, other: Any) -> ColumnElement[_NUMERIC]: ...
    @overload
    def __rtruediv__(self, other: Any) -> ColumnElement[Any]: ...
    @overload
    def __floordiv__(self, other: Any) -> ColumnElement[_NMT]: ...
    @overload
    def __floordiv__(self, other: Any) -> ColumnElement[Any]: ...
    @overload
    def __rfloordiv__(self, other: Any) -> ColumnElement[_NMT]: ...
    @overload
    def __rfloordiv__(self, other: Any) -> ColumnElement[Any]: ...

class SQLColumnExpression(SQLCoreOperations[_T_co], roles.ExpressionElementRole[_T_co], TypingOnly): ...

class ColumnElement(roles.ColumnArgumentOrKeyRole, roles.StatementOptionRole, roles.WhereHavingRole, roles.BinaryElementRole[_T], roles.OrderByRole, roles.ColumnsClauseRole, roles.LimitOffsetRole, roles.DMLColumnRole, roles.DDLConstraintColumnRole, roles.DDLExpressionRole, SQLColumnExpression[_T], DQLDMLClauseElement):
    __visit_name__: str
    primary_key: bool
    foreign_keys: AbstractSet[ForeignKey]
    key: Optional[str]
    @overload
    def self_group(self, against: Optional[OperatorType] = ...) -> ColumnElement[_T]: ...
    @overload
    def self_group(self, against: Optional[OperatorType] = ...) -> ColumnElement[Any]: ...
    type: TypeEngine[_T]
    def comparator(self) -> TypeEngine.Comparator[_T]: ...
    def __getattr__(self, key: str) -> Any: ...
    def operate(self, op: operators.OperatorType, *other: Any, **kwargs: Any) -> ColumnElement[Any]: ...
    def reverse_operate(self, op: operators.OperatorType, other: Any, **kwargs: Any) -> ColumnElement[Any]: ...
    @property
    def expression(self) -> ColumnElement[Any]: ...
    def base_columns(self) -> FrozenSet[ColumnElement[Any]]: ...
    def proxy_set(self) -> FrozenSet[ColumnElement[Any]]: ...
    def shares_lineage(self, othercolumn: ColumnElement[Any]) -> bool: ...
    def cast(self, type_: _TypeEngineArgument[_OPT]) -> Cast[_OPT]: ...
    def label(self, name: Optional[str]) -> Label[_T]: ...
    @property
    def anon_label(self) -> str: ...
    @property
    def anon_key_label(self) -> str: ...

class KeyedColumnElement(ColumnElement[_T]):
    key: str

class WrapsColumnExpression(ColumnElement[_T]):
    @property
    def wrapped_column_expression(self) -> ColumnElement[_T]: ...

class BindParameter(roles.InElementRole, KeyedColumnElement[_T]):
    __visit_name__: str
    key: str
    type: TypeEngine[_T]
    value: Optional[_T]
    inherit_cache: bool
    unique: Incomplete
    callable: Incomplete
    isoutparam: Incomplete
    required: Incomplete
    expanding: Incomplete
    expand_op: Incomplete
    literal_execute: Incomplete
    def __init__(self, key: Optional[str], value: Any = ..., type_: Optional[_TypeEngineArgument[_T]] = ..., unique: bool = ..., required: Union[bool, Literal[_NoArg.NO_ARG]] = ..., quote: Optional[bool] = ..., callable_: Optional[Callable[[], Any]] = ..., expanding: bool = ..., isoutparam: bool = ..., literal_execute: bool = ..., _compared_to_operator: Optional[OperatorType] = ..., _compared_to_type: Optional[TypeEngine[Any]] = ..., _is_crud: bool = ...) -> None: ...
    @property
    def effective_value(self) -> Optional[_T]: ...
    def render_literal_execute(self) -> BindParameter[_T]: ...

class TypeClause(DQLDMLClauseElement):
    __visit_name__: str
    type: Incomplete
    def __init__(self, type_) -> None: ...

class TextClause(roles.DDLConstraintColumnRole, roles.DDLExpressionRole, roles.StatementOptionRole, roles.WhereHavingRole, roles.OrderByRole, roles.FromClauseRole, roles.SelectStatementRole, roles.InElementRole, Generative, Executable, DQLDMLClauseElement, roles.BinaryElementRole[Any], inspection.Inspectable['TextClause']):
    __visit_name__: str
    def __and__(self, other): ...
    key: Optional[str]
    text: Incomplete
    def __init__(self, text: str) -> None: ...
    def bindparams(self, *binds: BindParameter[Any], **names_to_values: Any) -> Self: ...
    def columns(self, *cols: _ColumnExpressionArgument[Any], **types: TypeEngine[Any]) -> TextualSelect: ...
    @property
    def type(self) -> TypeEngine[Any]: ...
    @property
    def comparator(self): ...
    def self_group(self, against: Incomplete | None = ...): ...

class Null(SingletonConstant, roles.ConstExprRole[None], ColumnElement[None]):
    __visit_name__: str
    def type(self): ...

class False_(SingletonConstant, roles.ConstExprRole[bool], ColumnElement[bool]):
    __visit_name__: str
    def type(self): ...

class True_(SingletonConstant, roles.ConstExprRole[bool], ColumnElement[bool]):
    __visit_name__: str
    def type(self): ...

class ClauseList(roles.InElementRole, roles.OrderByRole, roles.ColumnsClauseRole, roles.DMLColumnRole, DQLDMLClauseElement):
    __visit_name__: str
    clauses: List[ColumnElement[Any]]
    operator: Incomplete
    group: Incomplete
    group_contents: Incomplete
    def __init__(self, *clauses: _ColumnExpressionArgument[Any], operator: OperatorType = ..., group: bool = ..., group_contents: bool = ..., _literal_as_text_role: Type[roles.SQLRole] = ...) -> None: ...
    def __iter__(self) -> Iterator[ColumnElement[Any]]: ...
    def __len__(self) -> int: ...
    def append(self, clause) -> None: ...
    def self_group(self, against: Incomplete | None = ...): ...

class OperatorExpression(ColumnElement[_T]):
    operator: OperatorType
    type: TypeEngine[_T]
    group: bool
    @property
    def is_comparison(self): ...
    def self_group(self, against: Incomplete | None = ...): ...

class ExpressionClauseList(OperatorExpression[_T]):
    __visit_name__: str
    clauses: typing_Tuple[ColumnElement[Any], ...]
    group: bool
    operator: Incomplete
    type: Incomplete
    def __init__(self, operator: OperatorType, *clauses: _ColumnExpressionArgument[Any], type_: Optional[_TypeEngineArgument[_T]] = ...) -> None: ...
    def __iter__(self) -> Iterator[ColumnElement[Any]]: ...
    def __len__(self) -> int: ...

class BooleanClauseList(ExpressionClauseList[bool]):
    __visit_name__: str
    inherit_cache: bool
    def __init__(self, *arg, **kw) -> None: ...
    @classmethod
    def and_(cls, initial_clause: Union[Literal[True], _ColumnExpressionArgument[bool], _NoArg] = ..., *clauses: _ColumnExpressionArgument[bool]) -> ColumnElement[bool]: ...
    @classmethod
    def or_(cls, initial_clause: Union[Literal[False], _ColumnExpressionArgument[bool], _NoArg] = ..., *clauses: _ColumnExpressionArgument[bool]) -> ColumnElement[bool]: ...
    def self_group(self, against: Incomplete | None = ...): ...

and_: Incomplete
or_: Incomplete

class Tuple(ClauseList, ColumnElement[typing_Tuple[Any, ...]]):
    __visit_name__: str
    type: TupleType
    def __init__(self, *clauses: _ColumnExpressionArgument[Any], types: Optional[Sequence[_TypeEngineArgument[Any]]] = ...) -> None: ...
    def self_group(self, against: Incomplete | None = ...): ...

class Case(ColumnElement[_T]):
    __visit_name__: str
    whens: List[typing_Tuple[ColumnElement[bool], ColumnElement[_T]]]
    else_: Optional[ColumnElement[_T]]
    value: Optional[ColumnElement[Any]]
    type: Incomplete
    def __init__(self, *whens: Union[typing_Tuple[_ColumnExpressionArgument[bool], Any], Mapping[Any, Any]], value: Optional[Any] = ..., else_: Optional[Any] = ...) -> None: ...

class Cast(WrapsColumnExpression[_T]):
    __visit_name__: str
    clause: ColumnElement[Any]
    type: TypeEngine[_T]
    typeclause: TypeClause
    def __init__(self, expression: _ColumnExpressionArgument[Any], type_: _TypeEngineArgument[_T]) -> None: ...
    @property
    def wrapped_column_expression(self): ...

class TryCast(Cast[_T]):
    __visit_name__: str
    inherit_cache: bool

class TypeCoerce(WrapsColumnExpression[_T]):
    __visit_name__: str
    clause: ColumnElement[Any]
    type: TypeEngine[_T]
    def __init__(self, expression: _ColumnExpressionArgument[Any], type_: _TypeEngineArgument[_T]) -> None: ...
    def typed_expression(self): ...
    @property
    def wrapped_column_expression(self): ...
    def self_group(self, against: Incomplete | None = ...): ...

class Extract(ColumnElement[int]):
    __visit_name__: str
    expr: ColumnElement[Any]
    field: str
    type: Incomplete
    def __init__(self, field: str, expr: _ColumnExpressionArgument[Any]) -> None: ...

class _label_reference(ColumnElement[_T]):
    __visit_name__: str
    element: ColumnElement[_T]
    def __init__(self, element: ColumnElement[_T]) -> None: ...

class _textual_label_reference(ColumnElement[Any]):
    __visit_name__: str
    element: Incomplete
    def __init__(self, element: str) -> None: ...

class UnaryExpression(ColumnElement[_T]):
    __visit_name__: str
    element: ClauseElement
    operator: Incomplete
    modifier: Incomplete
    type: Incomplete
    wraps_column_expression: Incomplete
    def __init__(self, element: ColumnElement[Any], operator: Optional[OperatorType] = ..., modifier: Optional[OperatorType] = ..., type_: Optional[_TypeEngineArgument[_T]] = ..., wraps_column_expression: bool = ...) -> None: ...
    def self_group(self, against: Incomplete | None = ...): ...

class CollectionAggregate(UnaryExpression[_T]):
    inherit_cache: bool
    def operate(self, op, *other, **kwargs): ...
    def reverse_operate(self, op, other, **kwargs) -> None: ...

class AsBoolean(WrapsColumnExpression[bool], UnaryExpression[bool]):
    inherit_cache: bool
    element: Incomplete
    type: Incomplete
    operator: Incomplete
    negate: Incomplete
    modifier: Incomplete
    wraps_column_expression: bool
    def __init__(self, element, operator, negate) -> None: ...
    @property
    def wrapped_column_expression(self): ...
    def self_group(self, against: Incomplete | None = ...): ...

class BinaryExpression(OperatorExpression[_T]):
    __visit_name__: str
    modifiers: Optional[Mapping[str, Any]]
    left: ColumnElement[Any]
    right: ColumnElement[Any]
    operator: Incomplete
    type: Incomplete
    negate: Incomplete
    def __init__(self, left: ColumnElement[Any], right: ColumnElement[Any], operator: OperatorType, type_: Optional[_TypeEngineArgument[_T]] = ..., negate: Optional[OperatorType] = ..., modifiers: Optional[Mapping[str, Any]] = ...) -> None: ...
    def __bool__(self) -> bool: ...
    def __invert__(self) -> BinaryExpression[_T]: ...

class Slice(ColumnElement[Any]):
    __visit_name__: str
    start: Incomplete
    stop: Incomplete
    step: Incomplete
    type: Incomplete
    def __init__(self, start, stop, step, _name: Incomplete | None = ...) -> None: ...
    def self_group(self, against: Incomplete | None = ...): ...

class IndexExpression(BinaryExpression[Any]):
    inherit_cache: bool

class GroupedElement(DQLDMLClauseElement):
    __visit_name__: str
    element: ClauseElement
    def self_group(self, against: Incomplete | None = ...): ...

class Grouping(GroupedElement, ColumnElement[_T]):
    element: Union[TextClause, ClauseList, ColumnElement[_T]]
    type: Incomplete
    def __init__(self, element: Union[TextClause, ClauseList, ColumnElement[_T]]) -> None: ...
    def __getattr__(self, attr): ...

class _OverRange(IntEnum):
    RANGE_UNBOUNDED: int
    RANGE_CURRENT: int

RANGE_UNBOUNDED: Incomplete
RANGE_CURRENT: Incomplete

class Over(ColumnElement[_T]):
    __visit_name__: str
    order_by: Optional[ClauseList]
    partition_by: Optional[ClauseList]
    element: ColumnElement[_T]
    range_: Optional[typing_Tuple[int, int]]
    rows: Incomplete
    def __init__(self, element: ColumnElement[_T], partition_by: Optional[Union[Iterable[_ColumnExpressionArgument[Any]], _ColumnExpressionArgument[Any]]] = ..., order_by: Optional[Union[Iterable[_ColumnExpressionArgument[Any]], _ColumnExpressionArgument[Any]]] = ..., range_: Optional[typing_Tuple[Optional[int], Optional[int]]] = ..., rows: Optional[typing_Tuple[Optional[int], Optional[int]]] = ...) -> None: ...
    def __reduce__(self): ...
    def type(self): ...

class WithinGroup(ColumnElement[_T]):
    __visit_name__: str
    order_by: Optional[ClauseList]
    element: Incomplete
    def __init__(self, element: FunctionElement[_T], *order_by: _ColumnExpressionArgument[Any]) -> None: ...
    def __reduce__(self): ...
    def over(self, partition_by: Incomplete | None = ..., order_by: Incomplete | None = ..., range_: Incomplete | None = ..., rows: Incomplete | None = ...): ...
    def type(self): ...

class FunctionFilter(ColumnElement[_T]):
    __visit_name__: str
    criterion: Optional[ColumnElement[bool]]
    func: Incomplete
    def __init__(self, func: FunctionElement[_T], *criterion: _ColumnExpressionArgument[bool]) -> None: ...
    def filter(self, *criterion): ...
    def over(self, partition_by: Optional[Union[Iterable[_ColumnExpressionArgument[Any]], _ColumnExpressionArgument[Any]]] = ..., order_by: Optional[Union[Iterable[_ColumnExpressionArgument[Any]], _ColumnExpressionArgument[Any]]] = ..., range_: Optional[typing_Tuple[Optional[int], Optional[int]]] = ..., rows: Optional[typing_Tuple[Optional[int], Optional[int]]] = ...) -> Over[_T]: ...
    def self_group(self, against: Incomplete | None = ...): ...
    def type(self): ...

class NamedColumn(KeyedColumnElement[_T]):
    is_literal: bool
    table: Optional[FromClause]
    name: str
    key: str
    def description(self) -> str: ...

class Label(roles.LabeledColumnExprRole[_T], NamedColumn[_T]):
    __visit_name__: str
    name: str
    key: Incomplete
    type: Incomplete
    def __init__(self, name: Optional[str], element: _ColumnExpressionArgument[_T], type_: Optional[_TypeEngineArgument[_T]] = ...) -> None: ...
    def __reduce__(self): ...
    def element(self) -> ColumnElement[_T]: ...
    def self_group(self, against: Incomplete | None = ...): ...
    @property
    def primary_key(self): ...
    @property
    def foreign_keys(self): ...

class ColumnClause(roles.DDLReferredColumnRole, roles.LabeledColumnExprRole[_T], roles.StrAsPlainColumnRole, Immutable, NamedColumn[_T]):
    table: Optional[FromClause]
    is_literal: bool
    __visit_name__: str
    onupdate: Optional[DefaultGenerator]
    default: Optional[DefaultGenerator]
    server_default: Optional[FetchedValue]
    server_onupdate: Optional[FetchedValue]
    key: Incomplete
    type: Incomplete
    def __init__(self, text: str, type_: Optional[_TypeEngineArgument[_T]] = ..., is_literal: bool = ..., _selectable: Optional[FromClause] = ...) -> None: ...
    def get_children(self, *, column_tables: bool = ..., **kw): ...
    @property
    def entity_namespace(self): ...

class TableValuedColumn(NamedColumn[_T]):
    __visit_name__: str
    scalar_alias: Incomplete
    key: Incomplete
    type: Incomplete
    def __init__(self, scalar_alias: NamedFromClause, type_: TypeEngine[_T]) -> None: ...

class CollationClause(ColumnElement[str]):
    __visit_name__: str
    collation: Incomplete
    def __init__(self, collation) -> None: ...

class _IdentifiedClause(Executable, ClauseElement):
    __visit_name__: str
    ident: Incomplete
    def __init__(self, ident) -> None: ...

class SavepointClause(_IdentifiedClause):
    __visit_name__: str
    inherit_cache: bool

class RollbackToSavepointClause(_IdentifiedClause):
    __visit_name__: str
    inherit_cache: bool

class ReleaseSavepointClause(_IdentifiedClause):
    __visit_name__: str
    inherit_cache: bool

class quoted_name(util.MemoizedSlots, str):
    quote: Optional[bool]
    @overload
    @classmethod
    def construct(cls, value: str, quote: Optional[bool]) -> quoted_name: ...
    @overload
    @classmethod
    def construct(cls, value: None, quote: Optional[bool]) -> None: ...
    def __new__(cls, value: str, quote: Optional[bool]) -> quoted_name: ...
    def __reduce__(self): ...

class AnnotatedColumnElement(Annotated):
    def __init__(self, element, values) -> None: ...
    def name(self): ...
    def table(self): ...
    def key(self): ...
    def info(self) -> _InfoType: ...

class _truncated_label(quoted_name):
    def __new__(cls, value: str, quote: Optional[bool] = ...) -> Any: ...
    def __reduce__(self) -> Any: ...
    def apply_map(self, map_: Mapping[str, Any]) -> str: ...

class conv(_truncated_label): ...

class _anonymous_label(_truncated_label):
    @classmethod
    def safe_construct(cls, seed: int, body: str, enclosing_label: Optional[str] = ..., sanitize_key: bool = ...) -> _anonymous_label: ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def apply_map(self, map_): ...
