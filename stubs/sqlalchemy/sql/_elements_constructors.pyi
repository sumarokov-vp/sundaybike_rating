from . import coercions as coercions, roles as roles
from ..util.typing import Literal as Literal
from ._typing import _ColumnExpressionArgument, _ColumnExpressionOrLiteralArgument, _ColumnExpressionOrStrLabelArgument, _TypeEngineArgument
from .base import _NoArg
from .elements import BinaryExpression as BinaryExpression, BindParameter as BindParameter, BooleanClauseList as BooleanClauseList, Case as Case, Cast as Cast, CollationClause as CollationClause, CollectionAggregate as CollectionAggregate, ColumnClause as ColumnClause, ColumnElement as ColumnElement, Extract as Extract, False_ as False_, FunctionFilter as FunctionFilter, Label as Label, Null as Null, Over as Over, TextClause as TextClause, True_ as True_, TryCast as TryCast, Tuple as Tuple, TypeCoerce as TypeCoerce, UnaryExpression as UnaryExpression, WithinGroup as WithinGroup
from .functions import FunctionElement as FunctionElement
from .selectable import FromClause as FromClause
from .type_api import TypeEngine as TypeEngine
from typing import Any, Callable, Iterable, Mapping, Optional, Sequence, Tuple as typing_Tuple, Union, overload

def all_(expr: _ColumnExpressionArgument[_T]) -> CollectionAggregate[bool]: ...
def and_(initial_clause: Union[Literal[True], _ColumnExpressionArgument[bool]], *clauses: _ColumnExpressionArgument[bool]) -> ColumnElement[bool]: ...
def any_(expr: _ColumnExpressionArgument[_T]) -> CollectionAggregate[bool]: ...
def asc(column: _ColumnExpressionOrStrLabelArgument[_T]) -> UnaryExpression[_T]: ...
def collate(expression: _ColumnExpressionArgument[str], collation: str) -> BinaryExpression[str]: ...
def between(expr: _ColumnExpressionOrLiteralArgument[_T], lower_bound: Any, upper_bound: Any, symmetric: bool = ...) -> BinaryExpression[bool]: ...
def outparam(key: str, type_: Optional[TypeEngine[_T]] = ...) -> BindParameter[_T]: ...
@overload
def not_(clause: BinaryExpression[_T]) -> BinaryExpression[_T]: ...
@overload
def not_(clause: _ColumnExpressionArgument[_T]) -> ColumnElement[_T]: ...
def bindparam(key: Optional[str], value: Any = ..., type_: Optional[_TypeEngineArgument[_T]] = ..., unique: bool = ..., required: Union[bool, Literal[_NoArg.NO_ARG]] = ..., quote: Optional[bool] = ..., callable_: Optional[Callable[[], Any]] = ..., expanding: bool = ..., isoutparam: bool = ..., literal_execute: bool = ...) -> BindParameter[_T]: ...
def case(*whens: Union[typing_Tuple[_ColumnExpressionArgument[bool], Any], Mapping[Any, Any]], value: Optional[Any] = ..., else_: Optional[Any] = ...) -> Case[Any]: ...
def cast(expression: _ColumnExpressionOrLiteralArgument[Any], type_: _TypeEngineArgument[_T]) -> Cast[_T]: ...
def try_cast(expression: _ColumnExpressionOrLiteralArgument[Any], type_: _TypeEngineArgument[_T]) -> TryCast[_T]: ...
def column(text: str, type_: Optional[_TypeEngineArgument[_T]] = ..., is_literal: bool = ..., _selectable: Optional[FromClause] = ...) -> ColumnClause[_T]: ...
def desc(column: _ColumnExpressionOrStrLabelArgument[_T]) -> UnaryExpression[_T]: ...
def distinct(expr: _ColumnExpressionArgument[_T]) -> UnaryExpression[_T]: ...
def bitwise_not(expr: _ColumnExpressionArgument[_T]) -> UnaryExpression[_T]: ...
def extract(field: str, expr: _ColumnExpressionArgument[Any]) -> Extract: ...
def false() -> False_: ...
def funcfilter(func: FunctionElement[_T], *criterion: _ColumnExpressionArgument[bool]) -> FunctionFilter[_T]: ...
def label(name: str, element: _ColumnExpressionArgument[_T], type_: Optional[_TypeEngineArgument[_T]] = ...) -> Label[_T]: ...
def null() -> Null: ...
def nulls_first(column: _ColumnExpressionArgument[_T]) -> UnaryExpression[_T]: ...
def nulls_last(column: _ColumnExpressionArgument[_T]) -> UnaryExpression[_T]: ...
def or_(initial_clause: Union[Literal[False], _ColumnExpressionArgument[bool]], *clauses: _ColumnExpressionArgument[bool]) -> ColumnElement[bool]: ...
def over(element: FunctionElement[_T], partition_by: Optional[Union[Iterable[_ColumnExpressionArgument[Any]], _ColumnExpressionArgument[Any]]] = ..., order_by: Optional[Union[Iterable[_ColumnExpressionArgument[Any]], _ColumnExpressionArgument[Any]]] = ..., range_: Optional[typing_Tuple[Optional[int], Optional[int]]] = ..., rows: Optional[typing_Tuple[Optional[int], Optional[int]]] = ...) -> Over[_T]: ...
def text(text: str) -> TextClause: ...
def true() -> True_: ...
def tuple_(*clauses: _ColumnExpressionArgument[Any], types: Optional[Sequence[_TypeEngineArgument[Any]]] = ...) -> Tuple: ...
def type_coerce(expression: _ColumnExpressionOrLiteralArgument[Any], type_: _TypeEngineArgument[_T]) -> TypeCoerce[_T]: ...
def within_group(element: FunctionElement[_T], *order_by: _ColumnExpressionArgument[Any]) -> WithinGroup[_T]: ...
