import datetime as dt
import decimal
import enum
from . import coercions as coercions, elements as elements, operators as operators, roles as roles, type_api as type_api
from .. import event as event, exc as exc, inspection as inspection, util as util
from ..engine import processors as processors
from ..engine.interfaces import Dialect as Dialect
from ..util import OrderedDict as OrderedDict, langhelpers as langhelpers
from ..util.typing import Literal as Literal, is_literal as is_literal, typing_get_args as typing_get_args
from ._typing import _ColumnExpressionArgument, _TypeEngineArgument
from .base import NO_ARG as NO_ARG, SchemaEventTarget as SchemaEventTarget
from .cache_key import HasCacheKey as HasCacheKey
from .elements import Slice as Slice, quoted_name as quoted_name
from .operators import OperatorType as OperatorType
from .schema import MetaData as MetaData
from .type_api import Emulated as Emulated, NativeForEmulated as NativeForEmulated, TypeDecorator as TypeDecorator, TypeEngine as TypeEngine, TypeEngineMixin as TypeEngineMixin, Variant as Variant, _BindProcessorType, _ComparatorFactory, _ResultProcessorType
from .visitors import InternalTraversal as InternalTraversal
from _typeshed import Incomplete
from typing import Any, Callable, List, Optional, Sequence, Tuple, Type, Union, overload

class HasExpressionLookup(TypeEngineMixin):
    class Comparator(TypeEngine.Comparator[_CT]): ...
    comparator_factory: _ComparatorFactory[Any]

class Concatenable(TypeEngineMixin):
    class Comparator(TypeEngine.Comparator[_T]): ...
    comparator_factory: _ComparatorFactory[Any]

class Indexable(TypeEngineMixin):
    class Comparator(TypeEngine.Comparator[_T]):
        def __getitem__(self, index): ...
    comparator_factory: _ComparatorFactory[Any]

class String(Concatenable, TypeEngine[str]):
    __visit_name__: str
    length: Incomplete
    collation: Incomplete
    def __init__(self, length: Optional[int] = ..., collation: Optional[str] = ...) -> None: ...
    def literal_processor(self, dialect): ...
    def bind_processor(self, dialect) -> None: ...
    def result_processor(self, dialect, coltype) -> None: ...
    @property
    def python_type(self): ...
    def get_dbapi_type(self, dbapi): ...

class Text(String):
    __visit_name__: str

class Unicode(String):
    __visit_name__: str
    def __init__(self, length: Incomplete | None = ..., **kwargs) -> None: ...

class UnicodeText(Text):
    __visit_name__: str
    def __init__(self, length: Incomplete | None = ..., **kwargs) -> None: ...

class Integer(HasExpressionLookup, TypeEngine[int]):
    __visit_name__: str
    def get_dbapi_type(self, dbapi): ...
    @property
    def python_type(self): ...
    def literal_processor(self, dialect): ...

class SmallInteger(Integer):
    __visit_name__: str

class BigInteger(Integer):
    __visit_name__: str

class Numeric(HasExpressionLookup, TypeEngine[_N]):
    __visit_name__: str
    @overload
    def __init__(self, precision: Optional[int] = ..., scale: Optional[int] = ..., decimal_return_scale: Optional[int] = ..., asdecimal: Literal[True] = ...) -> None: ...
    @overload
    def __init__(self, precision: Optional[int] = ..., scale: Optional[int] = ..., decimal_return_scale: Optional[int] = ..., asdecimal: Literal[False] = ...) -> None: ...
    def get_dbapi_type(self, dbapi): ...
    def literal_processor(self, dialect): ...
    @property
    def python_type(self): ...
    def bind_processor(self, dialect): ...
    def result_processor(self, dialect, coltype): ...

class Float(Numeric[_N]):
    __visit_name__: str
    scale: Incomplete
    @overload
    def __init__(self, precision: Optional[int] = ..., asdecimal: Literal[False] = ..., decimal_return_scale: Optional[int] = ...) -> None: ...
    @overload
    def __init__(self, precision: Optional[int] = ..., asdecimal: Literal[True] = ..., decimal_return_scale: Optional[int] = ...) -> None: ...
    def result_processor(self, dialect, coltype): ...

class Double(Float[_N]):
    __visit_name__: str

class _RenderISO8601NoT: ...

class DateTime(_RenderISO8601NoT, HasExpressionLookup, TypeEngine[dt.datetime]):
    __visit_name__: str
    timezone: Incomplete
    def __init__(self, timezone: bool = ...) -> None: ...
    def get_dbapi_type(self, dbapi): ...
    def literal_processor(self, dialect): ...
    @property
    def python_type(self): ...

class Date(_RenderISO8601NoT, HasExpressionLookup, TypeEngine[dt.date]):
    __visit_name__: str
    def get_dbapi_type(self, dbapi): ...
    @property
    def python_type(self): ...
    def literal_processor(self, dialect): ...

class Time(_RenderISO8601NoT, HasExpressionLookup, TypeEngine[dt.time]):
    __visit_name__: str
    timezone: Incomplete
    def __init__(self, timezone: bool = ...) -> None: ...
    def get_dbapi_type(self, dbapi): ...
    @property
    def python_type(self): ...
    def literal_processor(self, dialect): ...

class _Binary(TypeEngine[bytes]):
    length: Incomplete
    def __init__(self, length: Optional[int] = ...) -> None: ...
    def literal_processor(self, dialect): ...
    @property
    def python_type(self): ...
    def bind_processor(self, dialect): ...
    def result_processor(self, dialect, coltype): ...
    def coerce_compared_value(self, op, value): ...
    def get_dbapi_type(self, dbapi): ...

class LargeBinary(_Binary):
    __visit_name__: str
    def __init__(self, length: Optional[int] = ...) -> None: ...

class SchemaType(SchemaEventTarget, TypeEngineMixin):
    name: Optional[str]
    schema: Incomplete
    metadata: Incomplete
    inherit_schema: Incomplete
    dispatch: Incomplete
    def __init__(self, name: Optional[str] = ..., schema: Optional[str] = ..., metadata: Optional[MetaData] = ..., inherit_schema: bool = ..., quote: Optional[bool] = ..., _create_events: bool = ..., _adapted_from: Optional[SchemaType] = ...) -> None: ...
    def copy(self, **kw): ...
    @overload
    def adapt(self, cls: Type[_TE], **kw: Any) -> _TE: ...
    @overload
    def adapt(self, cls: Type[TypeEngineMixin], **kw: Any) -> TypeEngine[Any]: ...
    def create(self, bind, checkfirst: bool = ...) -> None: ...
    def drop(self, bind, checkfirst: bool = ...) -> None: ...

class Enum(String, SchemaType, Emulated, TypeEngine[Union[str, enum.Enum]]):
    __visit_name__: str
    def __init__(self, *enums: object, **kw: Any) -> None: ...
    @property
    def sort_key_function(self): ...
    @property
    def native(self): ...
    class Comparator(String.Comparator[str]):
        type: String
    comparator_factory = Comparator
    def as_generic(self, allow_nulltype: bool = ...): ...
    def adapt_to_emulated(self, impltype, **kw): ...
    def adapt(self, impltype, **kw): ...
    def literal_processor(self, dialect): ...
    def bind_processor(self, dialect): ...
    def result_processor(self, dialect, coltype): ...
    def copy(self, **kw): ...
    @property
    def python_type(self): ...

class PickleType(TypeDecorator[object]):
    impl = LargeBinary
    cache_ok: bool
    protocol: Incomplete
    pickler: Incomplete
    comparator: Incomplete
    def __init__(self, protocol: int = ..., pickler: Any = ..., comparator: Optional[Callable[[Any, Any], bool]] = ..., impl: Optional[_TypeEngineArgument[Any]] = ...) -> None: ...
    def __reduce__(self): ...
    def bind_processor(self, dialect): ...
    def result_processor(self, dialect, coltype): ...
    def compare_values(self, x, y): ...

class Boolean(SchemaType, Emulated, TypeEngine[bool]):
    __visit_name__: str
    native: bool
    create_constraint: Incomplete
    name: Incomplete
    dispatch: Incomplete
    def __init__(self, create_constraint: bool = ..., name: Optional[str] = ..., _create_events: bool = ..., _adapted_from: Optional[SchemaType] = ...) -> None: ...
    @property
    def python_type(self): ...
    def literal_processor(self, dialect): ...
    def bind_processor(self, dialect): ...
    def result_processor(self, dialect, coltype): ...

class _AbstractInterval(HasExpressionLookup, TypeEngine[dt.timedelta]): ...

class Interval(Emulated, _AbstractInterval, TypeDecorator[dt.timedelta]):
    impl = DateTime
    epoch: Incomplete
    cache_ok: bool
    native: Incomplete
    second_precision: Incomplete
    day_precision: Incomplete
    def __init__(self, native: bool = ..., second_precision: Optional[int] = ..., day_precision: Optional[int] = ...) -> None: ...
    class Comparator(TypeDecorator.Comparator[_CT], _AbstractInterval.Comparator[_CT]): ...
    comparator_factory = Comparator
    @property
    def python_type(self): ...
    def adapt_to_emulated(self, impltype, **kw): ...
    def coerce_compared_value(self, op, value): ...
    def bind_processor(self, dialect: Dialect) -> _BindProcessorType[dt.timedelta]: ...
    def result_processor(self, dialect: Dialect, coltype: Any) -> _ResultProcessorType[dt.timedelta]: ...

class JSON(Indexable, TypeEngine[Any]):
    __visit_name__: str
    hashable: bool
    NULL: Incomplete
    none_as_null: Incomplete
    def __init__(self, none_as_null: bool = ...) -> None: ...
    class JSONElementType(TypeEngine[Any]):
        def string_bind_processor(self, dialect): ...
        def string_literal_processor(self, dialect): ...
        def bind_processor(self, dialect): ...
        def literal_processor(self, dialect): ...
    class JSONIndexType(JSONElementType): ...
    class JSONIntIndexType(JSONIndexType): ...
    class JSONStrIndexType(JSONIndexType): ...
    class JSONPathType(JSONElementType):
        __visit_name__: str
    class Comparator(Indexable.Comparator[_T], Concatenable.Comparator[_T]):
        def as_boolean(self): ...
        def as_string(self): ...
        def as_integer(self): ...
        def as_float(self): ...
        def as_numeric(self, precision, scale, asdecimal: bool = ...): ...
        def as_json(self): ...
    comparator_factory = Comparator
    @property
    def python_type(self): ...
    @property
    def should_evaluate_none(self): ...
    @should_evaluate_none.setter
    def should_evaluate_none(self, value) -> None: ...
    def bind_processor(self, dialect): ...
    def result_processor(self, dialect, coltype): ...

class ARRAY(SchemaEventTarget, Indexable, Concatenable, TypeEngine[Sequence[Any]]):
    __visit_name__: str
    zero_indexes: bool
    class Comparator(Indexable.Comparator[Sequence[Any]], Concatenable.Comparator[Sequence[Any]]):
        type: ARRAY
        def contains(self, *arg, **kw) -> None: ...
        def any(self, other, operator: Incomplete | None = ...): ...
        def all(self, other, operator: Incomplete | None = ...): ...
    comparator_factory = Comparator
    item_type: Incomplete
    as_tuple: Incomplete
    dimensions: Incomplete
    def __init__(self, item_type: _TypeEngineArgument[Any], as_tuple: bool = ..., dimensions: Optional[int] = ..., zero_indexes: bool = ...) -> None: ...
    @property
    def hashable(self): ...
    @property
    def python_type(self): ...
    def compare_values(self, x, y): ...
    def literal_processor(self, dialect): ...

class TupleType(TypeEngine[Tuple[Any, ...]]):
    types: List[TypeEngine[Any]]
    def __init__(self, *types: _TypeEngineArgument[Any]) -> None: ...
    def coerce_compared_value(self, op: Optional[OperatorType], value: Any) -> TypeEngine[Any]: ...
    def result_processor(self, dialect, coltype) -> None: ...

class REAL(Float[_N]):
    __visit_name__: str

class FLOAT(Float[_N]):
    __visit_name__: str

class DOUBLE(Double[_N]):
    __visit_name__: str

class DOUBLE_PRECISION(Double[_N]):
    __visit_name__: str

class NUMERIC(Numeric[_N]):
    __visit_name__: str

class DECIMAL(Numeric[_N]):
    __visit_name__: str

class INTEGER(Integer):
    __visit_name__: str
INT = INTEGER

class SMALLINT(SmallInteger):
    __visit_name__: str

class BIGINT(BigInteger):
    __visit_name__: str

class TIMESTAMP(DateTime):
    __visit_name__: str
    def __init__(self, timezone: bool = ...) -> None: ...
    def get_dbapi_type(self, dbapi): ...

class DATETIME(DateTime):
    __visit_name__: str

class DATE(Date):
    __visit_name__: str

class TIME(Time):
    __visit_name__: str

class TEXT(Text):
    __visit_name__: str

class CLOB(Text):
    __visit_name__: str

class VARCHAR(String):
    __visit_name__: str

class NVARCHAR(Unicode):
    __visit_name__: str

class CHAR(String):
    __visit_name__: str

class NCHAR(Unicode):
    __visit_name__: str

class BLOB(LargeBinary):
    __visit_name__: str

class BINARY(_Binary):
    __visit_name__: str

class VARBINARY(_Binary):
    __visit_name__: str

class BOOLEAN(Boolean):
    __visit_name__: str

class NullType(TypeEngine[None]):
    __visit_name__: str
    def literal_processor(self, dialect) -> None: ...
    class Comparator(TypeEngine.Comparator[_T]): ...
    comparator_factory = Comparator

class TableValueType(HasCacheKey, TypeEngine[Any]):
    def __init__(self, *elements: Union[str, _ColumnExpressionArgument[Any]]) -> None: ...

class MatchType(Boolean): ...

class Uuid(Emulated, TypeEngine[_UUID_RETURN]):
    __visit_name__: str
    collation: Optional[str]
    @overload
    def __init__(self, as_uuid: Literal[True] = ..., native_uuid: bool = ...) -> None: ...
    @overload
    def __init__(self, as_uuid: Literal[False] = ..., native_uuid: bool = ...) -> None: ...
    @property
    def python_type(self): ...
    @property
    def native(self): ...
    def coerce_compared_value(self, op, value): ...
    def bind_processor(self, dialect): ...
    def result_processor(self, dialect, coltype): ...
    def literal_processor(self, dialect): ...

class UUID(Uuid[_UUID_RETURN], type_api.NativeForEmulated):
    __visit_name__: str
    @overload
    def __init__(self, as_uuid: Literal[True] = ...) -> None: ...
    @overload
    def __init__(self, as_uuid: Literal[False] = ...) -> None: ...
    @classmethod
    def adapt_emulated_to_native(cls, impl, **kw): ...

NULLTYPE: Incomplete
BOOLEANTYPE: Incomplete
STRINGTYPE: Incomplete
INTEGERTYPE: Incomplete
NUMERICTYPE: Numeric[decimal.Decimal]
MATCHTYPE: Incomplete
TABLEVALUE: Incomplete
DATETIME_TIMEZONE: Incomplete
TIME_TIMEZONE: Incomplete
INDEXABLE = Indexable
