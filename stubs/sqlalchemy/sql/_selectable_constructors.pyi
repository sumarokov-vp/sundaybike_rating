from . import coercions as coercions, roles as roles
from ._typing import _ColumnsClauseArgument, _FromClauseArgument, _OnClauseArgument, _SelectStatementForCompoundArgument, _T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _TypedColumnClauseArgument as _TCCA
from .elements import ColumnClause as ColumnClause
from .functions import Function as Function
from .selectable import Alias as Alias, CTE as CTE, CompoundSelect as CompoundSelect, Exists as Exists, FromClause as FromClause, HasCTE as HasCTE, Join as Join, Lateral as Lateral, LateralFromClause as LateralFromClause, NamedFromClause as NamedFromClause, ScalarSelect as ScalarSelect, Select as Select, SelectBase as SelectBase, TableClause as TableClause, TableSample as TableSample, Values as Values
from typing import Any, Optional, Tuple, Union, overload

def alias(selectable: FromClause, name: Optional[str] = ..., flat: bool = ...) -> NamedFromClause: ...
def cte(selectable: HasCTE, name: Optional[str] = ..., recursive: bool = ...) -> CTE: ...
def except_(*selects: _SelectStatementForCompoundArgument) -> CompoundSelect: ...
def except_all(*selects: _SelectStatementForCompoundArgument) -> CompoundSelect: ...
def exists(__argument: Optional[Union[_ColumnsClauseArgument[Any], SelectBase, ScalarSelect[Any]]] = ...) -> Exists: ...
def intersect(*selects: _SelectStatementForCompoundArgument) -> CompoundSelect: ...
def intersect_all(*selects: _SelectStatementForCompoundArgument) -> CompoundSelect: ...
def join(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument] = ..., isouter: bool = ..., full: bool = ...) -> Join: ...
def lateral(selectable: Union[SelectBase, _FromClauseArgument], name: Optional[str] = ...) -> LateralFromClause: ...
def outerjoin(left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument] = ..., full: bool = ...) -> Join: ...
@overload
def select(__ent0: _TCCA[_T0]) -> Select[Tuple[_T0]]: ...
@overload
def select(__ent0: _TCCA[_T0], __ent1: _TCCA[_T1]) -> Select[Tuple[_T0, _T1]]: ...
@overload
def select(__ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2]) -> Select[Tuple[_T0, _T1, _T2]]: ...
@overload
def select(__ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3]) -> Select[Tuple[_T0, _T1, _T2, _T3]]: ...
@overload
def select(__ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4]) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4]]: ...
@overload
def select(__ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5]) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5]]: ...
@overload
def select(__ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5], __ent6: _TCCA[_T6]) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6]]: ...
@overload
def select(__ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5], __ent6: _TCCA[_T6], __ent7: _TCCA[_T7]) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7]]: ...
@overload
def select(__ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5], __ent6: _TCCA[_T6], __ent7: _TCCA[_T7], __ent8: _TCCA[_T8]) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8]]: ...
@overload
def select(__ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5], __ent6: _TCCA[_T6], __ent7: _TCCA[_T7], __ent8: _TCCA[_T8], __ent9: _TCCA[_T9]) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9]]: ...
@overload
def select(*entities: _ColumnsClauseArgument[Any], **__kw: Any) -> Select[Any]: ...
def table(name: str, *columns: ColumnClause[Any], **kw: Any) -> TableClause: ...
def tablesample(selectable: _FromClauseArgument, sampling: Union[float, Function[Any]], name: Optional[str] = ..., seed: Optional[roles.ExpressionElementRole[Any]] = ...) -> TableSample: ...
def union(*selects: _SelectStatementForCompoundArgument) -> CompoundSelect: ...
def union_all(*selects: _SelectStatementForCompoundArgument) -> CompoundSelect: ...
def values(*columns: ColumnClause[Any], name: Optional[str] = ..., literal_binds: bool = ...) -> Values: ...
