from . import cache_key as cache_key, coercions as coercions, operators as operators, roles as roles, traversals as traversals, type_api as type_api, visitors as visitors
from .. import exc as exc, util as util
from ..util import HasMemoized_ro_memoized_attribute as HasMemoized_ro_memoized_attribute
from ..util.typing import Literal as Literal, Protocol as Protocol, Self as Self
from ._typing import _ColumnExpressionArgument, _ColumnExpressionOrStrLabelArgument, _ColumnsClauseArgument, _FromClauseArgument, _JoinTargetArgument, _LimitOffsetType, _NOT_ENTITY, _OnClauseArgument, _SelectStatementForCompoundArgument, _T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _TP, _TextCoercedExpressionArgument, _TypedColumnClauseArgument as _TCCA, is_column_element as is_column_element, is_select_statement as is_select_statement, is_subquery as is_subquery, is_table as is_table, is_text_clause as is_text_clause
from .annotation import Annotated as Annotated, SupportsCloneAnnotations as SupportsCloneAnnotations
from .base import CacheableOptions as CacheableOptions, ColumnCollection as ColumnCollection, ColumnSet as ColumnSet, CompileState as CompileState, DedupeColumnCollection as DedupeColumnCollection, Executable as Executable, ExecutableOption as ExecutableOption, Generative as Generative, HasCompileState as HasCompileState, HasMemoized as HasMemoized, Immutable as Immutable, ReadOnlyColumnCollection as ReadOnlyColumnCollection, _EntityNamespace, _NoArg
from .compiler import SQLCompiler as SQLCompiler
from .dml import Delete as Delete, Update as Update
from .elements import BinaryExpression as BinaryExpression, BindParameter as BindParameter, BooleanClauseList as BooleanClauseList, ClauseElement as ClauseElement, ClauseList as ClauseList, ColumnClause as ColumnClause, ColumnElement as ColumnElement, DQLDMLClauseElement as DQLDMLClauseElement, GroupedElement as GroupedElement, KeyedColumnElement as KeyedColumnElement, Label as Label, NamedColumn as NamedColumn, TableValuedColumn as TableValuedColumn, TextClause as TextClause, UnaryExpression as UnaryExpression, literal_column as literal_column
from .functions import Function as Function
from .operators import OperatorType as OperatorType
from .schema import ForeignKey as ForeignKey, ForeignKeyConstraint as ForeignKeyConstraint
from .sqltypes import NULLTYPE as NULLTYPE, TableValueType as TableValueType
from .type_api import TypeEngine as TypeEngine
from .visitors import InternalTraversal as InternalTraversal, prefix_anon_map as prefix_anon_map
from _typeshed import Incomplete
from enum import Enum
from typing import Any, Dict, Generic, Iterable, List, NamedTuple, NoReturn, Optional, Sequence, Tuple, Type, Union, overload

and_: Incomplete

class _JoinTargetProtocol(Protocol):
    def entity_namespace(self) -> _EntityNamespace: ...

class _OffsetLimitParam(BindParameter[int]):
    inherit_cache: bool

class ReturnsRows(roles.ReturnsRowsRole, DQLDMLClauseElement):
    @property
    def selectable(self) -> ReturnsRows: ...
    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool: ...
    @property
    def exported_columns(self) -> ReadOnlyColumnCollection[Any, Any]: ...

class ExecutableReturnsRows(Executable, ReturnsRows): ...
class TypedReturnsRows(ExecutableReturnsRows, Generic[_TP]): ...

class Selectable(ReturnsRows):
    __visit_name__: str
    is_selectable: bool
    def lateral(self, name: Optional[str] = ...) -> LateralFromClause: ...
    def replace_selectable(self, old: FromClause, alias: Alias) -> Self: ...
    def corresponding_column(self, column: KeyedColumnElement[Any], require_embedded: bool = ...) -> Optional[KeyedColumnElement[Any]]: ...

class HasPrefixes:
    def prefix_with(self, *prefixes: _TextCoercedExpressionArgument[Any], dialect: str = ...) -> Self: ...

class HasSuffixes:
    def suffix_with(self, *suffixes: _TextCoercedExpressionArgument[Any], dialect: str = ...) -> Self: ...

class HasHints:
    def with_statement_hint(self, text: str, dialect_name: str = ...) -> Self: ...
    def with_hint(self, selectable: _FromClauseArgument, text: str, dialect_name: str = ...) -> Self: ...

class FromClause(roles.AnonymizedFromClauseRole, Selectable):
    __visit_name__: str
    named_with_column: bool
    schema: Optional[str]
    is_selectable: bool
    def select(self) -> Select[Any]: ...
    def join(self, right: _FromClauseArgument, onclause: Optional[_ColumnExpressionArgument[bool]] = ..., isouter: bool = ..., full: bool = ...) -> Join: ...
    def outerjoin(self, right: _FromClauseArgument, onclause: Optional[_ColumnExpressionArgument[bool]] = ..., full: bool = ...) -> Join: ...
    def alias(self, name: Optional[str] = ..., flat: bool = ...) -> NamedFromClause: ...
    def tablesample(self, sampling: Union[float, Function[Any]], name: Optional[str] = ..., seed: Optional[roles.ExpressionElementRole[Any]] = ...) -> TableSample: ...
    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool: ...
    def description(self) -> str: ...
    def exported_columns(self) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]: ...
    def columns(self) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]: ...
    def c(self) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]: ...
    def entity_namespace(self) -> _EntityNamespace: ...
    def primary_key(self) -> Iterable[NamedColumn[Any]]: ...
    def foreign_keys(self) -> Iterable[ForeignKey]: ...
    def self_group(self, against: Optional[OperatorType] = ...) -> Union[FromGrouping, Self]: ...

class NamedFromClause(FromClause):
    named_with_column: bool
    name: str
    def table_valued(self) -> TableValuedColumn[Any]: ...

class SelectLabelStyle(Enum):
    LABEL_STYLE_NONE: int
    LABEL_STYLE_TABLENAME_PLUS_COL: int
    LABEL_STYLE_DISAMBIGUATE_ONLY: int
    LABEL_STYLE_DEFAULT = LABEL_STYLE_DISAMBIGUATE_ONLY
    LABEL_STYLE_LEGACY_ORM: int

LABEL_STYLE_NONE: Incomplete
LABEL_STYLE_TABLENAME_PLUS_COL: Incomplete
LABEL_STYLE_DISAMBIGUATE_ONLY: Incomplete
_: Incomplete
LABEL_STYLE_DEFAULT = LABEL_STYLE_DISAMBIGUATE_ONLY

class Join(roles.DMLTableRole, FromClause):
    __visit_name__: str
    left: FromClause
    right: FromClause
    onclause: Optional[ColumnElement[bool]]
    isouter: bool
    full: bool
    def __init__(self, left: _FromClauseArgument, right: _FromClauseArgument, onclause: Optional[_OnClauseArgument] = ..., isouter: bool = ..., full: bool = ...) -> None: ...
    def description(self) -> str: ...
    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool: ...
    def self_group(self, against: Optional[OperatorType] = ...) -> FromGrouping: ...
    def select(self) -> Select[Any]: ...

class NoInit:
    def __init__(self, *arg: Any, **kw: Any) -> None: ...

class LateralFromClause(NamedFromClause): ...

class AliasedReturnsRows(NoInit, NamedFromClause):
    element: ReturnsRows
    def description(self) -> str: ...
    def implicit_returning(self) -> bool: ...
    @property
    def original(self) -> ReturnsRows: ...
    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool: ...

class FromClauseAlias(AliasedReturnsRows):
    element: FromClause

class Alias(roles.DMLTableRole, FromClauseAlias):
    __visit_name__: str
    inherit_cache: bool
    element: FromClause

class TableValuedAlias(LateralFromClause, Alias):
    __visit_name__: str
    joins_implicitly: bool
    def column(self) -> TableValuedColumn[Any]: ...
    def alias(self, name: Optional[str] = ..., flat: bool = ...) -> TableValuedAlias: ...
    def lateral(self, name: Optional[str] = ...) -> LateralFromClause: ...
    def render_derived(self, name: Optional[str] = ..., with_types: bool = ...) -> TableValuedAlias: ...

class Lateral(FromClauseAlias, LateralFromClause):
    __visit_name__: str
    inherit_cache: bool

class TableSample(FromClauseAlias):
    __visit_name__: str

class CTE(roles.DMLTableRole, roles.IsCTERole, Generative, HasPrefixes, HasSuffixes, AliasedReturnsRows):
    __visit_name__: str
    element: HasCTE
    def alias(self, name: Optional[str] = ..., flat: bool = ...) -> CTE: ...
    def union(self, *other: _SelectStatementForCompoundArgument) -> CTE: ...
    def union_all(self, *other: _SelectStatementForCompoundArgument) -> CTE: ...

class _CTEOpts(NamedTuple):
    nesting: bool

class _ColumnsPlusNames(NamedTuple):
    required_label_name: Optional[str]
    proxy_key: Optional[str]
    fallback_label_name: Optional[str]
    column: Union[ColumnElement[Any], TextClause]
    repeated: bool

class SelectsRows(ReturnsRows): ...

class HasCTE(roles.HasCTERole, SelectsRows):
    def add_cte(self, *ctes: CTE, nest_here: bool = ...) -> Self: ...
    def cte(self, name: Optional[str] = ..., recursive: bool = ..., nesting: bool = ...) -> CTE: ...

class Subquery(AliasedReturnsRows):
    __visit_name__: str
    inherit_cache: bool
    element: SelectBase
    def as_scalar(self) -> ScalarSelect[Any]: ...

class FromGrouping(GroupedElement, FromClause):
    element: FromClause
    def __init__(self, element: FromClause) -> None: ...
    def columns(self) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]: ...
    def c(self) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]: ...
    @property
    def primary_key(self) -> Iterable[NamedColumn[Any]]: ...
    @property
    def foreign_keys(self) -> Iterable[ForeignKey]: ...
    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool: ...
    def alias(self, name: Optional[str] = ..., flat: bool = ...) -> NamedFromGrouping: ...

class NamedFromGrouping(FromGrouping, NamedFromClause):
    inherit_cache: bool

class TableClause(roles.DMLTableRole, Immutable, NamedFromClause):
    __visit_name__: str
    fullname: str
    implicit_returning: bool
    name: Incomplete
    primary_key: Incomplete
    foreign_keys: Incomplete
    schema: Incomplete
    def __init__(self, name: str, *columns: ColumnClause[Any], **kw: Any) -> None: ...
    def columns(self) -> ReadOnlyColumnCollection[str, ColumnClause[Any]]: ...
    def c(self) -> ReadOnlyColumnCollection[str, ColumnClause[Any]]: ...
    def description(self) -> str: ...
    def append_column(self, c: ColumnClause[Any]) -> None: ...
    def insert(self) -> util.preloaded.sql_dml.Insert: ...
    def update(self) -> Update: ...
    def delete(self) -> Delete: ...

ForUpdateParameter: Incomplete

class ForUpdateArg(ClauseElement):
    of: Optional[Sequence[ClauseElement]]
    nowait: bool
    read: bool
    skip_locked: bool
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    key_share: Incomplete
    def __init__(self, *, nowait: bool = ..., read: bool = ..., of: Optional[_ForUpdateOfArgument] = ..., skip_locked: bool = ..., key_share: bool = ...) -> None: ...

class Values(roles.InElementRole, Generative, LateralFromClause):
    __visit_name__: str
    name: Incomplete
    literal_binds: Incomplete
    named_with_column: Incomplete
    def __init__(self, *columns: ColumnClause[Any], name: Optional[str] = ..., literal_binds: bool = ...) -> None: ...
    def alias(self, name: Optional[str] = ..., flat: bool = ...) -> Self: ...
    def lateral(self, name: Optional[str] = ...) -> LateralFromClause: ...
    def data(self, values: Sequence[Tuple[Any, ...]]) -> Self: ...
    def scalar_values(self) -> ScalarValues: ...

class ScalarValues(roles.InElementRole, GroupedElement, ColumnElement[Any]):
    __visit_name__: str
    literal_binds: Incomplete
    def __init__(self, columns: Sequence[ColumnClause[Any]], data: Tuple[Sequence[Tuple[Any, ...]], ...], literal_binds: bool) -> None: ...
    def __clause_element__(self) -> ScalarValues: ...

class SelectBase(roles.SelectStatementRole, roles.DMLSelectRole, roles.CompoundElementRole, roles.InElementRole, HasCTE, SupportsCloneAnnotations, Selectable):
    is_select: bool
    def selected_columns(self) -> ColumnCollection[str, ColumnElement[Any]]: ...
    @property
    def exported_columns(self) -> ReadOnlyColumnCollection[str, ColumnElement[Any]]: ...
    @property
    def c(self) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]: ...
    @property
    def columns(self) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]: ...
    def get_label_style(self) -> SelectLabelStyle: ...
    def set_label_style(self, style: SelectLabelStyle) -> Self: ...
    def select(self, *arg: Any, **kw: Any) -> Select[Any]: ...
    def as_scalar(self) -> ScalarSelect[Any]: ...
    def exists(self) -> Exists: ...
    def scalar_subquery(self) -> ScalarSelect[Any]: ...
    def label(self, name: Optional[str]) -> Label[Any]: ...
    def lateral(self, name: Optional[str] = ...) -> LateralFromClause: ...
    def subquery(self, name: Optional[str] = ...) -> Subquery: ...
    def alias(self, name: Optional[str] = ..., flat: bool = ...) -> Subquery: ...

class SelectStatementGrouping(GroupedElement, SelectBase, Generic[_SB]):
    __visit_name__: str
    element: _SB
    def __init__(self, element: _SB) -> None: ...
    def get_label_style(self) -> SelectLabelStyle: ...
    def set_label_style(self, label_style: SelectLabelStyle) -> SelectStatementGrouping[_SB]: ...
    @property
    def select_statement(self) -> _SB: ...
    def self_group(self, against: Optional[OperatorType] = ...) -> Self: ...
    def selected_columns(self) -> ColumnCollection[str, ColumnElement[Any]]: ...

class GenerativeSelect(SelectBase, Generative):
    def __init__(self, _label_style: SelectLabelStyle = ...) -> None: ...
    def with_for_update(self, *, nowait: bool = ..., read: bool = ..., of: Optional[_ForUpdateOfArgument] = ..., skip_locked: bool = ..., key_share: bool = ...) -> Self: ...
    def get_label_style(self) -> SelectLabelStyle: ...
    def set_label_style(self, style: SelectLabelStyle) -> Self: ...
    def limit(self, limit: _LimitOffsetType) -> Self: ...
    def fetch(self, count: _LimitOffsetType, with_ties: bool = ..., percent: bool = ...) -> Self: ...
    def offset(self, offset: _LimitOffsetType) -> Self: ...
    def slice(self, start: int, stop: int) -> Self: ...
    def order_by(self, __first: Union[Literal[None, _NoArg.NO_ARG], _ColumnExpressionOrStrLabelArgument[Any]] = ..., *clauses: _ColumnExpressionOrStrLabelArgument[Any]) -> Self: ...
    def group_by(self, __first: Union[Literal[None, _NoArg.NO_ARG], _ColumnExpressionOrStrLabelArgument[Any]] = ..., *clauses: _ColumnExpressionOrStrLabelArgument[Any]) -> Self: ...

class CompoundSelectState(CompileState): ...

class _CompoundSelectKeyword(Enum):
    UNION: str
    UNION_ALL: str
    EXCEPT: str
    EXCEPT_ALL: str
    INTERSECT: str
    INTERSECT_ALL: str

class CompoundSelect(HasCompileState, GenerativeSelect, ExecutableReturnsRows):
    __visit_name__: str
    selects: List[SelectBase]
    keyword: Incomplete
    def __init__(self, keyword: _CompoundSelectKeyword, *selects: _SelectStatementForCompoundArgument) -> None: ...
    def self_group(self, against: Optional[OperatorType] = ...) -> GroupedElement: ...
    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool: ...
    def set_label_style(self, style: SelectLabelStyle) -> CompoundSelect: ...
    def selected_columns(self) -> ColumnCollection[str, ColumnElement[Any]]: ...

class SelectState(util.MemoizedSlots, CompileState):
    default_select_compile_options: CacheableOptions
    @classmethod
    def get_plugin_class(cls, statement: Executable) -> Type[SelectState]: ...
    statement: Incomplete
    from_clauses: Incomplete
    froms: Incomplete
    columns_plus_names: Incomplete
    def __init__(self, statement: Select[Any], compiler: Optional[SQLCompiler], **kw: Any) -> None: ...
    @classmethod
    def get_column_descriptions(cls, statement: Select[Any]) -> List[Dict[str, Any]]: ...
    @classmethod
    def from_statement(cls, statement: Select[Any], from_statement: roles.ReturnsRowsRole) -> ExecutableReturnsRows: ...
    @classmethod
    def get_columns_clause_froms(cls, statement: Select[Any]) -> List[FromClause]: ...
    @classmethod
    def determine_last_joined_entity(cls, stmt: Select[Any]) -> Optional[_JoinTargetElement]: ...
    @classmethod
    def all_selected_columns(cls, statement: Select[Any]) -> _SelectIterable: ...

class _SelectFromElements: ...

class _MemoizedSelectEntities(cache_key.HasCacheKey, traversals.HasCopyInternals, visitors.Traversible):
    __visit_name__: str

class Select(HasPrefixes, HasSuffixes, HasHints, HasCompileState, _SelectFromElements, GenerativeSelect, TypedReturnsRows[_TP]):
    __visit_name__: str
    def __init__(self, *entities: _ColumnsClauseArgument[Any]) -> None: ...
    def filter(self, *criteria: _ColumnExpressionArgument[bool]) -> Self: ...
    @overload
    def scalar_subquery(self) -> ScalarSelect[Any]: ...
    @overload
    def scalar_subquery(self) -> ScalarSelect[_NOT_ENTITY]: ...
    @overload
    def scalar_subquery(self) -> ScalarSelect[Any]: ...
    def filter_by(self, **kwargs: Any) -> Self: ...
    @property
    def column_descriptions(self) -> Any: ...
    def from_statement(self, statement: roles.ReturnsRowsRole) -> ExecutableReturnsRows: ...
    def join(self, target: _JoinTargetArgument, onclause: Optional[_OnClauseArgument] = ..., *, isouter: bool = ..., full: bool = ...) -> Self: ...
    def outerjoin_from(self, from_: _FromClauseArgument, target: _JoinTargetArgument, onclause: Optional[_OnClauseArgument] = ..., *, full: bool = ...) -> Self: ...
    def join_from(self, from_: _FromClauseArgument, target: _JoinTargetArgument, onclause: Optional[_OnClauseArgument] = ..., *, isouter: bool = ..., full: bool = ...) -> Self: ...
    def outerjoin(self, target: _JoinTargetArgument, onclause: Optional[_OnClauseArgument] = ..., *, full: bool = ...) -> Self: ...
    def get_final_froms(self) -> Sequence[FromClause]: ...
    @property
    def froms(self) -> Sequence[FromClause]: ...
    @property
    def columns_clause_froms(self) -> List[FromClause]: ...
    @property
    def inner_columns(self) -> _SelectIterable: ...
    def is_derived_from(self, fromclause: Optional[FromClause]) -> bool: ...
    def get_children(self, **kw: Any) -> Iterable[ClauseElement]: ...
    def add_columns(self, *entities: _ColumnsClauseArgument[Any]) -> Select[Any]: ...
    def column(self, column: _ColumnsClauseArgument[Any]) -> Select[Any]: ...
    def reduce_columns(self, only_synonyms: bool = ...) -> Select[Any]: ...
    @overload
    def with_only_columns(self, __ent0: _TCCA[_T0]) -> Select[Tuple[_T0]]: ...
    @overload
    def with_only_columns(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1]) -> Select[Tuple[_T0, _T1]]: ...
    @overload
    def with_only_columns(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2]) -> Select[Tuple[_T0, _T1, _T2]]: ...
    @overload
    def with_only_columns(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3]) -> Select[Tuple[_T0, _T1, _T2, _T3]]: ...
    @overload
    def with_only_columns(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4]) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4]]: ...
    @overload
    def with_only_columns(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5]) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5]]: ...
    @overload
    def with_only_columns(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5], __ent6: _TCCA[_T6]) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6]]: ...
    @overload
    def with_only_columns(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5], __ent6: _TCCA[_T6], __ent7: _TCCA[_T7]) -> Select[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7]]: ...
    @overload
    def with_only_columns(self, *entities: _ColumnsClauseArgument[Any], maintain_column_froms: bool = ..., **__kw: Any) -> Select[Any]: ...
    @property
    def whereclause(self) -> Optional[ColumnElement[Any]]: ...
    def where(self, *whereclause: _ColumnExpressionArgument[bool]) -> Self: ...
    def having(self, *having: _ColumnExpressionArgument[bool]) -> Self: ...
    def distinct(self, *expr: _ColumnExpressionArgument[Any]) -> Self: ...
    def select_from(self, *froms: _FromClauseArgument) -> Self: ...
    def correlate(self, *fromclauses: Union[Literal[None, False], _FromClauseArgument]) -> Self: ...
    def correlate_except(self, *fromclauses: Union[Literal[None, False], _FromClauseArgument]) -> Self: ...
    def selected_columns(self) -> ColumnCollection[str, ColumnElement[Any]]: ...
    def self_group(self, against: Optional[OperatorType] = ...) -> Union[SelectStatementGrouping[Self], Self]: ...
    def union(self, *other: _SelectStatementForCompoundArgument) -> CompoundSelect: ...
    def union_all(self, *other: _SelectStatementForCompoundArgument) -> CompoundSelect: ...
    def except_(self, *other: _SelectStatementForCompoundArgument) -> CompoundSelect: ...
    def except_all(self, *other: _SelectStatementForCompoundArgument) -> CompoundSelect: ...
    def intersect(self, *other: _SelectStatementForCompoundArgument) -> CompoundSelect: ...
    def intersect_all(self, *other: _SelectStatementForCompoundArgument) -> CompoundSelect: ...

class ScalarSelect(roles.InElementRole, Generative, GroupedElement, ColumnElement[_T]):
    inherit_cache: bool
    element: SelectBase
    type: Incomplete
    def __init__(self, element: SelectBase) -> None: ...
    def __getattr__(self, attr: str) -> Any: ...
    @property
    def columns(self) -> NoReturn: ...
    c = columns
    def where(self, crit: _ColumnExpressionArgument[bool]) -> Self: ...
    @overload
    def self_group(self, against: Optional[OperatorType] = ...) -> ScalarSelect[Any]: ...
    @overload
    def self_group(self, against: Optional[OperatorType] = ...) -> ColumnElement[Any]: ...
    def correlate(self, *fromclauses: Union[Literal[None, False], _FromClauseArgument]) -> Self: ...
    def correlate_except(self, *fromclauses: Union[Literal[None, False], _FromClauseArgument]) -> Self: ...

class Exists(UnaryExpression[bool]):
    inherit_cache: bool
    element: Union[SelectStatementGrouping[Select[Any]], ScalarSelect[Any]]
    def __init__(self, __argument: Optional[Union[_ColumnsClauseArgument[Any], SelectBase, ScalarSelect[Any]]] = ...) -> None: ...
    def select(self) -> Select[Any]: ...
    def correlate(self, *fromclauses: Union[Literal[None, False], _FromClauseArgument]) -> Self: ...
    def correlate_except(self, *fromclauses: Union[Literal[None, False], _FromClauseArgument]) -> Self: ...
    def select_from(self, *froms: _FromClauseArgument) -> Self: ...
    def where(self, *clause: _ColumnExpressionArgument[bool]) -> Self: ...

class TextualSelect(SelectBase, ExecutableReturnsRows, Generative):
    __visit_name__: str
    is_text: bool
    is_select: bool
    def __init__(self, text: TextClause, columns: List[_ColumnExpressionArgument[Any]], positional: bool = ...) -> None: ...
    def selected_columns(self) -> ColumnCollection[str, KeyedColumnElement[Any]]: ...
    def set_label_style(self, style: SelectLabelStyle) -> TextualSelect: ...
    element: Incomplete
    def bindparams(self, *binds: BindParameter[Any], **bind_as_values: Any) -> Self: ...
TextAsFrom = TextualSelect

class AnnotatedFromClause(Annotated):
    def c(self) -> ReadOnlyColumnCollection[str, KeyedColumnElement[Any]]: ...
