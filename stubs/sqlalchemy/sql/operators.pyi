from .. import exc as exc, util as util
from ..util.typing import Literal as Literal, Protocol as Protocol
from ._typing import ColumnExpressionArgument as ColumnExpressionArgument
from .cache_key import CacheConst as CacheConst
from .elements import ColumnElement as ColumnElement
from .type_api import TypeEngine as TypeEngine
from _typeshed import Incomplete
from enum import IntEnum
from typing import Any, Callable, Generic, Optional, Type, Union, overload

class OperatorType(Protocol):
    @overload
    def __call__(self, left: ColumnExpressionArgument[Any], right: Optional[Any] = ..., *other: Any, **kwargs: Any) -> ColumnElement[Any]: ...
    @overload
    def __call__(self, left: Operators, right: Optional[Any] = ..., *other: Any, **kwargs: Any) -> Operators: ...

add: Incomplete
and_: Incomplete
contains: Incomplete
eq: Incomplete
floordiv: Incomplete
ge: Incomplete
getitem: Incomplete
gt: Incomplete
inv: Incomplete
le: Incomplete
lshift: Incomplete
lt: Incomplete
mod: Incomplete
mul: Incomplete
ne: Incomplete
neg: Incomplete
or_: Incomplete
rshift: Incomplete
sub: Incomplete
truediv: Incomplete

class Operators:
    def __and__(self, other: Any) -> Operators: ...
    def __or__(self, other: Any) -> Operators: ...
    def __invert__(self) -> Operators: ...
    def op(self, opstring: str, precedence: int = ..., is_comparison: bool = ..., return_type: Optional[Union[Type[TypeEngine[Any]], TypeEngine[Any]]] = ..., python_impl: Optional[Callable[..., Any]] = ...) -> Callable[[Any], Operators]: ...
    def bool_op(self, opstring: str, precedence: int = ..., python_impl: Optional[Callable[..., Any]] = ...) -> Callable[[Any], Operators]: ...
    def operate(self, op: OperatorType, *other: Any, **kwargs: Any) -> Operators: ...
    __sa_operate__ = operate
    def reverse_operate(self, op: OperatorType, other: Any, **kwargs: Any) -> Operators: ...

class custom_op(OperatorType, Generic[_T]):
    opstring: Incomplete
    precedence: Incomplete
    is_comparison: Incomplete
    natural_self_precedent: Incomplete
    eager_grouping: Incomplete
    return_type: Incomplete
    python_impl: Incomplete
    def __init__(self, opstring: str, precedence: int = ..., is_comparison: bool = ..., return_type: Optional[Union[Type[TypeEngine[_T]], TypeEngine[_T]]] = ..., natural_self_precedent: bool = ..., eager_grouping: bool = ..., python_impl: Optional[Callable[..., Any]] = ...) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    @overload
    def __call__(self, left: ColumnExpressionArgument[Any], right: Optional[Any] = ..., *other: Any, **kwargs: Any) -> ColumnElement[Any]: ...
    @overload
    def __call__(self, left: Operators, right: Optional[Any] = ..., *other: Any, **kwargs: Any) -> Operators: ...

class ColumnOperators(Operators):
    timetuple: Literal[None]
    def operate(self, op: OperatorType, *other: Any, **kwargs: Any) -> ColumnOperators: ...
    def reverse_operate(self, op: OperatorType, other: Any, **kwargs: Any) -> ColumnOperators: ...
    def __lt__(self, other: Any) -> ColumnOperators: ...
    def __le__(self, other: Any) -> ColumnOperators: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> ColumnOperators: ...
    def __ne__(self, other: Any) -> ColumnOperators: ...
    def is_distinct_from(self, other: Any) -> ColumnOperators: ...
    def is_not_distinct_from(self, other: Any) -> ColumnOperators: ...
    def isnot_distinct_from(self, other: Any) -> ColumnOperators: ...
    def __gt__(self, other: Any) -> ColumnOperators: ...
    def __ge__(self, other: Any) -> ColumnOperators: ...
    def __neg__(self) -> ColumnOperators: ...
    def __contains__(self, other: Any) -> ColumnOperators: ...
    def __getitem__(self, index: Any) -> ColumnOperators: ...
    def __lshift__(self, other: Any) -> ColumnOperators: ...
    def __rshift__(self, other: Any) -> ColumnOperators: ...
    def concat(self, other: Any) -> ColumnOperators: ...
    def like(self, other: Any, escape: Optional[str] = ...) -> ColumnOperators: ...
    def ilike(self, other: Any, escape: Optional[str] = ...) -> ColumnOperators: ...
    def bitwise_xor(self, other: Any) -> ColumnOperators: ...
    def bitwise_or(self, other: Any) -> ColumnOperators: ...
    def bitwise_and(self, other: Any) -> ColumnOperators: ...
    def bitwise_not(self) -> ColumnOperators: ...
    def bitwise_lshift(self, other: Any) -> ColumnOperators: ...
    def bitwise_rshift(self, other: Any) -> ColumnOperators: ...
    def in_(self, other: Any) -> ColumnOperators: ...
    def not_in(self, other: Any) -> ColumnOperators: ...
    def notin_(self, other: Any) -> ColumnOperators: ...
    def not_like(self, other: Any, escape: Optional[str] = ...) -> ColumnOperators: ...
    def notlike(self, other: Any, escape: Optional[str] = ...) -> ColumnOperators: ...
    def not_ilike(self, other: Any, escape: Optional[str] = ...) -> ColumnOperators: ...
    def notilike(self, other: Any, escape: Optional[str] = ...) -> ColumnOperators: ...
    def is_(self, other: Any) -> ColumnOperators: ...
    def is_not(self, other: Any) -> ColumnOperators: ...
    def isnot(self, other: Any) -> ColumnOperators: ...
    def startswith(self, other: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> ColumnOperators: ...
    def istartswith(self, other: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> ColumnOperators: ...
    def endswith(self, other: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> ColumnOperators: ...
    def iendswith(self, other: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> ColumnOperators: ...
    def contains(self, other: Any, **kw: Any) -> ColumnOperators: ...
    def icontains(self, other: Any, **kw: Any) -> ColumnOperators: ...
    def match(self, other: Any, **kwargs: Any) -> ColumnOperators: ...
    def regexp_match(self, pattern: Any, flags: Optional[str] = ...) -> ColumnOperators: ...
    def regexp_replace(self, pattern: Any, replacement: Any, flags: Optional[str] = ...) -> ColumnOperators: ...
    def desc(self) -> ColumnOperators: ...
    def asc(self) -> ColumnOperators: ...
    def nulls_first(self) -> ColumnOperators: ...
    def nullsfirst(self) -> ColumnOperators: ...
    def nulls_last(self) -> ColumnOperators: ...
    def nullslast(self) -> ColumnOperators: ...
    def collate(self, collation: str) -> ColumnOperators: ...
    def __radd__(self, other: Any) -> ColumnOperators: ...
    def __rsub__(self, other: Any) -> ColumnOperators: ...
    def __rmul__(self, other: Any) -> ColumnOperators: ...
    def __rmod__(self, other: Any) -> ColumnOperators: ...
    def between(self, cleft: Any, cright: Any, symmetric: bool = ...) -> ColumnOperators: ...
    def distinct(self) -> ColumnOperators: ...
    def any_(self) -> ColumnOperators: ...
    def all_(self) -> ColumnOperators: ...
    def __add__(self, other: Any) -> ColumnOperators: ...
    def __sub__(self, other: Any) -> ColumnOperators: ...
    def __mul__(self, other: Any) -> ColumnOperators: ...
    def __mod__(self, other: Any) -> ColumnOperators: ...
    def __truediv__(self, other: Any) -> ColumnOperators: ...
    def __rtruediv__(self, other: Any) -> ColumnOperators: ...
    def __floordiv__(self, other: Any) -> ColumnOperators: ...
    def __rfloordiv__(self, other: Any) -> ColumnOperators: ...

def commutative_op(fn: _FN) -> _FN: ...
def comparison_op(fn: _FN) -> _FN: ...
def from_() -> Any: ...
def function_as_comparison_op() -> Any: ...
def as_() -> Any: ...
def exists() -> Any: ...
def is_true(a: Any) -> Any: ...
def istrue(a: Any) -> Any: ...
def is_false(a: Any) -> Any: ...
def isfalse(a: Any) -> Any: ...
def is_distinct_from(a: Any, b: Any) -> Any: ...
def is_not_distinct_from(a: Any, b: Any) -> Any: ...
def isnot_distinct_from(a: Any, b: Any) -> Any: ...
def is_(a: Any, b: Any) -> Any: ...
def is_not(a: Any, b: Any) -> Any: ...
def isnot(a: Any, b: Any) -> Any: ...
def collate(a: Any, b: Any) -> Any: ...
def op(a: Any, opstring: str, b: Any) -> Any: ...
def like_op(a: Any, b: Any, escape: Optional[str] = ...) -> Any: ...
def not_like_op(a: Any, b: Any, escape: Optional[str] = ...) -> Any: ...
def notlike_op(a: Any, b: Any, escape: Optional[str] = ...) -> Any: ...
def ilike_op(a: Any, b: Any, escape: Optional[str] = ...) -> Any: ...
def not_ilike_op(a: Any, b: Any, escape: Optional[str] = ...) -> Any: ...
def notilike_op(a: Any, b: Any, escape: Optional[str] = ...) -> Any: ...
def between_op(a: Any, b: Any, c: Any, symmetric: bool = ...) -> Any: ...
def not_between_op(a: Any, b: Any, c: Any, symmetric: bool = ...) -> Any: ...
def notbetween_op(a: Any, b: Any, c: Any, symmetric: bool = ...) -> Any: ...
def in_op(a: Any, b: Any) -> Any: ...
def not_in_op(a: Any, b: Any) -> Any: ...
def notin_op(a: Any, b: Any) -> Any: ...
def distinct_op(a: Any) -> Any: ...
def any_op(a: Any) -> Any: ...
def all_op(a: Any) -> Any: ...
def startswith_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def not_startswith_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def notstartswith_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def istartswith_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def not_istartswith_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def endswith_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def not_endswith_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def notendswith_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def iendswith_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def not_iendswith_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def contains_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def not_contains_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def notcontains_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def icontains_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def not_icontains_op(a: Any, b: Any, escape: Optional[str] = ..., autoescape: bool = ...) -> Any: ...
def match_op(a: Any, b: Any, **kw: Any) -> Any: ...
def regexp_match_op(a: Any, b: Any, flags: Optional[str] = ...) -> Any: ...
def not_regexp_match_op(a: Any, b: Any, flags: Optional[str] = ...) -> Any: ...
def regexp_replace_op(a: Any, b: Any, replacement: Any, flags: Optional[str] = ...) -> Any: ...
def not_match_op(a: Any, b: Any, **kw: Any) -> Any: ...
def notmatch_op(a: Any, b: Any, **kw: Any) -> Any: ...
def comma_op(a: Any, b: Any) -> Any: ...
def filter_op(a: Any, b: Any) -> Any: ...
def concat_op(a: Any, b: Any) -> Any: ...
def desc_op(a: Any) -> Any: ...
def asc_op(a: Any) -> Any: ...
def nulls_first_op(a: Any) -> Any: ...
def nullsfirst_op(a: Any) -> Any: ...
def nulls_last_op(a: Any) -> Any: ...
def nullslast_op(a: Any) -> Any: ...
def json_getitem_op(a: Any, b: Any) -> Any: ...
def json_path_getitem_op(a: Any, b: Any) -> Any: ...
def bitwise_xor_op(a: Any, b: Any) -> Any: ...
def bitwise_or_op(a: Any, b: Any) -> Any: ...
def bitwise_and_op(a: Any, b: Any) -> Any: ...
def bitwise_not_op(a: Any) -> Any: ...
def bitwise_lshift_op(a: Any, b: Any) -> Any: ...
def bitwise_rshift_op(a: Any, b: Any) -> Any: ...
def is_comparison(op: OperatorType) -> bool: ...
def is_commutative(op: OperatorType) -> bool: ...
def is_ordering_modifier(op: OperatorType) -> bool: ...
def is_natural_self_precedent(op: OperatorType) -> bool: ...
def is_boolean(op: OperatorType) -> bool: ...
def mirror(op: OperatorType) -> OperatorType: ...
def is_associative(op: OperatorType) -> bool: ...

class _OpLimit(IntEnum): ...

def is_precedent(operator: OperatorType, against: OperatorType) -> bool: ...
