from . import attributes, interfaces
from .. import log
from ..engine import Row
from ..engine.cursor import CursorResult
from ..engine.interfaces import CompiledCacheType, IsolationLevel, SchemaTranslateMapType, _ImmutableExecuteOptions
from ..engine.result import FrozenResult
from ..event import EventTarget, dispatcher
from ..sql import Select, roles
from ..sql._typing import _ColumnExpressionArgument, _ColumnExpressionOrStrLabelArgument, _ColumnsClauseArgument, _DMLColumnArgument, _FromClauseArgument, _JoinTargetArgument, _LimitOffsetType, _MAYBE_ENTITY, _NOT_ENTITY, _OnClauseArgument, _T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _TP, _TypedColumnClauseArgument as _TCCA
from ..sql.annotation import SupportsCloneAnnotations
from ..sql.base import Executable, ExecutableOption, Generative, _NoArg
from ..sql.elements import ColumnElement, Label
from ..sql.expression import Exists
from ..sql.selectable import Alias, CTE, ExecutableReturnsRows, HasHints, HasPrefixes, HasSuffixes, ScalarSelect, SelectLabelStyle, Subquery, _ForUpdateOfArgument, _SelectFromElements
from ..util.typing import Literal, Self
from ._typing import SynchronizeSessionArgument, _EntityType, _ExternalEntityType, _O
from .context import FromStatement, ORMCompileState, QueryContext as QueryContext
from .interfaces import ORMColumnDescription
from .session import Session, _PKIdentityArgument
from .state import InstanceState
from _typeshed import Incomplete
from typing import Any, Callable, Dict, Generic, Iterable, Iterator, List, Optional, Sequence, Tuple, Union, overload

class Query(_SelectFromElements, SupportsCloneAnnotations, HasPrefixes, HasSuffixes, HasHints, EventTarget, log.Identified, Generative, Executable, Generic[_T]):
    load_options: Incomplete
    session: Session
    dispatch: dispatcher[Query[_T]]
    def __init__(self, entities: Union[_ColumnsClauseArgument[Any], Sequence[_ColumnsClauseArgument[Any]]], session: Optional[Session] = ...) -> None: ...
    def tuples(self) -> Query[Tuple[_O]]: ...
    @property
    def statement(self) -> Union[Select[_T], FromStatement[_T]]: ...
    def subquery(self, name: Optional[str] = ..., with_labels: bool = ..., reduce_columns: bool = ...) -> Subquery: ...
    def cte(self, name: Optional[str] = ..., recursive: bool = ..., nesting: bool = ...) -> CTE: ...
    def label(self, name: Optional[str]) -> Label[Any]: ...
    @overload
    def as_scalar(self) -> ScalarSelect[_MAYBE_ENTITY]: ...
    @overload
    def as_scalar(self) -> ScalarSelect[_NOT_ENTITY]: ...
    @overload
    def as_scalar(self) -> ScalarSelect[Any]: ...
    @overload
    def scalar_subquery(self) -> ScalarSelect[Any]: ...
    @overload
    def scalar_subquery(self) -> ScalarSelect[_NOT_ENTITY]: ...
    @overload
    def scalar_subquery(self) -> ScalarSelect[Any]: ...
    @property
    def selectable(self) -> Union[Select[_T], FromStatement[_T]]: ...
    def __clause_element__(self) -> Union[Select[_T], FromStatement[_T]]: ...
    @overload
    def only_return_tuples(self, value: Literal[True]) -> RowReturningQuery[Tuple[_O]]: ...
    @overload
    def only_return_tuples(self, value: Literal[False]) -> Query[_O]: ...
    @property
    def is_single_entity(self) -> bool: ...
    def enable_eagerloads(self, value: bool) -> Self: ...
    def with_labels(self) -> Self: ...
    apply_labels = with_labels
    @property
    def get_label_style(self) -> SelectLabelStyle: ...
    def set_label_style(self, style: SelectLabelStyle) -> Self: ...
    def enable_assertions(self, value: bool) -> Self: ...
    @property
    def whereclause(self) -> Optional[ColumnElement[bool]]: ...
    def yield_per(self, count: int) -> Self: ...
    def get(self, ident: _PKIdentityArgument) -> Optional[Any]: ...
    @property
    def lazy_loaded_from(self) -> Optional[InstanceState[Any]]: ...
    def correlate(self, *fromclauses: Union[Literal[None, False], _FromClauseArgument]) -> Self: ...
    def autoflush(self, setting: bool) -> Self: ...
    def populate_existing(self) -> Self: ...
    def with_parent(self, instance: object, property: Optional[attributes.QueryableAttribute[Any]] = ..., from_entity: Optional[_ExternalEntityType[Any]] = ...) -> Self: ...
    def add_entity(self, entity: _EntityType[Any], alias: Optional[Union[Alias, Subquery]] = ...) -> Query[Any]: ...
    def with_session(self, session: Session) -> Self: ...
    def values(self, *columns: _ColumnsClauseArgument[Any]) -> Iterable[Any]: ...
    def value(self, column: _ColumnExpressionArgument[Any]) -> Any: ...
    @overload
    def with_entities(self, _entity: _EntityType[_O]) -> Query[_O]: ...
    @overload
    def with_entities(self, _colexpr: roles.TypedColumnsClauseRole[_T]) -> RowReturningQuery[Tuple[_T]]: ...
    @overload
    def with_entities(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1]) -> RowReturningQuery[Tuple[_T0, _T1]]: ...
    @overload
    def with_entities(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2]) -> RowReturningQuery[Tuple[_T0, _T1, _T2]]: ...
    @overload
    def with_entities(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3]) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3]]: ...
    @overload
    def with_entities(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4]) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4]]: ...
    @overload
    def with_entities(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5]) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4, _T5]]: ...
    @overload
    def with_entities(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5], __ent6: _TCCA[_T6]) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6]]: ...
    @overload
    def with_entities(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5], __ent6: _TCCA[_T6], __ent7: _TCCA[_T7]) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7]]: ...
    @overload
    def with_entities(self, *entities: _ColumnsClauseArgument[Any]) -> Query[Any]: ...
    def add_columns(self, *column: _ColumnExpressionArgument[Any]) -> Query[Any]: ...
    def add_column(self, column: _ColumnExpressionArgument[Any]) -> Query[Any]: ...
    def options(self, *args: ExecutableOption) -> Self: ...
    def with_transformation(self, fn: Callable[[Query[Any]], Query[Any]]) -> Query[Any]: ...
    def get_execution_options(self) -> _ImmutableExecuteOptions: ...
    @overload
    def execution_options(self, *, compiled_cache: Optional[CompiledCacheType] = ..., logging_token: str = ..., isolation_level: IsolationLevel = ..., no_parameters: bool = ..., stream_results: bool = ..., max_row_buffer: int = ..., yield_per: int = ..., insertmanyvalues_page_size: int = ..., schema_translate_map: Optional[SchemaTranslateMapType] = ..., populate_existing: bool = ..., autoflush: bool = ..., **opt: Any) -> Self: ...
    @overload
    def execution_options(self, **opt: Any) -> Self: ...
    def with_for_update(self, *, nowait: bool = ..., read: bool = ..., of: Optional[_ForUpdateOfArgument] = ..., skip_locked: bool = ..., key_share: bool = ...) -> Self: ...
    def params(self, __params: Optional[Dict[str, Any]] = ..., **kw: Any) -> Self: ...
    def where(self, *criterion: _ColumnExpressionArgument[bool]) -> Self: ...
    def filter(self, *criterion: _ColumnExpressionArgument[bool]) -> Self: ...
    def filter_by(self, **kwargs: Any) -> Self: ...
    def order_by(self, __first: Union[Literal[None, False, _NoArg.NO_ARG], _ColumnExpressionOrStrLabelArgument[Any]] = ..., *clauses: _ColumnExpressionOrStrLabelArgument[Any]) -> Self: ...
    def group_by(self, __first: Union[Literal[None, False, _NoArg.NO_ARG], _ColumnExpressionOrStrLabelArgument[Any]] = ..., *clauses: _ColumnExpressionOrStrLabelArgument[Any]) -> Self: ...
    def having(self, *having: _ColumnExpressionArgument[bool]) -> Self: ...
    def union(self, *q: Query[Any]) -> Self: ...
    def union_all(self, *q: Query[Any]) -> Self: ...
    def intersect(self, *q: Query[Any]) -> Self: ...
    def intersect_all(self, *q: Query[Any]) -> Self: ...
    def except_(self, *q: Query[Any]) -> Self: ...
    def except_all(self, *q: Query[Any]) -> Self: ...
    def join(self, target: _JoinTargetArgument, onclause: Optional[_OnClauseArgument] = ..., *, isouter: bool = ..., full: bool = ...) -> Self: ...
    def outerjoin(self, target: _JoinTargetArgument, onclause: Optional[_OnClauseArgument] = ..., *, full: bool = ...) -> Self: ...
    def reset_joinpoint(self) -> Self: ...
    def select_from(self, *from_obj: _FromClauseArgument) -> Self: ...
    def __getitem__(self, item: Any) -> Any: ...
    def slice(self, start: int, stop: int) -> Self: ...
    def limit(self, limit: _LimitOffsetType) -> Self: ...
    def offset(self, offset: _LimitOffsetType) -> Self: ...
    def distinct(self, *expr: _ColumnExpressionArgument[Any]) -> Self: ...
    def all(self) -> List[_T]: ...
    def from_statement(self, statement: ExecutableReturnsRows) -> Self: ...
    def first(self) -> Optional[_T]: ...
    def one_or_none(self) -> Optional[_T]: ...
    def one(self) -> _T: ...
    def scalar(self) -> Any: ...
    def __iter__(self) -> Iterator[_T]: ...
    @property
    def column_descriptions(self) -> List[ORMColumnDescription]: ...
    def instances(self, result_proxy: CursorResult[Any], context: Optional[QueryContext] = ...) -> Any: ...
    def merge_result(self, iterator: Union[FrozenResult[Any], Iterable[Sequence[Any]], Iterable[object]], load: bool = ...) -> Union[FrozenResult[Any], Iterable[Any]]: ...
    def exists(self) -> Exists: ...
    def count(self) -> int: ...
    def delete(self, synchronize_session: SynchronizeSessionArgument = ...) -> int: ...
    def update(self, values: Dict[_DMLColumnArgument, Any], synchronize_session: SynchronizeSessionArgument = ..., update_args: Optional[Dict[Any, Any]] = ...) -> int: ...

class AliasOption(interfaces.LoaderOption):
    inherit_cache: bool
    def __init__(self, alias: Union[Alias, Subquery]) -> None: ...
    def process_compile_state(self, compile_state: ORMCompileState) -> None: ...

class BulkUD:
    query: Incomplete
    mapper: Incomplete
    def __init__(self, query: Query[Any]) -> None: ...
    @property
    def session(self) -> Session: ...

class BulkUpdate(BulkUD):
    values: Incomplete
    update_kwargs: Incomplete
    def __init__(self, query: Query[Any], values: Dict[_DMLColumnArgument, Any], update_kwargs: Optional[Dict[Any, Any]]) -> None: ...

class BulkDelete(BulkUD): ...

class RowReturningQuery(Query[Row[_TP]]):
    def tuples(self) -> Query[_TP]: ...
