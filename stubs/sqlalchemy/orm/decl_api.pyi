from . import attributes as attributes, clsregistry as clsregistry, instrumentation as instrumentation, interfaces as interfaces, mapperlib as mapperlib
from .. import exc as exc, inspection as inspection, util as util
from ..sql import sqltypes as sqltypes
from ..sql.base import _NoArg
from ..sql.elements import SQLCoreOperations as SQLCoreOperations
from ..sql.schema import MetaData as MetaData
from ..sql.selectable import FromClause as FromClause
from ..util import hybridmethod as hybridmethod, hybridproperty as hybridproperty
from ..util.typing import CallableReference as CallableReference, Literal as Literal, Self as Self, flatten_newtype as flatten_newtype, is_generic as is_generic, is_literal as is_literal, is_newtype as is_newtype
from ._orm_constructors import composite as composite, deferred as deferred, mapped_column as mapped_column, relationship as relationship, synonym as synonym
from ._typing import _O, _RegistryType
from .attributes import InstrumentedAttribute as InstrumentedAttribute
from .base import Mapped as Mapped, ORMDescriptor as ORMDescriptor
from .descriptor_props import Composite as Composite, Synonym as Synonym
from .instrumentation import ClassManager as ClassManager
from .interfaces import MapperProperty as MapperProperty
from .mapper import Mapper as Mapper
from .properties import MappedColumn as MappedColumn
from .relationships import RelationshipProperty as RelationshipProperty
from .state import InstanceState as InstanceState
from _typeshed import Incomplete
from typing import Any, Callable, ClassVar, Dict, FrozenSet, Generic, Optional, Type, Union, overload

def has_inherited_table(cls) -> bool: ...

class _DynamicAttributesType(type):
    def __setattr__(cls, key: str, value: Any) -> None: ...
    def __delattr__(cls, key: str) -> None: ...

class DeclarativeAttributeIntercept(_DynamicAttributesType, inspection.Inspectable[Mapper[Any]]): ...
class DCTransformDeclarative(DeclarativeAttributeIntercept): ...

class DeclarativeMeta(DeclarativeAttributeIntercept):
    metadata: MetaData
    registry: RegistryType
    def __init__(cls, classname: Any, bases: Any, dict_: Any, **kw: Any) -> None: ...

def synonym_for(name: str, map_column: bool = ...) -> Callable[[Callable[..., Any]], Synonym[Any]]: ...

class _declared_attr_common:
    fget: Incomplete
    __doc__: Incomplete
    def __init__(self, fn: Callable[..., Any], cascading: bool = ..., quiet: bool = ...) -> None: ...
    def __get__(self, instance: Optional[object], owner: Any) -> Any: ...

class _declared_directive(_declared_attr_common, Generic[_T]):
    def __init__(self, fn: Callable[..., _T], cascading: bool = ...) -> None: ...
    def __get__(self, instance: Optional[object], owner: Any) -> _T: ...
    def __set__(self, instance: Any, value: Any) -> None: ...
    def __delete__(self, instance: Any) -> None: ...
    def __call__(self, fn: Callable[..., _TT]) -> _declared_directive[_TT]: ...

class declared_attr(interfaces._MappedAttribute[_T], _declared_attr_common):
    def __init__(self, fn: _DeclaredAttrDecorated[_T], cascading: bool = ...) -> None: ...
    def __set__(self, instance: Any, value: Any) -> None: ...
    def __delete__(self, instance: Any) -> None: ...
    @overload
    def __get__(self, instance: None, owner: Any) -> InstrumentedAttribute[_T]: ...
    @overload
    def __get__(self, instance: object, owner: Any) -> _T: ...
    def directive(cls) -> _declared_directive[Any]: ...
    def cascading(cls) -> _stateful_declared_attr[_T]: ...

class _stateful_declared_attr(declared_attr[_T]):
    kw: Dict[str, Any]
    def __init__(self, **kw: Any) -> None: ...
    def __call__(self, fn: _DeclaredAttrDecorated[_T]) -> declared_attr[_T]: ...

def declarative_mixin(cls) -> Type[_T]: ...

class MappedAsDataclass(metaclass=DCTransformDeclarative):
    def __init_subclass__(cls, init: Union[_NoArg, bool] = ..., repr: Union[_NoArg, bool] = ..., eq: Union[_NoArg, bool] = ..., order: Union[_NoArg, bool] = ..., unsafe_hash: Union[_NoArg, bool] = ..., match_args: Union[_NoArg, bool] = ..., kw_only: Union[_NoArg, bool] = ..., dataclass_callable: Union[_NoArg, Callable[..., Type[Any]]] = ...) -> None: ...

class DeclarativeBase(inspection.Inspectable[InstanceState[Any]], metaclass=DeclarativeAttributeIntercept):
    registry: ClassVar[_RegistryType]
    metadata: ClassVar[MetaData]
    __mapper__: ClassVar[Mapper[Any]]
    __table__: ClassVar[FromClause]
    __tablename__: Any
    __mapper_args__: Any
    __table_args__: Any
    def __init__(self, **kw: Any) -> None: ...
    def __init_subclass__(cls) -> None: ...

class DeclarativeBaseNoMeta(inspection.Inspectable[InstanceState[Any]]):
    registry: ClassVar[_RegistryType]
    metadata: ClassVar[MetaData]
    __mapper__: ClassVar[Mapper[Any]]
    __table__: Optional[FromClause]
    __tablename__: Any
    __mapper_args__: Any
    __table_args__: Any
    def __init__(self, **kw: Any) -> None: ...
    def __init_subclass__(cls) -> None: ...

def add_mapped_attribute(target: Type[_O], key: str, attr: MapperProperty[Any]) -> None: ...
def declarative_base(*, metadata: Optional[MetaData] = ..., mapper: Optional[Callable[..., Mapper[Any]]] = ..., cls: Type[Any] = ..., name: str = ..., class_registry: Optional[clsregistry._ClsRegistryType] = ..., type_annotation_map: Optional[_TypeAnnotationMapType] = ..., constructor: Callable[..., None] = ..., metaclass: Type[Any] = ...) -> Any: ...

class registry:
    metadata: MetaData
    constructor: CallableReference[Callable[..., None]]
    type_annotation_map: _MutableTypeAnnotationMapType
    def __init__(self, *, metadata: Optional[MetaData] = ..., class_registry: Optional[clsregistry._ClsRegistryType] = ..., type_annotation_map: Optional[_TypeAnnotationMapType] = ..., constructor: Callable[..., None] = ...) -> None: ...
    def update_type_annotation_map(self, type_annotation_map: _TypeAnnotationMapType) -> None: ...
    @property
    def mappers(self) -> FrozenSet[Mapper[Any]]: ...
    def configure(self, cascade: bool = ...) -> None: ...
    def dispose(self, cascade: bool = ...) -> None: ...
    def generate_base(self, mapper: Optional[Callable[..., Mapper[Any]]] = ..., cls: Type[Any] = ..., name: str = ..., metaclass: Type[Any] = ...) -> Any: ...
    @overload
    def mapped_as_dataclass(self, __cls: Type[_O]) -> Type[_O]: ...
    @overload
    def mapped_as_dataclass(self, __cls: Literal[None] = ..., *, init: Union[_NoArg, bool] = ..., repr: Union[_NoArg, bool] = ..., eq: Union[_NoArg, bool] = ..., order: Union[_NoArg, bool] = ..., unsafe_hash: Union[_NoArg, bool] = ..., match_args: Union[_NoArg, bool] = ..., kw_only: Union[_NoArg, bool] = ..., dataclass_callable: Union[_NoArg, Callable[..., Type[Any]]] = ...) -> Callable[[Type[_O]], Type[_O]]: ...
    def mapped(self, cls: Type[_O]) -> Type[_O]: ...
    def as_declarative_base(self, **kw: Any) -> Callable[[Type[_T]], Type[_T]]: ...
    def map_declaratively(self, cls: Type[_O]) -> Mapper[_O]: ...
    def map_imperatively(self, class_: Type[_O], local_table: Optional[FromClause] = ..., **kw: Any) -> Mapper[_O]: ...
RegistryType = registry

def as_declarative(**kw: Any) -> Callable[[Type[_T]], Type[_T]]: ...
