import dataclasses
from . import collections as collections, interfaces as interfaces
from .. import event as event, exc as exc, inspection as inspection, util as util
from ..event import EventTarget as EventTarget, dispatcher as dispatcher
from ..event.base import _Dispatch
from ..sql import base as sql_base, cache_key as cache_key, coercions as coercions, roles as roles, visitors as visitors
from ..sql._typing import _ColumnExpressionArgument, _InfoType
from ..sql.cache_key import HasCacheKey as HasCacheKey
from ..sql.elements import ColumnElement as ColumnElement, Label as Label
from ..sql.operators import OperatorType as OperatorType
from ..sql.selectable import FromClause as FromClause
from ..sql.visitors import InternalTraversal as InternalTraversal
from ..util.typing import Literal as Literal, Self as Self, TypeGuard as TypeGuard
from ._typing import _EntityType, _ExternalEntityType, _InstanceDict, _InternalEntityType, _LoaderCallable, _O, insp_is_aliased_class as insp_is_aliased_class
from .base import ATTR_EMPTY as ATTR_EMPTY, ATTR_WAS_SET as ATTR_WAS_SET, CALLABLES_OK as CALLABLES_OK, DEFERRED_HISTORY_LOAD as DEFERRED_HISTORY_LOAD, INCLUDE_PENDING_MUTATIONS as INCLUDE_PENDING_MUTATIONS, INIT_OK as INIT_OK, LOAD_AGAINST_COMMITTED as LOAD_AGAINST_COMMITTED, LoaderCallableStatus as LoaderCallableStatus, NEVER_SET as NEVER_SET, NON_PERSISTENT_OK as NON_PERSISTENT_OK, NO_AUTOFLUSH as NO_AUTOFLUSH, NO_CHANGE as NO_CHANGE, NO_KEY as NO_KEY, NO_RAISE as NO_RAISE, NO_VALUE as NO_VALUE, PASSIVE_CLASS_MISMATCH as PASSIVE_CLASS_MISMATCH, PASSIVE_NO_FETCH as PASSIVE_NO_FETCH, PASSIVE_NO_FETCH_RELATED as PASSIVE_NO_FETCH_RELATED, PASSIVE_NO_INITIALIZE as PASSIVE_NO_INITIALIZE, PASSIVE_NO_RESULT as PASSIVE_NO_RESULT, PASSIVE_OFF as PASSIVE_OFF, PASSIVE_ONLY_PERSISTENT as PASSIVE_ONLY_PERSISTENT, PASSIVE_RETURN_NO_VALUE as PASSIVE_RETURN_NO_VALUE, PassiveFlag as PassiveFlag, RELATED_OBJECT_OK as RELATED_OBJECT_OK, SQLORMExpression as SQLORMExpression, SQL_OK as SQL_OK, _DeclarativeMapped, instance_str as instance_str, state_str as state_str
from .collections import CollectionAdapter as CollectionAdapter, _AdaptedCollectionProtocol
from .interfaces import MapperProperty as MapperProperty
from .relationships import RelationshipProperty as RelationshipProperty
from .state import InstanceState as InstanceState
from .util import AliasedInsp as AliasedInsp
from .writeonly import WriteOnlyAttributeImpl as WriteOnlyAttributeImpl
from _typeshed import Incomplete
from typing import Any, Callable, ClassVar, Dict, List, NamedTuple, Optional, Sequence, Tuple, Type, Union, overload

class QueryableAttribute(_DeclarativeMapped[_T_co], SQLORMExpression[_T_co], interfaces.InspectionAttr, interfaces.PropComparator[_T_co], roles.JoinTargetRole, roles.OnClauseRole, sql_base.Immutable, cache_key.SlotsMemoizedHasCacheKey, util.MemoizedSlots, EventTarget):
    is_attribute: bool
    dispatch: dispatcher[QueryableAttribute[_T_co]]
    class_: _ExternalEntityType[Any]
    key: str
    parententity: _InternalEntityType[Any]
    impl: AttributeImpl
    comparator: interfaces.PropComparator[_T_co]
    __visit_name__: str
    def __init__(self, class_: _ExternalEntityType[_O], key: str, parententity: _InternalEntityType[_O], comparator: interfaces.PropComparator[_T_co], impl: Optional[AttributeImpl] = ..., of_type: Optional[_InternalEntityType[Any]] = ..., extra_criteria: Tuple[ColumnElement[bool], ...] = ...) -> None: ...
    def __reduce__(self) -> Any: ...
    def get_history(self, instance: Any, passive: PassiveFlag = ...) -> History: ...
    @property
    def info(self) -> _InfoType: ...
    parent: _InternalEntityType[Any]
    expression: ColumnElement[_T_co]
    def __clause_element__(self) -> ColumnElement[_T_co]: ...
    def adapt_to_entity(self, adapt_to_entity: AliasedInsp[Any]) -> Self: ...
    def of_type(self, entity: _EntityType[Any]) -> QueryableAttribute[_T]: ...
    def and_(self, *clauses: _ColumnExpressionArgument[bool]) -> QueryableAttribute[bool]: ...
    def label(self, name: Optional[str]) -> Label[_T_co]: ...
    def operate(self, op: OperatorType, *other: Any, **kwargs: Any) -> ColumnElement[Any]: ...
    def reverse_operate(self, op: OperatorType, other: Any, **kwargs: Any) -> ColumnElement[Any]: ...
    def hasparent(self, state: InstanceState[Any], optimistic: bool = ...) -> bool: ...
    def __getattr__(self, key: str) -> Any: ...

class InstrumentedAttribute(QueryableAttribute[_T]):
    inherit_cache: bool
    def __set__(self, instance: object, value: Any) -> None: ...
    def __delete__(self, instance: object) -> None: ...
    @overload
    def __get__(self, instance: None, owner: Any) -> InstrumentedAttribute[_T]: ...
    @overload
    def __get__(self, instance: object, owner: Any) -> _T: ...

@dataclasses.dataclass(frozen=True)
class AdHocHasEntityNamespace(HasCacheKey):
    is_mapper: ClassVar[bool] = ...
    is_aliased_class: ClassVar[bool] = ...
    @property
    def entity_namespace(self): ...
    def __init__(self, _entity_namespace) -> None: ...

def create_proxied_attribute(descriptor: Any) -> Callable[..., QueryableAttribute[Any]]: ...

OP_REMOVE: Incomplete
OP_APPEND: Incomplete
OP_REPLACE: Incomplete
OP_BULK_REPLACE: Incomplete
OP_MODIFIED: Incomplete

class AttributeEventToken:
    impl: Incomplete
    op: Incomplete
    parent_token: Incomplete
    def __init__(self, attribute_impl: AttributeImpl, op: util.symbol) -> None: ...
    def __eq__(self, other): ...
    @property
    def key(self): ...
    def hasparent(self, state): ...
AttributeEvent = AttributeEventToken
Event = AttributeEventToken

class AttributeImpl:
    collection: bool
    default_accepts_scalar_loader: bool
    uses_objects: bool
    supports_population: bool
    dynamic: bool
    class_: Incomplete
    key: Incomplete
    callable_: Incomplete
    dispatch: Incomplete
    trackparent: Incomplete
    parent_token: Incomplete
    send_modified_events: Incomplete
    is_equal: Incomplete
    accepts_scalar_loader: Incomplete
    load_on_unexpire: Incomplete
    def __init__(self, class_: _ExternalEntityType[_O], key: str, callable_: Optional[_LoaderCallable], dispatch: _Dispatch[QueryableAttribute[Any]], trackparent: bool = ..., compare_function: Optional[Callable[..., bool]] = ..., active_history: bool = ..., parent_token: Optional[AttributeEventToken] = ..., load_on_unexpire: bool = ..., send_modified_events: bool = ..., accepts_scalar_loader: Optional[bool] = ..., **kwargs: Any) -> None: ...
    active_history: Incomplete
    def hasparent(self, state: InstanceState[Any], optimistic: bool = ...) -> bool: ...
    def sethasparent(self, state: InstanceState[Any], parent_state: InstanceState[Any], value: bool) -> None: ...
    def get_history(self, state: InstanceState[Any], dict_: _InstanceDict, passive: PassiveFlag = ...) -> History: ...
    def get_all_pending(self, state: InstanceState[Any], dict_: _InstanceDict, passive: PassiveFlag = ...) -> _AllPendingType: ...
    def get(self, state: InstanceState[Any], dict_: _InstanceDict, passive: PassiveFlag = ...) -> Any: ...
    def append(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken], passive: PassiveFlag = ...) -> None: ...
    def remove(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken], passive: PassiveFlag = ...) -> None: ...
    def pop(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken], passive: PassiveFlag = ...) -> None: ...
    def set(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken] = ..., passive: PassiveFlag = ..., check_old: Any = ..., pop: bool = ...) -> None: ...
    def delete(self, state: InstanceState[Any], dict_: _InstanceDict) -> None: ...
    def get_committed_value(self, state: InstanceState[Any], dict_: _InstanceDict, passive: PassiveFlag = ...) -> Any: ...
    def set_committed_value(self, state, dict_, value): ...

class ScalarAttributeImpl(AttributeImpl):
    default_accepts_scalar_loader: bool
    uses_objects: bool
    supports_population: bool
    collection: bool
    dynamic: bool
    def __init__(self, *arg, **kw) -> None: ...
    def delete(self, state: InstanceState[Any], dict_: _InstanceDict) -> None: ...
    def get_history(self, state: InstanceState[Any], dict_: Dict[str, Any], passive: PassiveFlag = ...) -> History: ...
    def set(self, state: InstanceState[Any], dict_: Dict[str, Any], value: Any, initiator: Optional[AttributeEventToken] = ..., passive: PassiveFlag = ..., check_old: Optional[object] = ..., pop: bool = ...) -> None: ...
    def fire_replace_event(self, state: InstanceState[Any], dict_: _InstanceDict, value: _T, previous: Any, initiator: Optional[AttributeEventToken]) -> _T: ...
    def fire_remove_event(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken]) -> None: ...

class ScalarObjectAttributeImpl(ScalarAttributeImpl):
    default_accepts_scalar_loader: bool
    uses_objects: bool
    supports_population: bool
    collection: bool
    def delete(self, state: InstanceState[Any], dict_: _InstanceDict) -> None: ...
    def get_history(self, state: InstanceState[Any], dict_: _InstanceDict, passive: PassiveFlag = ...) -> History: ...
    def get_all_pending(self, state: InstanceState[Any], dict_: _InstanceDict, passive: PassiveFlag = ...) -> _AllPendingType: ...
    def set(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken] = ..., passive: PassiveFlag = ..., check_old: Any = ..., pop: bool = ...) -> None: ...
    def fire_remove_event(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken]) -> None: ...
    def fire_replace_event(self, state: InstanceState[Any], dict_: _InstanceDict, value: _T, previous: Any, initiator: Optional[AttributeEventToken]) -> _T: ...

class HasCollectionAdapter:
    collection: bool
    @overload
    def get_collection(self, state: InstanceState[Any], dict_: _InstanceDict, user_data: Literal[None] = ..., passive: Literal[PassiveFlag.PASSIVE_OFF] = ...) -> CollectionAdapter: ...
    @overload
    def get_collection(self, state: InstanceState[Any], dict_: _InstanceDict, user_data: _AdaptedCollectionProtocol = ..., passive: PassiveFlag = ...) -> CollectionAdapter: ...
    @overload
    def get_collection(self, state: InstanceState[Any], dict_: _InstanceDict, user_data: Optional[_AdaptedCollectionProtocol] = ..., passive: PassiveFlag = ...) -> Union[Literal[LoaderCallableStatus.PASSIVE_NO_RESULT], CollectionAdapter]: ...
    def set(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken] = ..., passive: PassiveFlag = ..., check_old: Any = ..., pop: bool = ..., _adapt: bool = ...) -> None: ...

class CollectionAttributeImpl(HasCollectionAdapter, AttributeImpl):
    uses_objects: bool
    collection: bool
    default_accepts_scalar_loader: bool
    supports_population: bool
    dynamic: bool
    copy: Incomplete
    collection_factory: Incomplete
    def __init__(self, class_, key, callable_, dispatch, typecallable: Incomplete | None = ..., trackparent: bool = ..., copy_function: Incomplete | None = ..., compare_function: Incomplete | None = ..., **kwargs) -> None: ...
    def get_history(self, state: InstanceState[Any], dict_: _InstanceDict, passive: PassiveFlag = ...) -> History: ...
    def get_all_pending(self, state: InstanceState[Any], dict_: _InstanceDict, passive: PassiveFlag = ...) -> _AllPendingType: ...
    def fire_append_event(self, state: InstanceState[Any], dict_: _InstanceDict, value: _T, initiator: Optional[AttributeEventToken], key: Optional[Any]) -> _T: ...
    def fire_append_wo_mutation_event(self, state: InstanceState[Any], dict_: _InstanceDict, value: _T, initiator: Optional[AttributeEventToken], key: Optional[Any]) -> _T: ...
    def fire_pre_remove_event(self, state: InstanceState[Any], dict_: _InstanceDict, initiator: Optional[AttributeEventToken], key: Optional[Any]) -> None: ...
    def fire_remove_event(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken], key: Optional[Any]) -> None: ...
    def delete(self, state: InstanceState[Any], dict_: _InstanceDict) -> None: ...
    def append(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken], passive: PassiveFlag = ...) -> None: ...
    def remove(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken], passive: PassiveFlag = ...) -> None: ...
    def pop(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken], passive: PassiveFlag = ...) -> None: ...
    def set(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken] = ..., passive: PassiveFlag = ..., check_old: Any = ..., pop: bool = ..., _adapt: bool = ...) -> None: ...
    def set_committed_value(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any) -> _AdaptedCollectionProtocol: ...
    @overload
    def get_collection(self, state: InstanceState[Any], dict_: _InstanceDict, user_data: Literal[None] = ..., passive: Literal[PassiveFlag.PASSIVE_OFF] = ...) -> CollectionAdapter: ...
    @overload
    def get_collection(self, state: InstanceState[Any], dict_: _InstanceDict, user_data: _AdaptedCollectionProtocol = ..., passive: PassiveFlag = ...) -> CollectionAdapter: ...
    @overload
    def get_collection(self, state: InstanceState[Any], dict_: _InstanceDict, user_data: Optional[_AdaptedCollectionProtocol] = ..., passive: PassiveFlag = ...) -> Union[Literal[LoaderCallableStatus.PASSIVE_NO_RESULT], CollectionAdapter]: ...

def backref_listeners(attribute: QueryableAttribute[Any], key: str, uselist: bool) -> None: ...

class History(NamedTuple):
    added: Union[Tuple, List[Any]]
    unchanged: Union[Tuple, List[Any]]
    deleted: Union[Tuple, List[Any]]
    def __bool__(self) -> bool: ...
    def empty(self) -> bool: ...
    def sum(self) -> Sequence[Any]: ...
    def non_deleted(self) -> Sequence[Any]: ...
    def non_added(self) -> Sequence[Any]: ...
    def has_changes(self) -> bool: ...
    def as_state(self) -> History: ...
    @classmethod
    def from_scalar_attribute(cls, attribute: ScalarAttributeImpl, state: InstanceState[Any], current: Any) -> History: ...
    @classmethod
    def from_object_attribute(cls, attribute: ScalarObjectAttributeImpl, state: InstanceState[Any], current: Any, original: Any = ...) -> History: ...
    @classmethod
    def from_collection(cls, attribute: CollectionAttributeImpl, state: InstanceState[Any], current: Any) -> History: ...

HISTORY_BLANK: Incomplete

def get_history(obj: object, key: str, passive: PassiveFlag = ...) -> History: ...
def get_state_history(state: InstanceState[Any], key: str, passive: PassiveFlag = ...) -> History: ...
def has_parent(cls, obj: _O, key: str, optimistic: bool = ...) -> bool: ...
def register_attribute(class_: Type[_O], key: str, *, comparator: interfaces.PropComparator[_T], parententity: _InternalEntityType[_O], doc: Optional[str] = ..., **kw: Any) -> InstrumentedAttribute[_T]: ...
def register_attribute_impl(class_: Type[_O], key: str, uselist: bool = ..., callable_: Optional[_LoaderCallable] = ..., useobject: bool = ..., impl_class: Optional[Type[AttributeImpl]] = ..., backref: Optional[str] = ..., **kw: Any) -> QueryableAttribute[Any]: ...
def register_descriptor(class_: Type[Any], key: str, *, comparator: interfaces.PropComparator[_T], parententity: _InternalEntityType[Any], doc: Optional[str] = ...) -> InstrumentedAttribute[_T]: ...
def unregister_attribute(class_: Type[Any], key: str) -> None: ...
def init_collection(obj: object, key: str) -> CollectionAdapter: ...
def init_state_collection(state: InstanceState[Any], dict_: _InstanceDict, key: str) -> CollectionAdapter: ...
def set_committed_value(instance, key, value) -> None: ...
def set_attribute(instance: object, key: str, value: Any, initiator: Optional[AttributeEventToken] = ...) -> None: ...
def get_attribute(instance: object, key: str) -> Any: ...
def del_attribute(instance: object, key: str) -> None: ...
def flag_modified(instance: object, key: str) -> None: ...
def flag_dirty(instance: object) -> None: ...
