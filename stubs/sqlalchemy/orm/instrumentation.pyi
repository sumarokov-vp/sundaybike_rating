import weakref
from . import base as base, collections as collections, exc as exc, interfaces as interfaces, state as state
from .. import util as util
from ..event import EventTarget as EventTarget, dispatcher as dispatcher
from ..util import HasMemoized as HasMemoized
from ..util.typing import Literal as Literal, Protocol as Protocol
from ._typing import _O, _RegistryType
from .attributes import AttributeImpl as AttributeImpl, QueryableAttribute as QueryableAttribute
from .collections import _AdaptedCollectionProtocol, _CollectionFactoryType
from .decl_base import _MapperConfig
from .events import InstanceEvents as InstanceEvents
from .mapper import Mapper as Mapper
from .state import InstanceState as InstanceState
from _typeshed import Incomplete
from collections.abc import Generator
from typing import Any, Callable, Collection, Dict, Generic, Iterable, Optional, Set, Tuple, Type

DEL_ATTR: Incomplete

class _ExpiredAttributeLoaderProto(Protocol):
    def __call__(self, state: state.InstanceState[Any], toload: Set[str], passive: base.PassiveFlag) -> None: ...

class _ManagerFactory(Protocol):
    def __call__(self, class_: Type[_O]) -> ClassManager[_O]: ...

class ClassManager(HasMemoized, Dict[str, 'QueryableAttribute[Any]'], EventTarget, Generic[_O]):
    dispatch: dispatcher[ClassManager[_O]]
    MANAGER_ATTR: Incomplete
    STATE_ATTR: Incomplete
    expired_attribute_loader: _ExpiredAttributeLoaderProto
    init_method: Optional[Callable[..., None]]
    original_init: Optional[Callable[..., None]]
    factory: Optional[_ManagerFactory]
    declarative_scan: Optional[weakref.ref[_MapperConfig]]
    registry: _RegistryType
    class_: Type[_O]
    @property
    def deferred_scalar_loader(self): ...
    @deferred_scalar_loader.setter
    def deferred_scalar_loader(self, obj) -> None: ...
    info: Incomplete
    new_init: Incomplete
    local_attrs: Incomplete
    originals: Incomplete
    def __init__(self, class_) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    @property
    def is_mapped(self) -> bool: ...
    def mapper(self) -> Mapper[_O]: ...
    def manage(self) -> None: ...
    def manager_getter(self): ...
    def state_getter(self): ...
    def dict_getter(self): ...
    def instrument_attribute(self, key: str, inst: QueryableAttribute[Any], propagated: bool = ...) -> None: ...
    def subclass_managers(self, recursive) -> Generator[Incomplete, Incomplete, None]: ...
    def post_configure_attribute(self, key) -> None: ...
    def uninstrument_attribute(self, key, propagated: bool = ...) -> None: ...
    def unregister(self) -> None: ...
    def install_descriptor(self, key: str, inst: QueryableAttribute[Any]) -> None: ...
    def uninstall_descriptor(self, key: str) -> None: ...
    def install_member(self, key: str, implementation: Any) -> None: ...
    def uninstall_member(self, key: str) -> None: ...
    def instrument_collection_class(self, key: str, collection_class: Type[Collection[Any]]) -> _CollectionFactoryType: ...
    def initialize_collection(self, key: str, state: InstanceState[_O], factory: _CollectionFactoryType) -> Tuple[collections.CollectionAdapter, _AdaptedCollectionProtocol]: ...
    def is_instrumented(self, key: str, search: bool = ...) -> bool: ...
    def get_impl(self, key: str) -> AttributeImpl: ...
    @property
    def attributes(self) -> Iterable[Any]: ...
    def new_instance(self, state: Optional[InstanceState[_O]] = ...) -> _O: ...
    def setup_instance(self, instance: _O, state: Optional[InstanceState[_O]] = ...) -> None: ...
    def teardown_instance(self, instance: _O) -> None: ...
    def has_state(self, instance: _O) -> bool: ...
    def has_parent(self, state: InstanceState[_O], key: str, optimistic: bool = ...) -> bool: ...
    def __bool__(self) -> bool: ...

class _SerializeManager:
    class_: Incomplete
    def __init__(self, state: state.InstanceState[Any], d: Dict[str, Any]) -> None: ...
    def __call__(self, state, inst, state_dict) -> None: ...

class InstrumentationFactory(EventTarget):
    dispatch: dispatcher[InstrumentationFactory]
    def create_manager_for_cls(self, class_: Type[_O]) -> ClassManager[_O]: ...
    def unregister(self, class_: Type[_O]) -> None: ...
instance_state = base.instance_state
instance_dict = base.instance_dict
manager_of_class = base.manager_of_class

opt_manager_of_class: Incomplete

def register_class(class_: Type[_O], finalize: bool = ..., mapper: Optional[Mapper[_O]] = ..., registry: Optional[_RegistryType] = ..., declarative_scan: Optional[_MapperConfig] = ..., expired_attribute_loader: Optional[_ExpiredAttributeLoaderProto] = ..., init_method: Optional[Callable[..., None]] = ...) -> ClassManager[_O]: ...
def unregister_class(class_) -> None: ...
def is_instrumented(instance, key): ...
