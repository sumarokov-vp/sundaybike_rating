from . import QueryableAttribute as QueryableAttribute, attributes as attributes, interfaces as interfaces, relationships as relationships, strategies as strategies
from .. import exc as exc, inspect as inspect, log as log, util as util
from ..event import _Dispatch
from ..sql import delete as delete, insert as insert, select as select, update as update
from ..sql.dml import Delete as Delete, Insert as Insert, Update as Update
from ..sql.selectable import FromClause as FromClause, Select as Select
from ..util.typing import Literal as Literal
from ._typing import _InstanceDict
from .attributes import AttributeEventToken as AttributeEventToken
from .base import LoaderCallableStatus as LoaderCallableStatus, NEVER_SET as NEVER_SET, PassiveFlag as PassiveFlag, RelationshipDirection as RelationshipDirection, object_mapper as object_mapper
from .collections import CollectionAdapter as CollectionAdapter, _AdaptedCollectionProtocol
from .mapper import Mapper as Mapper
from .relationships import _RelationshipOrderByArg
from .state import InstanceState as InstanceState
from .util import AliasedClass as AliasedClass
from _typeshed import Incomplete
from typing import Any, Collection, Generic, Iterable, Iterator, List, NoReturn, Optional, Tuple, Type, Union, overload

class WriteOnlyHistory(Generic[_T]):
    unchanged_items: util.OrderedIdentitySet
    added_items: util.OrderedIdentitySet
    deleted_items: util.OrderedIdentitySet
    def __init__(self, attr: WriteOnlyAttributeImpl, state: InstanceState[_T], passive: PassiveFlag, apply_to: Optional[WriteOnlyHistory[_T]] = ...) -> None: ...
    @property
    def added_plus_unchanged(self) -> List[_T]: ...
    @property
    def all_items(self) -> List[_T]: ...
    def as_history(self) -> attributes.History: ...
    def indexed(self, index: Union[int, slice]) -> Union[List[_T], _T]: ...
    def add_added(self, value: _T) -> None: ...
    def add_removed(self, value: _T) -> None: ...

class WriteOnlyAttributeImpl(attributes.HasCollectionAdapter, attributes.AttributeImpl):
    uses_objects: bool
    default_accepts_scalar_loader: bool
    supports_population: bool
    collection: bool
    dynamic: bool
    order_by: _RelationshipOrderByArg
    collection_history_cls: Type[WriteOnlyHistory[Any]]
    query_class: Type[WriteOnlyCollection[Any]]
    target_mapper: Incomplete
    def __init__(self, class_: Union[Type[Any], AliasedClass[Any]], key: str, dispatch: _Dispatch[QueryableAttribute[Any]], target_mapper: Mapper[_T], order_by: _RelationshipOrderByArg, **kw: Any) -> None: ...
    def get(self, state: InstanceState[Any], dict_: _InstanceDict, passive: PassiveFlag = ...) -> Union[util.OrderedIdentitySet, WriteOnlyCollection[Any]]: ...
    @overload
    def get_collection(self, state: InstanceState[Any], dict_: _InstanceDict, user_data: Literal[None] = ..., passive: Literal[PassiveFlag.PASSIVE_OFF] = ...) -> CollectionAdapter: ...
    @overload
    def get_collection(self, state: InstanceState[Any], dict_: _InstanceDict, user_data: _AdaptedCollectionProtocol = ..., passive: PassiveFlag = ...) -> CollectionAdapter: ...
    @overload
    def get_collection(self, state: InstanceState[Any], dict_: _InstanceDict, user_data: Optional[_AdaptedCollectionProtocol] = ..., passive: PassiveFlag = ...) -> Union[Literal[LoaderCallableStatus.PASSIVE_NO_RESULT], CollectionAdapter]: ...
    def fire_append_event(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken], collection_history: Optional[WriteOnlyHistory[Any]] = ...) -> None: ...
    def fire_remove_event(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken], collection_history: Optional[WriteOnlyHistory[Any]] = ...) -> None: ...
    def set(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken] = ..., passive: PassiveFlag = ..., check_old: Any = ..., pop: bool = ..., _adapt: bool = ...) -> None: ...
    def delete(self, *args: Any, **kwargs: Any) -> NoReturn: ...
    def set_committed_value(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any) -> NoReturn: ...
    def get_history(self, state: InstanceState[Any], dict_: _InstanceDict, passive: PassiveFlag = ...) -> attributes.History: ...
    def get_all_pending(self, state: InstanceState[Any], dict_: _InstanceDict, passive: PassiveFlag = ...) -> List[Tuple[InstanceState[Any], Any]]: ...
    def append(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken], passive: PassiveFlag = ...) -> None: ...
    def remove(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken], passive: PassiveFlag = ...) -> None: ...
    def pop(self, state: InstanceState[Any], dict_: _InstanceDict, value: Any, initiator: Optional[AttributeEventToken], passive: PassiveFlag = ...) -> None: ...

class WriteOnlyLoader(strategies.AbstractRelationshipLoader, log.Identified):
    impl_class = WriteOnlyAttributeImpl
    is_class_level: bool
    def init_class_attribute(self, mapper: Mapper[Any]) -> None: ...

class DynamicCollectionAdapter:
    data: Collection[Any]
    def __init__(self, data: Collection[Any]) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...

class AbstractCollectionWriter(Generic[_T]):
    instance: _T
    attr: Incomplete
    def __init__(self, attr: WriteOnlyAttributeImpl, state: InstanceState[_T]) -> None: ...

class WriteOnlyCollection(AbstractCollectionWriter[_T]):
    def __iter__(self) -> NoReturn: ...
    def select(self) -> Select[Tuple[_T]]: ...
    def insert(self) -> Insert: ...
    def update(self) -> Update: ...
    def delete(self) -> Delete: ...
    def add_all(self, iterator: Iterable[_T]) -> None: ...
    def add(self, item: _T) -> None: ...
    def remove(self, item: _T) -> None: ...
