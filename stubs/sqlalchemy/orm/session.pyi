import contextlib
from . import bulk_persistence, context
from .. import util
from ..engine import Connection, CursorResult, Engine, Result, Row, RowMapping
from ..engine.interfaces import CoreExecuteOptionsParameter, _CoreAnyExecuteParams, _CoreSingleExecuteParams, _ExecuteOptions
from ..engine.result import ScalarResult
from ..engine.util import TransactionalContext
from ..event import EventTarget, _InstanceLevelDispatch, dispatcher
from ..sql import TableClause
from ..sql._typing import _ColumnsClauseArgument, _InfoType, _T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _TypedColumnClauseArgument as _TCCA
from ..sql.base import Executable, _NoArg
from ..sql.dml import UpdateBase
from ..sql.elements import ClauseElement
from ..sql.roles import TypedColumnsClauseRole
from ..sql.selectable import ForUpdateParameter, TypedReturnsRows
from ..util import IdentitySet
from ..util.typing import Literal, Protocol
from ._typing import OrmExecuteOptionsParameter, _EntityType, _IdentityKeyType, _O
from .context import ORMCompileState
from .identity import IdentityMap
from .interfaces import ORMOption, UserDefinedOption
from .mapper import Mapper
from .path_registry import PathRegistry
from .query import Query, RowReturningQuery
from .state import InstanceState
from .state_changes import _StateChange, _StateChangeState
from _typeshed import Incomplete
from enum import Enum
from typing import Any, Dict, Generic, Iterable, Iterator, List, Optional, Sequence, Tuple, Type, Union, overload

class _ConnectionCallableProto(Protocol):
    def __call__(self, mapper: Optional[Mapper[Any]] = ..., instance: Optional[object] = ..., **kw: Any) -> Connection: ...

class _SessionClassMethods:
    @classmethod
    def close_all(cls) -> None: ...
    @classmethod
    def identity_key(cls, class_: Optional[Type[Any]] = ..., ident: Union[Any, Tuple[Any, ...]] = ..., *, instance: Optional[Any] = ..., row: Optional[Union[Row[Any], RowMapping]] = ..., identity_token: Optional[Any] = ...) -> _IdentityKeyType[Any]: ...
    @classmethod
    def object_session(cls, instance: object) -> Optional[Session]: ...

class SessionTransactionState(_StateChangeState):
    ACTIVE: int
    PREPARED: int
    COMMITTED: int
    DEACTIVE: int
    CLOSED: int
    PROVISIONING_CONNECTION: int

class ORMExecuteState(util.MemoizedSlots):
    session: Session
    statement: Executable
    parameters: Optional[_CoreAnyExecuteParams]
    execution_options: _ExecuteOptions
    local_execution_options: _ExecuteOptions
    bind_arguments: _BindArguments
    def __init__(self, session: Session, statement: Executable, parameters: Optional[_CoreAnyExecuteParams], execution_options: _ExecuteOptions, bind_arguments: _BindArguments, compile_state_cls: Optional[Type[ORMCompileState]], events_todo: List[_InstanceLevelDispatch[Session]]) -> None: ...
    def invoke_statement(self, statement: Optional[Executable] = ..., params: Optional[_CoreAnyExecuteParams] = ..., execution_options: Optional[OrmExecuteOptionsParameter] = ..., bind_arguments: Optional[_BindArguments] = ...) -> Result[Any]: ...
    @property
    def bind_mapper(self) -> Optional[Mapper[Any]]: ...
    @property
    def all_mappers(self) -> Sequence[Mapper[Any]]: ...
    @property
    def is_orm_statement(self) -> bool: ...
    @property
    def is_executemany(self) -> bool: ...
    @property
    def is_select(self) -> bool: ...
    @property
    def is_insert(self) -> bool: ...
    @property
    def is_update(self) -> bool: ...
    @property
    def is_delete(self) -> bool: ...
    def update_execution_options(self, **opts: Any) -> None: ...
    @property
    def lazy_loaded_from(self) -> Optional[InstanceState[Any]]: ...
    @property
    def loader_strategy_path(self) -> Optional[PathRegistry]: ...
    @property
    def is_column_load(self) -> bool: ...
    @property
    def is_relationship_load(self) -> bool: ...
    @property
    def load_options(self) -> Union[context.QueryContext.default_load_options, Type[context.QueryContext.default_load_options]]: ...
    @property
    def update_delete_options(self) -> Union[bulk_persistence.BulkUDCompileState.default_update_options, Type[bulk_persistence.BulkUDCompileState.default_update_options]]: ...
    @property
    def user_defined_options(self) -> Sequence[UserDefinedOption]: ...

class SessionTransactionOrigin(Enum):
    AUTOBEGIN: int
    BEGIN: int
    BEGIN_NESTED: int
    SUBTRANSACTION: int

class SessionTransaction(_StateChange, TransactionalContext):
    session: Session
    origin: SessionTransactionOrigin
    nested: bool
    def __init__(self, session: Session, origin: SessionTransactionOrigin, parent: Optional[SessionTransaction] = ...) -> None: ...
    @property
    def parent(self) -> Optional[SessionTransaction]: ...
    @property
    def is_active(self) -> bool: ...
    def connection(self, bindkey: Optional[Mapper[Any]], execution_options: Optional[_ExecuteOptions] = ..., **kwargs: Any) -> Connection: ...
    def prepare(self) -> None: ...
    def commit(self, _to_root: bool = ...) -> None: ...
    def rollback(self, _capture_exception: bool = ..., _to_root: bool = ...) -> None: ...
    def close(self, invalidate: bool = ...) -> None: ...

class _SessionCloseState(Enum):
    ACTIVE: int
    CLOSED: int
    CLOSE_IS_RESET: int

class Session(_SessionClassMethods, EventTarget):
    dispatch: dispatcher[Session]
    identity_map: IdentityMap
    bind: Optional[Union[Engine, Connection]]
    hash_key: int
    autoflush: bool
    expire_on_commit: bool
    enable_baked_queries: bool
    twophase: bool
    join_transaction_mode: JoinTransactionMode
    autobegin: Incomplete
    def __init__(self, bind: Optional[_SessionBind] = ..., *, autoflush: bool = ..., future: Literal[True] = ..., expire_on_commit: bool = ..., autobegin: bool = ..., twophase: bool = ..., binds: Optional[Dict[_SessionBindKey, _SessionBind]] = ..., enable_baked_queries: bool = ..., info: Optional[_InfoType] = ..., query_cls: Optional[Type[Query[Any]]] = ..., autocommit: Literal[False] = ..., join_transaction_mode: JoinTransactionMode = ..., close_resets_only: Union[bool, _NoArg] = ...) -> None: ...
    connection_callable: Optional[_ConnectionCallableProto]
    def __enter__(self) -> _S: ...
    def __exit__(self, type_: Any, value: Any, traceback: Any) -> None: ...
    def in_transaction(self) -> bool: ...
    def in_nested_transaction(self) -> bool: ...
    def get_transaction(self) -> Optional[SessionTransaction]: ...
    def get_nested_transaction(self) -> Optional[SessionTransaction]: ...
    def info(self) -> _InfoType: ...
    def begin(self, nested: bool = ...) -> SessionTransaction: ...
    def begin_nested(self) -> SessionTransaction: ...
    def rollback(self) -> None: ...
    def commit(self) -> None: ...
    def prepare(self) -> None: ...
    def connection(self, bind_arguments: Optional[_BindArguments] = ..., execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> Connection: ...
    @overload
    def execute(self, statement: TypedReturnsRows[_T], params: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: OrmExecuteOptionsParameter = ..., bind_arguments: Optional[_BindArguments] = ..., _parent_execute_state: Optional[Any] = ..., _add_event: Optional[Any] = ...) -> Result[_T]: ...
    @overload
    def execute(self, statement: UpdateBase, params: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: OrmExecuteOptionsParameter = ..., bind_arguments: Optional[_BindArguments] = ..., _parent_execute_state: Optional[Any] = ..., _add_event: Optional[Any] = ...) -> CursorResult[Any]: ...
    @overload
    def execute(self, statement: Executable, params: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: OrmExecuteOptionsParameter = ..., bind_arguments: Optional[_BindArguments] = ..., _parent_execute_state: Optional[Any] = ..., _add_event: Optional[Any] = ...) -> Result[Any]: ...
    @overload
    def scalar(self, statement: TypedReturnsRows[Tuple[_T]], params: Optional[_CoreSingleExecuteParams] = ..., *, execution_options: OrmExecuteOptionsParameter = ..., bind_arguments: Optional[_BindArguments] = ..., **kw: Any) -> Optional[_T]: ...
    @overload
    def scalar(self, statement: Executable, params: Optional[_CoreSingleExecuteParams] = ..., *, execution_options: OrmExecuteOptionsParameter = ..., bind_arguments: Optional[_BindArguments] = ..., **kw: Any) -> Any: ...
    @overload
    def scalars(self, statement: TypedReturnsRows[Tuple[_T]], params: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: OrmExecuteOptionsParameter = ..., bind_arguments: Optional[_BindArguments] = ..., **kw: Any) -> ScalarResult[_T]: ...
    @overload
    def scalars(self, statement: Executable, params: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: OrmExecuteOptionsParameter = ..., bind_arguments: Optional[_BindArguments] = ..., **kw: Any) -> ScalarResult[Any]: ...
    def close(self) -> None: ...
    def reset(self) -> None: ...
    def invalidate(self) -> None: ...
    def expunge_all(self) -> None: ...
    def bind_mapper(self, mapper: _EntityBindKey[_O], bind: _SessionBind) -> None: ...
    def bind_table(self, table: TableClause, bind: _SessionBind) -> None: ...
    def get_bind(self, mapper: Optional[_EntityBindKey[_O]] = ..., *, clause: Optional[ClauseElement] = ..., bind: Optional[_SessionBind] = ..., _sa_skip_events: Optional[bool] = ..., _sa_skip_for_implicit_returning: bool = ..., **kw: Any) -> Union[Engine, Connection]: ...
    @overload
    def query(self, _entity: _EntityType[_O]) -> Query[_O]: ...
    @overload
    def query(self, _colexpr: TypedColumnsClauseRole[_T]) -> RowReturningQuery[Tuple[_T]]: ...
    @overload
    def query(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1]) -> RowReturningQuery[Tuple[_T0, _T1]]: ...
    @overload
    def query(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2]) -> RowReturningQuery[Tuple[_T0, _T1, _T2]]: ...
    @overload
    def query(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3]) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3]]: ...
    @overload
    def query(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4]) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4]]: ...
    @overload
    def query(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5]) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4, _T5]]: ...
    @overload
    def query(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5], __ent6: _TCCA[_T6]) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6]]: ...
    @overload
    def query(self, __ent0: _TCCA[_T0], __ent1: _TCCA[_T1], __ent2: _TCCA[_T2], __ent3: _TCCA[_T3], __ent4: _TCCA[_T4], __ent5: _TCCA[_T5], __ent6: _TCCA[_T6], __ent7: _TCCA[_T7]) -> RowReturningQuery[Tuple[_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7]]: ...
    @overload
    def query(self, *entities: _ColumnsClauseArgument[Any], **kwargs: Any) -> Query[Any]: ...
    def no_autoflush(self) -> Iterator[Session]: ...
    def refresh(self, instance: object, attribute_names: Optional[Iterable[str]] = ..., with_for_update: ForUpdateParameter = ...) -> None: ...
    def expire_all(self) -> None: ...
    def expire(self, instance: object, attribute_names: Optional[Iterable[str]] = ...) -> None: ...
    def expunge(self, instance: object) -> None: ...
    def add(self, instance: object, _warn: bool = ...) -> None: ...
    def add_all(self, instances: Iterable[object]) -> None: ...
    def delete(self, instance: object) -> None: ...
    def get(self, entity: _EntityBindKey[_O], ident: _PKIdentityArgument, *, options: Optional[Sequence[ORMOption]] = ..., populate_existing: bool = ..., with_for_update: ForUpdateParameter = ..., identity_token: Optional[Any] = ..., execution_options: OrmExecuteOptionsParameter = ..., bind_arguments: Optional[_BindArguments] = ...) -> Optional[_O]: ...
    def get_one(self, entity: _EntityBindKey[_O], ident: _PKIdentityArgument, *, options: Optional[Sequence[ORMOption]] = ..., populate_existing: bool = ..., with_for_update: ForUpdateParameter = ..., identity_token: Optional[Any] = ..., execution_options: OrmExecuteOptionsParameter = ..., bind_arguments: Optional[_BindArguments] = ...) -> _O: ...
    def merge(self, instance: _O, *, load: bool = ..., options: Optional[Sequence[ORMOption]] = ...) -> _O: ...
    def enable_relationship_loading(self, obj: object) -> None: ...
    def __contains__(self, instance: object) -> bool: ...
    def __iter__(self) -> Iterator[object]: ...
    def flush(self, objects: Optional[Sequence[Any]] = ...) -> None: ...
    def bulk_save_objects(self, objects: Iterable[object], return_defaults: bool = ..., update_changed_only: bool = ..., preserve_order: bool = ...) -> None: ...
    def bulk_insert_mappings(self, mapper: Mapper[Any], mappings: Iterable[Dict[str, Any]], return_defaults: bool = ..., render_nulls: bool = ...) -> None: ...
    def bulk_update_mappings(self, mapper: Mapper[Any], mappings: Iterable[Dict[str, Any]]) -> None: ...
    def is_modified(self, instance: object, include_collections: bool = ...) -> bool: ...
    @property
    def is_active(self) -> bool: ...
    @property
    def dirty(self) -> IdentitySet: ...
    @property
    def deleted(self) -> IdentitySet: ...
    @property
    def new(self) -> IdentitySet: ...

class sessionmaker(_SessionClassMethods, Generic[_S]):
    class_: Type[_S]
    @overload
    def __init__(self, bind: Optional[_SessionBind] = ..., *, class_: Type[_S], autoflush: bool = ..., expire_on_commit: bool = ..., info: Optional[_InfoType] = ..., **kw: Any) -> None: ...
    @overload
    def __init__(self, bind: Optional[_SessionBind] = ..., *, autoflush: bool = ..., expire_on_commit: bool = ..., info: Optional[_InfoType] = ..., **kw: Any) -> None: ...
    def begin(self) -> contextlib.AbstractContextManager[_S]: ...
    def __call__(self, **local_kw: Any) -> _S: ...
    def configure(self, **new_kw: Any) -> None: ...

def close_all_sessions() -> None: ...
def make_transient(instance: object) -> None: ...
def make_transient_to_detached(instance: object) -> None: ...
def object_session(instance: object) -> Optional[Session]: ...
