from ..util.typing import Protocol
from .attributes import AttributeEventToken, CollectionAttributeImpl
from .mapped_collection import KeyFuncDict as KeyFuncDict, attribute_keyed_dict as attribute_keyed_dict, column_keyed_dict as column_keyed_dict, keyfunc_mapping as keyfunc_mapping
from .state import InstanceState
from _typeshed import Incomplete
from typing import Any, Collection, Dict, Iterable, List, Optional, Set

class _CollectionConverterProtocol(Protocol):
    def __call__(self, collection: _COL) -> _COL: ...

class _AdaptedCollectionProtocol(Protocol): ...

class collection:
    @staticmethod
    def appender(fn): ...
    @staticmethod
    def remover(fn): ...
    @staticmethod
    def iterator(fn): ...
    @staticmethod
    def internally_instrumented(fn): ...
    @staticmethod
    def converter(fn): ...
    @staticmethod
    def adds(arg): ...
    @staticmethod
    def replaces(arg): ...
    @staticmethod
    def removes(arg): ...
    @staticmethod
    def removes_return(): ...

def collection_adapter(collection: Collection[Any]) -> CollectionAdapter: ...

class CollectionAdapter:
    attr: CollectionAttributeImpl
    owner_state: InstanceState[Any]
    invalidated: bool
    empty: bool
    def __init__(self, attr: CollectionAttributeImpl, owner_state: InstanceState[Any], data: _AdaptedCollectionProtocol) -> None: ...
    @property
    def data(self) -> _AdaptedCollectionProtocol: ...
    def bulk_appender(self): ...
    def append_with_event(self, item: Any, initiator: Optional[AttributeEventToken] = ...) -> None: ...
    def append_without_event(self, item: Any) -> None: ...
    def append_multiple_without_event(self, items: Iterable[Any]) -> None: ...
    def bulk_remover(self): ...
    def remove_with_event(self, item: Any, initiator: Optional[AttributeEventToken] = ...) -> None: ...
    def remove_without_event(self, item: Any) -> None: ...
    def clear_with_event(self, initiator: Optional[AttributeEventToken] = ...) -> None: ...
    def clear_without_event(self) -> None: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def fire_append_wo_mutation_event(self, item, initiator: Incomplete | None = ..., key=...): ...
    def fire_append_event(self, item, initiator: Incomplete | None = ..., key=...): ...
    def fire_remove_event(self, item, initiator: Incomplete | None = ..., key=...) -> None: ...
    def fire_pre_remove_event(self, initiator: Incomplete | None = ..., key=...) -> None: ...

class InstrumentedList(List[_T]): ...
class InstrumentedSet(Set[_T]): ...
class InstrumentedDict(Dict[_KT, _VT]): ...

# Names in __all__ with no definition:
#   MappedCollection
