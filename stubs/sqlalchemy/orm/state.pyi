import weakref
from . import base as base, interfaces as interfaces
from .. import inspection as inspection, util as util
from ..engine import Row as Row
from ..ext.asyncio.session import AsyncSession as AsyncSession
from ..util.typing import Literal as Literal, Protocol as Protocol
from ._typing import _IdentityKeyType, _InstanceDict, _O, is_collection_impl as is_collection_impl
from .attributes import AttributeImpl as AttributeImpl, History as History
from .base import ATTR_WAS_SET as ATTR_WAS_SET, INIT_OK as INIT_OK, LoaderCallableStatus as LoaderCallableStatus, NEVER_SET as NEVER_SET, NO_VALUE as NO_VALUE, PASSIVE_NO_INITIALIZE as PASSIVE_NO_INITIALIZE, PASSIVE_NO_RESULT as PASSIVE_NO_RESULT, PASSIVE_OFF as PASSIVE_OFF, PassiveFlag as PassiveFlag, SQL_OK as SQL_OK
from .identity import IdentityMap as IdentityMap
from .instrumentation import ClassManager as ClassManager
from .interfaces import ORMOption as ORMOption
from .mapper import Mapper as Mapper
from .path_registry import PathRegistry as PathRegistry
from .session import Session as Session
from _typeshed import Incomplete
from typing import Any, Callable, Dict, Generic, Iterable, Optional, Set, Tuple, Union

class _InstanceDictProto(Protocol):
    def __call__(self) -> Optional[IdentityMap]: ...

class _InstallLoaderCallableProto(Protocol[_O]):
    def __call__(self, state: InstanceState[_O], dict_: _InstanceDict, row: Row[Any]) -> None: ...

class InstanceState(interfaces.InspectionAttrInfo, Generic[_O]):
    manager: ClassManager[_O]
    session_id: Optional[int]
    key: Optional[_IdentityKeyType[_O]]
    runid: Optional[int]
    load_options: Tuple[ORMOption, ...]
    load_path: PathRegistry
    insert_order: Optional[int]
    obj: weakref.ref[_O]
    committed_state: Dict[str, Any]
    modified: bool
    expired: bool
    is_instance: bool
    identity_token: object
    expired_attributes: Set[str]
    callables: Dict[str, Callable[[InstanceState[_O], PassiveFlag], Any]]
    class_: Incomplete
    def __init__(self, obj: _O, manager: ClassManager[_O]) -> None: ...
    def attrs(self) -> util.ReadOnlyProperties[AttributeState]: ...
    @property
    def transient(self) -> bool: ...
    @property
    def pending(self) -> bool: ...
    @property
    def deleted(self) -> bool: ...
    @property
    def was_deleted(self) -> bool: ...
    @property
    def persistent(self) -> bool: ...
    @property
    def detached(self) -> bool: ...
    @property
    def session(self) -> Optional[Session]: ...
    @property
    def async_session(self) -> Optional[AsyncSession]: ...
    @property
    def object(self) -> Optional[_O]: ...
    @property
    def identity(self) -> Optional[Tuple[Any, ...]]: ...
    @property
    def identity_key(self) -> Optional[_IdentityKeyType[_O]]: ...
    def parents(self) -> Dict[int, Union[Literal[False], InstanceState[Any]]]: ...
    def mapper(self) -> Mapper[_O]: ...
    @property
    def has_identity(self) -> bool: ...
    @property
    def dict(self) -> _InstanceDict: ...
    def get_history(self, key: str, passive: PassiveFlag) -> History: ...
    def get_impl(self, key: str) -> AttributeImpl: ...
    @property
    def unmodified(self) -> Set[str]: ...
    def unmodified_intersection(self, keys: Iterable[str]) -> Set[str]: ...
    @property
    def unloaded(self) -> Set[str]: ...
    @property
    def unloaded_expirable(self) -> Set[str]: ...

class AttributeState:
    state: InstanceState[Any]
    key: str
    def __init__(self, state: InstanceState[Any], key: str) -> None: ...
    @property
    def loaded_value(self) -> Any: ...
    @property
    def value(self) -> Any: ...
    @property
    def history(self) -> History: ...
    def load_history(self) -> History: ...

class PendingCollection:
    deleted_items: util.IdentitySet
    added_items: util.OrderedIdentitySet
    def __init__(self) -> None: ...
    def merge_with_history(self, history: History) -> History: ...
    def append(self, value: Any) -> None: ...
    def remove(self, value: Any) -> None: ...
