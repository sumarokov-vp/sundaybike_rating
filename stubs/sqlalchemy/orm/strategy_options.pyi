from .. import inspect as inspect, util as util
from ..sql import and_ as and_, cache_key as cache_key, coercions as coercions, roles as roles, traversals as traversals, visitors as visitors
from ..sql._typing import _ColumnExpressionArgument, _FromClauseArgument
from ..sql.cache_key import CacheKey as CacheKey, _CacheKeyTraversalType
from ..util.typing import Final as Final, Literal as Literal, Self as Self
from ._typing import _EntityType, _InternalEntityType, insp_is_aliased_class as insp_is_aliased_class, insp_is_attribute as insp_is_attribute, insp_is_mapper as insp_is_mapper, insp_is_mapper_property as insp_is_mapper_property
from .attributes import QueryableAttribute as QueryableAttribute
from .base import InspectionAttr as InspectionAttr
from .context import ORMCompileState as ORMCompileState, QueryContext as QueryContext, _MapperEntity
from .interfaces import LoaderOption as LoaderOption, MapperProperty as MapperProperty, ORMOption as ORMOption, _StrategyKey
from .mapper import Mapper as Mapper
from .path_registry import AbstractEntityRegistry as AbstractEntityRegistry, PathRegistry as PathRegistry, TokenRegistry as TokenRegistry, _StrPathToken, path_is_property as path_is_property
from .util import AliasedInsp as AliasedInsp
from typing import Any, Iterable, Optional, Sequence, Tuple, Type, Union

class _AbstractLoad(traversals.GenerativeOnTraversal, LoaderOption):
    propagate_to_loaders: bool
    def contains_eager(self, attr: _AttrType, alias: Optional[_FromClauseArgument] = ..., _is_chain: bool = ...) -> Self: ...
    def load_only(self, *attrs: _AttrType, raiseload: bool = ...) -> Self: ...
    def joinedload(self, attr: _AttrType, innerjoin: Optional[bool] = ...) -> Self: ...
    def subqueryload(self, attr: _AttrType) -> Self: ...
    def selectinload(self, attr: _AttrType, recursion_depth: Optional[int] = ...) -> Self: ...
    def lazyload(self, attr: _AttrType) -> Self: ...
    def immediateload(self, attr: _AttrType, recursion_depth: Optional[int] = ...) -> Self: ...
    def noload(self, attr: _AttrType) -> Self: ...
    def raiseload(self, attr: _AttrType, sql_only: bool = ...) -> Self: ...
    def defaultload(self, attr: _AttrType) -> Self: ...
    def defer(self, key: _AttrType, raiseload: bool = ...) -> Self: ...
    def undefer(self, key: _AttrType) -> Self: ...
    def undefer_group(self, name: str) -> Self: ...
    def with_expression(self, key: _AttrType, expression: _ColumnExpressionArgument[Any]) -> Self: ...
    def selectin_polymorphic(self, classes: Iterable[Type[Any]]) -> Self: ...
    def options(self, *opts: _AbstractLoad) -> Self: ...
    def process_compile_state_replaced_entities(self, compile_state: ORMCompileState, mapper_entities: Sequence[_MapperEntity]) -> None: ...
    def process_compile_state(self, compile_state: ORMCompileState) -> None: ...

class Load(_AbstractLoad):
    path: PathRegistry
    context: Tuple[_LoadElement, ...]
    additional_source_entities: Tuple[_InternalEntityType[Any], ...]
    propagate_to_loaders: bool
    def __init__(self, entity: _EntityType[Any]) -> None: ...
    def options(self, *opts: _AbstractLoad) -> Self: ...

class _WildcardLoad(_AbstractLoad):
    cache_key_traversal: _CacheKeyTraversalType
    strategy: Optional[Tuple[Any, ...]]
    local_opts: _OptsType
    path: Union[Tuple, Tuple[str]]
    propagate_to_loaders: bool
    def __init__(self) -> None: ...
    def options(self, *opts: _AbstractLoad) -> Self: ...

class _LoadElement(cache_key.HasCacheKey, traversals.HasShallowCopy, visitors.Traversible):
    __visit_name__: str
    strategy: Optional[_StrategyKey]
    path: PathRegistry
    propagate_to_loaders: bool
    local_opts: util.immutabledict[str, Any]
    is_token_strategy: bool
    is_class_strategy: bool
    def __hash__(self) -> int: ...
    def __eq__(self, other): ...
    @property
    def is_opts_only(self) -> bool: ...
    def process_compile_state(self, parent_loader, compile_state, mapper_entities, reconciled_lead_entity, raiseerr) -> None: ...
    @classmethod
    def create(cls, path: PathRegistry, attr: Union[_AttrType, _StrPathToken, None], strategy: Optional[_StrategyKey], wildcard_key: Optional[_WildcardKeyType], local_opts: Optional[_OptsType], propagate_to_loaders: bool, raiseerr: bool = ..., attr_group: Optional[_AttrGroupType] = ..., reconcile_to_other: Optional[bool] = ..., extra_criteria: Optional[Tuple[Any, ...]] = ...) -> _LoadElement: ...
    def __init__(self) -> None: ...

class _AttributeStrategyLoad(_LoadElement):
    __visit_name__: str
    is_class_strategy: bool
    is_token_strategy: bool

class _TokenStrategyLoad(_LoadElement):
    __visit_name__: str
    inherit_cache: bool
    is_class_strategy: bool
    is_token_strategy: bool

class _ClassStrategyLoad(_LoadElement):
    inherit_cache: bool
    is_class_strategy: bool
    is_token_strategy: bool
    __visit_name__: str

def loader_unbound_fn(fn: _FN) -> _FN: ...
def contains_eager(*keys: _AttrType, **kw: Any) -> _AbstractLoad: ...
def load_only(*attrs: _AttrType, raiseload: bool = ...) -> _AbstractLoad: ...
def joinedload(*keys: _AttrType, **kw: Any) -> _AbstractLoad: ...
def subqueryload(*keys: _AttrType) -> _AbstractLoad: ...
def selectinload(*keys: _AttrType, recursion_depth: Optional[int] = ...) -> _AbstractLoad: ...
def lazyload(*keys: _AttrType) -> _AbstractLoad: ...
def immediateload(*keys: _AttrType, recursion_depth: Optional[int] = ...) -> _AbstractLoad: ...
def noload(*keys: _AttrType) -> _AbstractLoad: ...
def raiseload(*keys: _AttrType, **kw: Any) -> _AbstractLoad: ...
def defaultload(*keys: _AttrType) -> _AbstractLoad: ...
def defer(key: _AttrType, *addl_attrs: _AttrType, raiseload: bool = ...) -> _AbstractLoad: ...
def undefer(key: _AttrType, *addl_attrs: _AttrType) -> _AbstractLoad: ...
def undefer_group(name: str) -> _AbstractLoad: ...
def with_expression(key: _AttrType, expression: _ColumnExpressionArgument[Any]) -> _AbstractLoad: ...
def selectin_polymorphic(base_cls: _EntityType[Any], classes: Iterable[Type[Any]]) -> _AbstractLoad: ...
