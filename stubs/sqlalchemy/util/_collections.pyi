import types
import typing
from ._has_cy import HAS_CYEXTENSION as HAS_CYEXTENSION
from ._py_collections import IdentitySet as IdentitySet, ImmutableDictBase as ImmutableDictBase, OrderedSet as OrderedSet, ReadOnlyContainer as ReadOnlyContainer, immutabledict as immutabledict
from .typing import Literal as Literal, Protocol as Protocol
from _typeshed import Incomplete
from typing import Any, Callable, Dict, FrozenSet, Generic, Iterable, Iterator, List, Mapping, NoReturn, Optional, Sequence, Set, Tuple, Union, ValuesView, overload

EMPTY_SET: FrozenSet[Any]
NONE_SET: FrozenSet[Any]

def merge_lists_w_ordering(a: List[Any], b: List[Any]) -> List[Any]: ...
def coerce_to_immutabledict(d: Mapping[_KT, _VT]) -> immutabledict[_KT, _VT]: ...

EMPTY_DICT: immutabledict[Any, Any]

class FacadeDict(ImmutableDictBase[_KT, _VT]):
    def __new__(cls, *args: Any) -> FacadeDict[Any, Any]: ...
    def copy(self) -> NoReturn: ...
    def __reduce__(self) -> Any: ...

class Properties(Generic[_T]):
    def __init__(self, data: Dict[str, _T]) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_T]: ...
    def __dir__(self) -> List[str]: ...
    def __add__(self, other: Properties[_F]) -> List[Union[_T, _F]]: ...
    def __setitem__(self, key: str, obj: _T) -> None: ...
    def __getitem__(self, key: str) -> _T: ...
    def __delitem__(self, key: str) -> None: ...
    def __setattr__(self, key: str, obj: _T) -> None: ...
    def __getattr__(self, key: str) -> _T: ...
    def __contains__(self, key: str) -> bool: ...
    def as_readonly(self) -> ReadOnlyProperties[_T]: ...
    def update(self, value: Dict[str, _T]) -> None: ...
    @overload
    def get(self, key: str) -> Optional[_T]: ...
    @overload
    def get(self, key: str, default: Union[_DT, _T]) -> Union[_DT, _T]: ...
    def keys(self) -> List[str]: ...
    def values(self) -> List[_T]: ...
    def items(self) -> List[Tuple[str, _T]]: ...
    def has_key(self, key: str) -> bool: ...
    def clear(self) -> None: ...

class OrderedProperties(Properties[_T]):
    def __init__(self) -> None: ...

class ReadOnlyProperties(ReadOnlyContainer, Properties[_T]): ...
OrderedDict = dict
sort_dictionary: Incomplete

class WeakSequence(Sequence[_T]):
    def __init__(self, __elements: Sequence[_T] = ...) -> None: ...
    def append(self, item) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def __getitem__(self, index): ...

class OrderedIdentitySet(IdentitySet):
    def __init__(self, iterable: Optional[Iterable[Any]] = ...) -> None: ...

class PopulateDict(Dict[_KT, _VT]):
    creator: Incomplete
    def __init__(self, creator: Callable[[_KT], _VT]) -> None: ...
    def __missing__(self, key: Any) -> Any: ...

class WeakPopulateDict(Dict[_KT, _VT]):
    creator: Incomplete
    weakself: Incomplete
    def __init__(self, creator_method: types.MethodType) -> None: ...
    def __missing__(self, key: Any) -> Any: ...
column_set = set
column_dict = dict
ordered_column_set = OrderedSet

class UniqueAppender(Generic[_T]):
    data: Union[Iterable[_T], Set[_T], List[_T]]
    def __init__(self, data: Union[Iterable[_T], Set[_T], List[_T]], via: Optional[str] = ...) -> None: ...
    def append(self, item: _T) -> None: ...
    def __iter__(self) -> Iterator[_T]: ...

def coerce_generator_arg(arg: Any) -> List[Any]: ...
def to_list(x: Any, default: Optional[List[Any]] = ...) -> List[Any]: ...
def has_intersection(set_, iterable): ...
def to_set(x): ...
def to_column_set(x: Any) -> Set[Any]: ...
def update_copy(d, _new: Incomplete | None = ..., **kw): ...
def flatten_iterator(x: Iterable[_T]) -> Iterator[_T]: ...

class LRUCache(typing.MutableMapping[_KT, _VT]):
    capacity: int
    threshold: float
    size_alert: Optional[Callable[[LRUCache[_KT, _VT]], None]]
    def __init__(self, capacity: int = ..., threshold: float = ..., size_alert: Optional[Callable[..., None]] = ...) -> None: ...
    @overload
    def get(self, key: _KT) -> Optional[_VT]: ...
    @overload
    def get(self, key: _KT, default: Union[_VT, _T]) -> Union[_VT, _T]: ...
    def __getitem__(self, key: _KT) -> _VT: ...
    def __iter__(self) -> Iterator[_KT]: ...
    def __len__(self) -> int: ...
    def values(self) -> ValuesView[_VT]: ...
    def __setitem__(self, key: _KT, value: _VT) -> None: ...
    def __delitem__(self, __v: _KT) -> None: ...
    @property
    def size_threshold(self) -> float: ...

class _CreateFuncType(Protocol[_T_co]):
    def __call__(self) -> _T_co: ...

class _ScopeFuncType(Protocol):
    def __call__(self) -> Any: ...

class ScopedRegistry(Generic[_T]):
    createfunc: _CreateFuncType[_T]
    scopefunc: _ScopeFuncType
    registry: Any
    def __init__(self, createfunc: Callable[[], _T], scopefunc: Callable[[], Any]) -> None: ...
    def __call__(self) -> _T: ...
    def has(self) -> bool: ...
    def set(self, obj: _T) -> None: ...
    def clear(self) -> None: ...

class ThreadLocalRegistry(ScopedRegistry[_T]):
    createfunc: Incomplete
    registry: Incomplete
    def __init__(self, createfunc: Callable[[], _T]) -> None: ...
    def __call__(self) -> _T: ...
    def has(self) -> bool: ...
    def set(self, obj: _T) -> None: ...
    def clear(self) -> None: ...

def has_dupes(sequence, target): ...
