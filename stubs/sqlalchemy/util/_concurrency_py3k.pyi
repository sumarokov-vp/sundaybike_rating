import asyncio
from .. import exc as exc
from ..util.typing import Protocol as Protocol, TypeGuard as TypeGuard
from .langhelpers import memoized_property as memoized_property
from _typeshed import Incomplete
from contextvars import Context
from typing import Any, Awaitable, Callable, Coroutine, Optional

class greenlet(Protocol):
    dead: bool
    gr_context: Optional[Context]
    def __init__(self, fn: Callable[..., Any], driver: greenlet) -> None: ...
    def throw(self, *arg: Any) -> Any: ...
    def switch(self, value: Any) -> Any: ...

def getcurrent() -> greenlet: ...
def is_exit_exception(e: BaseException) -> bool: ...

class _AsyncIoGreenlet(greenlet):
    dead: bool
    driver: Incomplete
    gr_context: Incomplete
    def __init__(self, fn: Callable[..., Any], driver: greenlet) -> None: ...

def iscoroutine(awaitable: Awaitable[_T_co]) -> TypeGuard[Coroutine[Any, Any, _T_co]]: ...
def await_only(awaitable: Awaitable[_T]) -> _T: ...
def await_fallback(awaitable: Awaitable[_T]) -> _T: ...
async def greenlet_spawn(fn: Callable[..., _T], *args: Any, _require_await: bool = ..., **kwargs: Any) -> _T: ...

class AsyncAdaptedLock:
    def mutex(self) -> asyncio.Lock: ...
    def __enter__(self) -> bool: ...
    def __exit__(self, *arg: Any, **kw: Any) -> None: ...

def get_event_loop() -> asyncio.AbstractEventLoop: ...
