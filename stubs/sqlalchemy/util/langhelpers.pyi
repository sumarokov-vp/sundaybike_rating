import re
import types
from . import compat as compat
from .. import exc as exc
from ._has_cy import HAS_CYEXTENSION as HAS_CYEXTENSION
from .typing import Literal as Literal
from _typeshed import Incomplete
from collections.abc import Generator
from enum import IntFlag
from typing import Any, Callable, Dict, Generic, Iterator, List, Mapping, NoReturn, Optional, Sequence, Set, Tuple, Type, Union, overload

def get_annotations(obj: Any) -> Mapping[str, Any]: ...
def md5_hex(x: Any) -> str: ...

class safe_reraise:
    def __enter__(self) -> None: ...
    def __exit__(self, type_: Optional[Type[BaseException]], value: Optional[BaseException], traceback: Optional[types.TracebackType]) -> NoReturn: ...

def walk_subclasses(cls) -> Iterator[Type[_T]]: ...
def string_or_unprintable(element: Any) -> str: ...
def clsname_as_plain_name(cls) -> str: ...
def method_is_overridden(instance_or_cls: Union[Type[Any], object], against_method: Callable[..., Any]) -> bool: ...
def decode_slice(slc: slice) -> Tuple[Any, ...]: ...
def map_bits(fn: Callable[[int], Any], n: int) -> Iterator[Any]: ...
def decorator(target: Callable[..., Any]) -> Callable[[_Fn], _Fn]: ...

class PluginLoader:
    group: Incomplete
    impls: Incomplete
    auto_fn: Incomplete
    def __init__(self, group: str, auto_fn: Optional[Callable[..., Any]] = ...) -> None: ...
    def clear(self) -> None: ...
    def load(self, name: str) -> Any: ...
    def register(self, name: str, modulepath: str, objname: str) -> None: ...

@overload
def get_cls_kwargs(cls, *, _set: Optional[Set[str]] = ..., raiseerr: Literal[True] = ...) -> Set[str]: ...
@overload
def get_cls_kwargs(cls, *, _set: Optional[Set[str]] = ..., raiseerr: bool = ...) -> Optional[Set[str]]: ...
def get_func_kwargs(func: Callable[..., Any]) -> List[str]: ...
def get_callable_argspec(fn: Callable[..., Any], no_self: bool = ..., _is_init: bool = ...) -> compat.FullArgSpec: ...
def format_argspec_plus(fn: Union[Callable[..., Any], compat.FullArgSpec], grouped: bool = ...) -> Dict[str, Optional[str]]: ...
def format_argspec_init(method, grouped: bool = ...): ...
def create_proxy_methods(target_cls: Type[Any], target_cls_sphinx_name: str, proxy_cls_sphinx_name: str, classmethods: Sequence[str] = ..., methods: Sequence[str] = ..., attributes: Sequence[str] = ..., use_intermediate_variable: Sequence[str] = ...) -> Callable[[_T], _T]: ...
def getargspec_init(method): ...
def unbound_method_to_callable(func_or_cls): ...
def generic_repr(obj: Any, additional_kw: Sequence[Tuple[str, Any]] = ..., to_inspect: Optional[Union[object, List[object]]] = ..., omit_kwarg: Sequence[str] = ...) -> str: ...

class portable_instancemethod:
    target: Incomplete
    name: Incomplete
    kwargs: Incomplete
    def __init__(self, meth, kwargs=...) -> None: ...
    def __call__(self, *arg, **kw): ...

def class_hierarchy(cls): ...
def iterate_attributes(cls) -> Generator[Incomplete, None, None]: ...
def monkeypatch_proxied_specials(into_cls, from_cls, skip: Incomplete | None = ..., only: Incomplete | None = ..., name: str = ..., from_instance: Incomplete | None = ...) -> None: ...
def methods_equivalent(meth1, meth2): ...
def as_interface(obj, cls: Incomplete | None = ..., methods: Incomplete | None = ..., required: Incomplete | None = ...): ...

class generic_fn_descriptor(Generic[_T_co]):
    fget: Callable[..., _T_co]
    __doc__: Optional[str]
    def __init__(self, fget: Callable[..., _T_co], doc: Optional[str] = ...) -> None: ...
    @overload
    def __get__(self, obj: None, cls: Any) -> _GFD: ...
    @overload
    def __get__(self, obj: object, cls: Any) -> _T_co: ...
    def __set__(self, instance: Any, value: Any) -> None: ...
    def __delete__(self, instance: Any) -> None: ...
    @classmethod
    def reset(cls, obj: Any, name: str) -> None: ...

class _non_memoized_property(generic_fn_descriptor[_T_co]): ...

class _memoized_property(generic_fn_descriptor[_T_co]):
    @classmethod
    def reset(cls, obj, name) -> None: ...
memoized_property = generic_fn_descriptor
non_memoized_property = generic_fn_descriptor
ro_memoized_property = property
ro_non_memoized_property = property

def memoized_instancemethod(fn: _F) -> _F: ...

class HasMemoized:
    class memoized_attribute(memoized_property[_T]):
        fget: Callable[..., _T]
        __doc__: Optional[str]
        def __init__(self, fget: Callable[..., _T], doc: Optional[str] = ...) -> None: ...
        @overload
        def __get__(self, obj: None, cls: Any) -> _MA: ...
        @overload
        def __get__(self, obj: Any, cls: Any) -> _T: ...
    @classmethod
    def memoized_instancemethod(cls, fn: _F) -> _F: ...
HasMemoized_ro_memoized_attribute = property

class MemoizedSlots:
    def __getattr__(self, key: str) -> Any: ...

def asbool(obj: Any) -> bool: ...
def bool_or_str(*text: str) -> Callable[[str], Union[str, bool]]: ...
def asint(value: Any) -> Optional[int]: ...
def coerce_kw_type(kw: Dict[str, Any], key: str, type_: Type[Any], flexi_bool: bool = ..., dest: Optional[Dict[str, Any]] = ...) -> None: ...
def constructor_key(obj: Any, cls: Type[Any]) -> Tuple[Any, ...]: ...
def constructor_copy(obj: _T, cls: Type[_T], *args: Any, **kw: Any) -> _T: ...
def counter() -> Callable[[], int]: ...
def duck_type_collection(specimen: Any, default: Optional[Type[Any]] = ...) -> Optional[Type[Any]]: ...
def assert_arg_type(arg: Any, argtype: Union[Tuple[Type[Any], ...], Type[Any]], name: str) -> Any: ...
def dictlike_iteritems(dictlike): ...

class classproperty(property):
    fget: Callable[[Any], Any]
    __doc__: Incomplete
    def __init__(self, fget: Callable[[Any], Any], *arg: Any, **kw: Any) -> None: ...
    def __get__(self, obj: Any, cls: Optional[type] = ...) -> Any: ...

class hybridproperty(Generic[_T]):
    func: Incomplete
    clslevel: Incomplete
    def __init__(self, func: Callable[..., _T]) -> None: ...
    def __get__(self, instance: Any, owner: Any) -> _T: ...
    def classlevel(self, func: Callable[..., Any]) -> hybridproperty[_T]: ...

class rw_hybridproperty(Generic[_T]):
    func: Incomplete
    clslevel: Incomplete
    setfn: Incomplete
    def __init__(self, func: Callable[..., _T]) -> None: ...
    def __get__(self, instance: Any, owner: Any) -> _T: ...
    def __set__(self, instance: Any, value: Any) -> None: ...
    def setter(self, func: Callable[..., Any]) -> rw_hybridproperty[_T]: ...
    def classlevel(self, func: Callable[..., Any]) -> rw_hybridproperty[_T]: ...

class hybridmethod(Generic[_T]):
    func: Incomplete
    clslevel: Incomplete
    def __init__(self, func: Callable[..., _T]) -> None: ...
    def __get__(self, instance: Any, owner: Any) -> Callable[..., _T]: ...
    def classlevel(self, func: Callable[..., Any]) -> hybridmethod[_T]: ...

class symbol(int):
    name: str
    symbols: Dict[str, symbol]
    def __new__(cls, name: str, doc: Optional[str] = ..., canonical: Optional[int] = ...) -> symbol: ...
    def __reduce__(self): ...

class _IntFlagMeta(type):
    def __init__(cls, classname: str, bases: Tuple[Type[Any], ...], dict_: Dict[str, Any], **kw: Any) -> None: ...
    def __iter__(self) -> Iterator[symbol]: ...

class _FastIntFlag(metaclass=_IntFlagMeta): ...
FastIntFlag = IntFlag

def parse_user_argument_for_enum(arg: Any, choices: Dict[_E, List[Any]], name: str, resolve_symbol_names: bool = ...) -> Optional[_E]: ...
def set_creation_order(instance: Any) -> None: ...
def warn_exception(func: Callable[..., Any], *args: Any, **kwargs: Any) -> Any: ...
def ellipses_string(value, len_: int = ...): ...

class _hash_limit_string(str):
    def __new__(cls, value: str, num: int, args: Sequence[Any]) -> _hash_limit_string: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...

def warn(msg: str, code: Optional[str] = ...) -> None: ...
def warn_limited(msg: str, args: Sequence[Any]) -> None: ...
def tag_method_for_warnings(message: str, category: Type[Warning]) -> Callable[[_F], _F]: ...
def only_once(fn: Callable[..., _T], retry_on_exception: bool) -> Callable[..., Optional[_T]]: ...
def chop_traceback(tb: List[str], exclude_prefix: re.Pattern[str] = ..., exclude_suffix: re.Pattern[str] = ...) -> List[str]: ...

NoneType: Incomplete

def attrsetter(attrname): ...

class TypingOnly:
    def __init_subclass__(cls) -> None: ...

class EnsureKWArg:
    ensure_kwarg: str
    def __init_subclass__(cls) -> None: ...

def wrap_callable(wrapper, fn): ...
def quoted_token_parser(value): ...
def add_parameter_text(params: Any, text: str) -> Callable[[_F], _F]: ...
def inject_docstring_text(given_doctext: Optional[str], injecttext: str, pos: int) -> str: ...
def inject_param_text(doctext: str, inject_params: Dict[str, str]) -> str: ...
def repr_tuple_names(names: List[str]) -> Optional[str]: ...
def has_compiled_ext(raise_: bool = ...): ...
