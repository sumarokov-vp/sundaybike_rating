from . import compat as compat
from _typeshed import Incomplete
from typing import Any, Callable, ForwardRef, Generic, Iterable, Mapping, NewType, NoReturn, Optional, Set, Tuple, Type, Union, overload
from typing_extensions import Protocol as Protocol, TypeGuard as TypeGuard, get_args as get_args, get_origin as get_origin

NoneFwd: Incomplete
typing_get_args = get_args
typing_get_origin = get_origin

class ArgsTypeProcotol(Protocol):
    __args__: Tuple[_AnnotationScanType, ...]

class GenericProtocol(Protocol[_T]):
    __args__: Tuple[_AnnotationScanType, ...]
    __origin__: Type[_T]

class SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):
    def keys(self) -> Iterable[_KT]: ...
    def __getitem__(self, __k: _KT) -> _VT_co: ...

def de_stringify_annotation(cls, annotation: _AnnotationScanType, originating_module: str, locals_: Mapping[str, Any], *, str_cleanup_fn: Optional[Callable[[str, str], str]] = ..., include_generic: bool = ..., _already_seen: Optional[Set[Any]] = ...) -> Type[Any]: ...
def eval_expression(expression: str, module_name: str, *, locals_: Optional[Mapping[str, Any]] = ...) -> Any: ...
def eval_name_only(name: str, module_name: str, *, locals_: Optional[Mapping[str, Any]] = ...) -> Any: ...
def resolve_name_to_real_class_name(name: str, module_name: str) -> str: ...
def de_stringify_union_elements(cls, annotation: ArgsTypeProcotol, originating_module: str, locals_: Mapping[str, Any], *, str_cleanup_fn: Optional[Callable[[str, str], str]] = ...) -> Type[Any]: ...
def is_pep593(type_: Optional[_AnnotationScanType]) -> bool: ...
def is_literal(type_: _AnnotationScanType) -> bool: ...
def is_newtype(type_: Optional[_AnnotationScanType]) -> TypeGuard[NewType]: ...
def is_generic(type_: _AnnotationScanType) -> TypeGuard[GenericProtocol[Any]]: ...
def flatten_newtype(type_: NewType) -> Type[Any]: ...
def is_fwd_ref(type_: _AnnotationScanType, check_generic: bool = ...) -> TypeGuard[ForwardRef]: ...
@overload
def de_optionalize_union_types(type_: str) -> str: ...
@overload
def de_optionalize_union_types(type_: Type[Any]) -> Type[Any]: ...
@overload
def de_optionalize_union_types(type_: _AnnotationScanType) -> _AnnotationScanType: ...
def de_optionalize_fwd_ref_union_types(type_: ForwardRef) -> _AnnotationScanType: ...
def make_union_type(*types: _AnnotationScanType) -> Type[Any]: ...
def expand_unions(type_: Type[Any], include_union: bool = ..., discard_none: bool = ...) -> Tuple[Type[Any], ...]: ...
def is_optional(type_: Any) -> TypeGuard[ArgsTypeProcotol]: ...
def is_optional_union(type_: Any) -> bool: ...
def is_union(type_: Any) -> TypeGuard[ArgsTypeProcotol]: ...
def is_origin_of_cls(type_: Any, class_obj: Union[Tuple[Type[Any], ...], Type[Any]]) -> bool: ...
def is_origin_of(type_: Any, *names: str, module: Optional[str] = ...) -> bool: ...

class DescriptorProto(Protocol):
    def __get__(self, instance: object, owner: Any) -> Any: ...
    def __set__(self, instance: Any, value: Any) -> None: ...
    def __delete__(self, instance: Any) -> None: ...

class DescriptorReference(Generic[_DESC]):
    def __get__(self, instance: object, owner: Any) -> _DESC: ...
    def __set__(self, instance: Any, value: _DESC) -> None: ...
    def __delete__(self, instance: Any) -> None: ...

class RODescriptorReference(Generic[_DESC_co]):
    def __get__(self, instance: object, owner: Any) -> _DESC_co: ...
    def __set__(self, instance: Any, value: Any) -> NoReturn: ...
    def __delete__(self, instance: Any) -> NoReturn: ...

class CallableReference(Generic[_FN]):
    def __get__(self, instance: object, owner: Any) -> _FN: ...
    def __set__(self, instance: Any, value: _FN) -> None: ...
    def __delete__(self, instance: Any) -> None: ...
