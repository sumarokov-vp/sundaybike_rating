from ..util.typing import Self as Self
from typing import AbstractSet, Any, Callable, Dict, Iterable, Iterator, List, Mapping, NoReturn, Optional, Set, Tuple, Union

class ReadOnlyContainer:
    def __delitem__(self, key: Any) -> NoReturn: ...
    def __setitem__(self, key: Any, value: Any) -> NoReturn: ...
    def __setattr__(self, key: str, value: Any) -> NoReturn: ...

class ImmutableDictBase(ReadOnlyContainer, Dict[_KT, _VT]):
    def __new__(cls, *args: Any) -> Self: ...
    def __init__(cls, *args: Any) -> None: ...
    def clear(self) -> NoReturn: ...
    def pop(self, key: Any, default: Optional[Any] = ...) -> NoReturn: ...
    def popitem(self) -> NoReturn: ...
    def setdefault(self, key: Any, default: Optional[Any] = ...) -> NoReturn: ...
    def update(self, *arg: Any, **kw: Any) -> NoReturn: ...

class immutabledict(ImmutableDictBase[_KT, _VT]):
    def __new__(cls, *args): ...
    def __init__(self, *args: Union[Mapping[_KT, _VT], Iterable[Tuple[_KT, _VT]]]) -> None: ...
    def __reduce__(self): ...
    def union(self, __d: Optional[Mapping[_KT, _VT]] = ...) -> immutabledict[_KT, _VT]: ...
    def merge_with(self, *dicts: Optional[Mapping[_KT, _VT]]) -> immutabledict[_KT, _VT]: ...
    def __ior__(self, __value: Any) -> NoReturn: ...
    def __or__(self, __value: Mapping[_KT, _VT]) -> immutabledict[_KT, _VT]: ...
    def __ror__(self, __value: Mapping[_KT, _VT]) -> immutabledict[_KT, _VT]: ...

class OrderedSet(Set[_T]):
    def __init__(self, d: Optional[Iterable[_T]] = ...) -> None: ...
    def copy(self) -> OrderedSet[_T]: ...
    def add(self, element: _T) -> None: ...
    def remove(self, element: _T) -> None: ...
    def pop(self) -> _T: ...
    def insert(self, pos: int, element: _T) -> None: ...
    def discard(self, element: _T) -> None: ...
    def clear(self) -> None: ...
    def __getitem__(self, key: int) -> _T: ...
    def __iter__(self) -> Iterator[_T]: ...
    def __add__(self, other: Iterator[_T]) -> OrderedSet[_T]: ...
    def update(self, *iterables: Iterable[_T]) -> None: ...
    def __ior__(self, other: AbstractSet[_S]) -> OrderedSet[Union[_T, _S]]: ...
    def union(self, *other: Iterable[_S]) -> OrderedSet[Union[_T, _S]]: ...
    def __or__(self, other: AbstractSet[_S]) -> OrderedSet[Union[_T, _S]]: ...
    def intersection(self, *other: Iterable[Any]) -> OrderedSet[_T]: ...
    def __and__(self, other: AbstractSet[object]) -> OrderedSet[_T]: ...
    def symmetric_difference(self, other: Iterable[_T]) -> OrderedSet[_T]: ...
    def __xor__(self, other: AbstractSet[_S]) -> OrderedSet[Union[_T, _S]]: ...
    def difference(self, *other: Iterable[Any]) -> OrderedSet[_T]: ...
    def __sub__(self, other: AbstractSet[Optional[_T]]) -> OrderedSet[_T]: ...
    def intersection_update(self, *other: Iterable[Any]) -> None: ...
    def __iand__(self, other: AbstractSet[object]) -> OrderedSet[_T]: ...
    def symmetric_difference_update(self, other: Iterable[Any]) -> None: ...
    def __ixor__(self, other: AbstractSet[_S]) -> OrderedSet[Union[_T, _S]]: ...
    def difference_update(self, *other: Iterable[Any]) -> None: ...
    def __isub__(self, other: AbstractSet[Optional[_T]]) -> OrderedSet[_T]: ...

class IdentitySet:
    def __init__(self, iterable: Optional[Iterable[Any]] = ...) -> None: ...
    def add(self, value: Any) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def remove(self, value: Any) -> None: ...
    def discard(self, value: Any) -> None: ...
    def pop(self) -> Any: ...
    def clear(self) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def issubset(self, iterable: Iterable[Any]) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __lt__(self, other: Any) -> bool: ...
    def issuperset(self, iterable: Iterable[Any]) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...
    def union(self, iterable: Iterable[Any]) -> IdentitySet: ...
    def __or__(self, other: Any) -> IdentitySet: ...
    def update(self, iterable: Iterable[Any]) -> None: ...
    def __ior__(self, other: Any) -> IdentitySet: ...
    def difference(self, iterable: Iterable[Any]) -> IdentitySet: ...
    def __sub__(self, other: IdentitySet) -> IdentitySet: ...
    def difference_update(self, iterable: Iterable[Any]) -> None: ...
    def __isub__(self, other: IdentitySet) -> IdentitySet: ...
    def intersection(self, iterable: Iterable[Any]) -> IdentitySet: ...
    def __and__(self, other: IdentitySet) -> IdentitySet: ...
    def intersection_update(self, iterable: Iterable[Any]) -> None: ...
    def __iand__(self, other: IdentitySet) -> IdentitySet: ...
    def symmetric_difference(self, iterable: Iterable[Any]) -> IdentitySet: ...
    def __xor__(self, other: IdentitySet) -> IdentitySet: ...
    def symmetric_difference_update(self, iterable: Iterable[Any]) -> None: ...
    def __ixor__(self, other: IdentitySet) -> IdentitySet: ...
    def copy(self) -> IdentitySet: ...
    __copy__ = copy
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __hash__(self) -> NoReturn: ...

def unique_list(seq: Iterable[_T], hashfunc: Optional[Callable[[_T], int]] = ...) -> List[_T]: ...
