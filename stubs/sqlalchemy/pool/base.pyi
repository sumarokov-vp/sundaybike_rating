import dataclasses
import weakref
from .. import event as event, exc as exc, log as log, util as util
from ..engine.interfaces import DBAPIConnection as DBAPIConnection, DBAPICursor as DBAPICursor, Dialect as Dialect
from ..event import _DispatchCommon, _ListenerFnType, dispatcher as dispatcher
from ..sql._typing import _InfoType
from ..util.typing import Literal as Literal, Protocol as Protocol
from _typeshed import Incomplete
from enum import Enum
from typing import Any, Callable, Deque, List, Optional, Tuple, Union

@dataclasses.dataclass(frozen=True)
class PoolResetState:
    transaction_was_reset: bool
    terminate_only: bool
    asyncio_safe: bool
    def __init__(self, transaction_was_reset, terminate_only, asyncio_safe) -> None: ...

class ResetStyle(Enum):
    reset_rollback: int
    reset_commit: int
    reset_none: int

reset_rollback: Incomplete
reset_commit: Incomplete
reset_none: Incomplete

class _ConnDialect:
    is_async: bool
    has_terminate: bool
    def do_rollback(self, dbapi_connection: PoolProxiedConnection) -> None: ...
    def do_commit(self, dbapi_connection: PoolProxiedConnection) -> None: ...
    def do_terminate(self, dbapi_connection: DBAPIConnection) -> None: ...
    def do_close(self, dbapi_connection: DBAPIConnection) -> None: ...
    def get_driver_connection(self, connection: DBAPIConnection) -> Any: ...

class _AsyncConnDialect(_ConnDialect):
    is_async: bool

class _CreatorFnType(Protocol):
    def __call__(self) -> DBAPIConnection: ...

class _CreatorWRecFnType(Protocol):
    def __call__(self, rec: ConnectionPoolEntry) -> DBAPIConnection: ...

class Pool(log.Identified, event.EventTarget):
    dispatch: dispatcher[Pool]
    echo: log._EchoFlagType
    logging_name: Incomplete
    def __init__(self, creator: Union[_CreatorFnType, _CreatorWRecFnType], recycle: int = ..., echo: log._EchoFlagType = ..., logging_name: Optional[str] = ..., reset_on_return: _ResetStyleArgType = ..., events: Optional[List[Tuple[_ListenerFnType, str]]] = ..., dialect: Optional[Union[_ConnDialect, Dialect]] = ..., pre_ping: bool = ..., _dispatch: Optional[_DispatchCommon[Pool]] = ...) -> None: ...
    def recreate(self) -> Pool: ...
    def dispose(self) -> None: ...
    def connect(self) -> PoolProxiedConnection: ...
    def status(self) -> str: ...

class ManagesConnection:
    dbapi_connection: Optional[DBAPIConnection]
    driver_connection: Optional[Any]
    def info(self) -> _InfoType: ...
    def record_info(self) -> Optional[_InfoType]: ...
    def invalidate(self, e: Optional[BaseException] = ..., soft: bool = ...) -> None: ...

class ConnectionPoolEntry(ManagesConnection):
    @property
    def in_use(self) -> bool: ...
    def close(self) -> None: ...

class _ConnectionRecord(ConnectionPoolEntry):
    finalize_callback: Deque[Callable[[DBAPIConnection], None]]
    fresh: bool
    fairy_ref: Optional[weakref.ref[_ConnectionFairy]]
    starttime: float
    dbapi_connection: Incomplete
    def __init__(self, pool: Pool, connect: bool = ...) -> None: ...
    @property
    def driver_connection(self) -> Optional[Any]: ...
    @property
    def connection(self) -> Optional[DBAPIConnection]: ...
    def info(self) -> _InfoType: ...
    def record_info(self) -> Optional[_InfoType]: ...
    @classmethod
    def checkout(cls, pool: Pool) -> _ConnectionFairy: ...
    def checkin(self, _fairy_was_created: bool = ...) -> None: ...
    @property
    def in_use(self) -> bool: ...
    @property
    def last_connect_time(self) -> float: ...
    def close(self) -> None: ...
    def invalidate(self, e: Optional[BaseException] = ..., soft: bool = ...) -> None: ...
    def get_connection(self) -> DBAPIConnection: ...

class PoolProxiedConnection(ManagesConnection):
    def commit(self) -> None: ...
    def cursor(self) -> DBAPICursor: ...
    def rollback(self) -> None: ...
    @property
    def is_valid(self) -> bool: ...
    @property
    def is_detached(self) -> bool: ...
    def detach(self) -> None: ...
    def close(self) -> None: ...

class _AdhocProxiedConnection(PoolProxiedConnection):
    dbapi_connection: DBAPIConnection
    def __init__(self, dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry) -> None: ...
    @property
    def driver_connection(self) -> Any: ...
    @property
    def connection(self) -> DBAPIConnection: ...
    @property
    def is_valid(self) -> bool: ...
    def invalidate(self, e: Optional[BaseException] = ..., soft: bool = ...) -> None: ...
    def record_info(self) -> Optional[_InfoType]: ...
    def cursor(self, *args: Any, **kwargs: Any) -> DBAPICursor: ...
    def __getattr__(self, key: Any) -> Any: ...

class _ConnectionFairy(PoolProxiedConnection):
    pool: Pool
    dbapi_connection: DBAPIConnection
    def __init__(self, pool: Pool, dbapi_connection: DBAPIConnection, connection_record: _ConnectionRecord, echo: log._EchoFlagType) -> None: ...
    @property
    def driver_connection(self) -> Optional[Any]: ...
    @property
    def connection(self) -> DBAPIConnection: ...
    @property
    def is_valid(self) -> bool: ...
    @property
    def is_detached(self) -> bool: ...
    def info(self) -> _InfoType: ...
    def record_info(self) -> Optional[_InfoType]: ...
    def invalidate(self, e: Optional[BaseException] = ..., soft: bool = ...) -> None: ...
    def cursor(self, *args: Any, **kwargs: Any) -> DBAPICursor: ...
    def __getattr__(self, key: str) -> Any: ...
    def detach(self) -> None: ...
    def close(self) -> None: ...
