from .. import util as util
from ..util.typing import Literal as Literal
from .attr import _InstanceLevelDispatch, _JoinedListener
from .registry import _ET
from _typeshed import Incomplete
from typing import Any, Generic, Optional, Tuple, Type, Union, overload

class _UnpickleDispatch:
    def __call__(self, _instance_cls: Type[_ET]) -> _Dispatch[_ET]: ...

class _DispatchCommon(Generic[_ET]):
    def __getattr__(self, name: str) -> _InstanceLevelDispatch[_ET]: ...

class _Dispatch(_DispatchCommon[_ET]):
    def __init__(self, parent: Optional[_Dispatch[_ET]], instance_cls: Optional[Type[_ET]] = ...) -> None: ...
    def __getattr__(self, name: str) -> _InstanceLevelDispatch[_ET]: ...
    def __reduce__(self) -> Union[str, Tuple[Any, ...]]: ...

class _HasEventsDispatch(Generic[_ET]):
    dispatch: _Dispatch[_ET]
    def __getattr__(self, name: str) -> _InstanceLevelDispatch[_ET]: ...
    def __init_subclass__(cls) -> None: ...

class Events(_HasEventsDispatch[_ET]): ...

class _JoinedDispatcher(_DispatchCommon[_ET]):
    local: _DispatchCommon[_ET]
    parent: _DispatchCommon[_ET]
    def __init__(self, local: _DispatchCommon[_ET], parent: _DispatchCommon[_ET]) -> None: ...
    def __getattr__(self, name: str) -> _JoinedListener[_ET]: ...

class dispatcher(Generic[_ET]):
    dispatch: Incomplete
    events: Incomplete
    def __init__(self, events: Type[_HasEventsDispatch[_ET]]) -> None: ...
    @overload
    def __get__(self, obj: Literal[None], cls: Type[Any]) -> Type[_Dispatch[_ET]]: ...
    @overload
    def __get__(self, obj: Any, cls: Type[Any]) -> _DispatchCommon[_ET]: ...

class slots_dispatcher(dispatcher[_ET]):
    def __get__(self, obj: Any, cls: Type[Any]) -> Any: ...
