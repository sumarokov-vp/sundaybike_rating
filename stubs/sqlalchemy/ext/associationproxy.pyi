from .. import ColumnElement as ColumnElement, exc as exc, inspect as inspect, orm as orm, util as util
from ..orm import InspectionAttrExtensionType as InspectionAttrExtensionType, ORMDescriptor as ORMDescriptor, collections as collections, interfaces as interfaces
from ..orm.base import SQLORMOperations as SQLORMOperations
from ..orm.interfaces import MapperProperty as MapperProperty, PropComparator as PropComparator, _AttributeOptions, _DCAttributeOptions
from ..orm.mapper import Mapper as Mapper
from ..sql import operators as operators, or_ as or_
from ..sql._typing import _ColumnExpressionArgument, _InfoType
from ..sql.base import _NoArg
from ..util.typing import Literal as Literal, Protocol as Protocol, Self as Self, SupportsIndex as SupportsIndex, SupportsKeysAndGetItem as SupportsKeysAndGetItem
from _typeshed import Incomplete
from typing import AbstractSet, Any, Callable, Collection, Dict, Generic, ItemsView, Iterable, Iterator, KeysView, List, MutableMapping, MutableSequence, MutableSet, NoReturn, Optional, Tuple, Type, Union, ValuesView, overload

def association_proxy(target_collection: str, attr: str, *, creator: Optional[_CreatorProtocol] = ..., getset_factory: Optional[_GetSetFactoryProtocol] = ..., proxy_factory: Optional[_ProxyFactoryProtocol] = ..., proxy_bulk_set: Optional[_ProxyBulkSetProtocol] = ..., info: Optional[_InfoType] = ..., cascade_scalar_deletes: bool = ..., create_on_none_assignment: bool = ..., init: Union[_NoArg, bool] = ..., repr: Union[_NoArg, bool] = ..., default: Optional[Any] = ..., default_factory: Union[_NoArg, Callable[[], _T]] = ..., compare: Union[_NoArg, bool] = ..., kw_only: Union[_NoArg, bool] = ...) -> AssociationProxy[Any]: ...

class AssociationProxyExtensionType(InspectionAttrExtensionType):
    ASSOCIATION_PROXY: str

class _GetterProtocol(Protocol[_T_co]):
    def __call__(self, instance: Any) -> _T_co: ...

class _SetterProtocol(Protocol): ...

class _PlainSetterProtocol(_SetterProtocol, Protocol[_T_con]):
    def __call__(self, instance: Any, value: _T_con) -> None: ...

class _DictSetterProtocol(_SetterProtocol, Protocol[_T_con]):
    def __call__(self, instance: Any, key: Any, value: _T_con) -> None: ...

class _CreatorProtocol(Protocol): ...

class _PlainCreatorProtocol(_CreatorProtocol, Protocol[_T_con]):
    def __call__(self, value: _T_con) -> Any: ...

class _KeyCreatorProtocol(_CreatorProtocol, Protocol[_T_con]):
    def __call__(self, key: Any, value: Optional[_T_con]) -> Any: ...

class _LazyCollectionProtocol(Protocol[_T]):
    def __call__(self) -> Union[MutableSet[_T], MutableMapping[Any, _T], MutableSequence[_T]]: ...

class _GetSetFactoryProtocol(Protocol):
    def __call__(self, collection_class: Optional[Type[Any]], assoc_instance: AssociationProxyInstance[Any]) -> Tuple[_GetterProtocol[Any], _SetterProtocol]: ...

class _ProxyFactoryProtocol(Protocol):
    def __call__(self, lazy_collection: _LazyCollectionProtocol[Any], creator: _CreatorProtocol, value_attr: str, parent: AssociationProxyInstance[Any]) -> Any: ...

class _ProxyBulkSetProtocol(Protocol):
    def __call__(self, proxy: _AssociationCollection[Any], collection: Iterable[Any]) -> None: ...

class _AssociationProxyProtocol(Protocol[_T]):
    creator: Optional[_CreatorProtocol]
    key: str
    target_collection: str
    value_attr: str
    cascade_scalar_deletes: bool
    create_on_none_assignment: bool
    getset_factory: Optional[_GetSetFactoryProtocol]
    proxy_factory: Optional[_ProxyFactoryProtocol]
    proxy_bulk_set: Optional[_ProxyBulkSetProtocol]
    def info(self) -> _InfoType: ...
    def for_class(self, class_: Type[Any], obj: Optional[object] = ...) -> AssociationProxyInstance[_T]: ...

class AssociationProxy(interfaces.InspectionAttrInfo, ORMDescriptor[_T], _DCAttributeOptions, _AssociationProxyProtocol[_T]):
    is_attribute: bool
    extension_type: Incomplete
    target_collection: Incomplete
    value_attr: Incomplete
    creator: Incomplete
    getset_factory: Incomplete
    proxy_factory: Incomplete
    proxy_bulk_set: Incomplete
    cascade_scalar_deletes: Incomplete
    create_on_none_assignment: Incomplete
    key: Incomplete
    info: Incomplete
    def __init__(self, target_collection: str, attr: str, *, creator: Optional[_CreatorProtocol] = ..., getset_factory: Optional[_GetSetFactoryProtocol] = ..., proxy_factory: Optional[_ProxyFactoryProtocol] = ..., proxy_bulk_set: Optional[_ProxyBulkSetProtocol] = ..., info: Optional[_InfoType] = ..., cascade_scalar_deletes: bool = ..., create_on_none_assignment: bool = ..., attribute_options: Optional[_AttributeOptions] = ...) -> None: ...
    @overload
    def __get__(self, instance: Literal[None], owner: Literal[None]) -> Self: ...
    @overload
    def __get__(self, instance: Literal[None], owner: Any) -> AssociationProxyInstance[_T]: ...
    @overload
    def __get__(self, instance: object, owner: Any) -> _T: ...
    def __set__(self, instance: object, values: _T) -> None: ...
    def __delete__(self, instance: object) -> None: ...
    def for_class(self, class_: Type[Any], obj: Optional[object] = ...) -> AssociationProxyInstance[_T]: ...

class AssociationProxyInstance(SQLORMOperations[_T]):
    collection_class: Optional[Type[Any]]
    parent: _AssociationProxyProtocol[_T]
    key: Incomplete
    owning_class: Incomplete
    target_collection: Incomplete
    target_class: Incomplete
    value_attr: Incomplete
    def __init__(self, parent: _AssociationProxyProtocol[_T], owning_class: Type[Any], target_class: Type[Any], value_attr: str) -> None: ...
    @classmethod
    def for_proxy(cls, parent: AssociationProxy[_T], owning_class: Type[Any], parent_instance: Any) -> AssociationProxyInstance[_T]: ...
    def __clause_element__(self) -> NoReturn: ...
    @property
    def remote_attr(self) -> SQLORMOperations[_T]: ...
    @property
    def local_attr(self) -> SQLORMOperations[Any]: ...
    @property
    def attr(self) -> Tuple[SQLORMOperations[Any], SQLORMOperations[_T]]: ...
    def scalar(self) -> bool: ...
    def info(self) -> _InfoType: ...
    @overload
    def get(self, obj: Literal[None]) -> _Self: ...
    @overload
    def get(self, obj: Any) -> _T: ...
    def set(self, obj: Any, values: _T) -> None: ...
    def delete(self, obj: Any) -> None: ...
    def any(self, criterion: Optional[_ColumnExpressionArgument[bool]] = ..., **kwargs: Any) -> ColumnElement[bool]: ...
    def has(self, criterion: Optional[_ColumnExpressionArgument[bool]] = ..., **kwargs: Any) -> ColumnElement[bool]: ...

class AmbiguousAssociationProxyInstance(AssociationProxyInstance[_T]):
    def get(self, obj: Any) -> Any: ...
    def __eq__(self, obj: object) -> NoReturn: ...
    def __ne__(self, obj: object) -> NoReturn: ...
    def any(self, criterion: Optional[_ColumnExpressionArgument[bool]] = ..., **kwargs: Any) -> NoReturn: ...
    def has(self, criterion: Optional[_ColumnExpressionArgument[bool]] = ..., **kwargs: Any) -> NoReturn: ...

class ObjectAssociationProxyInstance(AssociationProxyInstance[_T]):
    def contains(self, other: Any, **kw: Any) -> ColumnElement[bool]: ...
    def __eq__(self, obj: Any) -> ColumnElement[bool]: ...
    def __ne__(self, obj: Any) -> ColumnElement[bool]: ...

class ColumnAssociationProxyInstance(AssociationProxyInstance[_T]):
    def __eq__(self, other: Any) -> ColumnElement[bool]: ...
    def operate(self, op: operators.OperatorType, *other: Any, **kwargs: Any) -> ColumnElement[Any]: ...

class _lazy_collection(_LazyCollectionProtocol[_T]):
    parent: Incomplete
    target: Incomplete
    def __init__(self, obj: Any, target: str) -> None: ...
    def __call__(self) -> Union[MutableSet[_T], MutableMapping[Any, _T], MutableSequence[_T]]: ...

class _AssociationCollection(Generic[_IT]):
    getter: _GetterProtocol[_IT]
    creator: _CreatorProtocol
    parent: AssociationProxyInstance[_IT]
    setter: _SetterProtocol
    lazy_collection: _LazyCollectionProtocol[_IT]
    def __init__(self, lazy_collection: _LazyCollectionProtocol[_IT], creator: _CreatorProtocol, getter: _GetterProtocol[_IT], setter: _SetterProtocol, parent: AssociationProxyInstance[_IT]) -> None: ...
    col: Collection[_IT]
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def clear(self) -> None: ...

class _AssociationSingleItem(_AssociationCollection[_T]):
    setter: _PlainSetterProtocol[_T]
    creator: _PlainCreatorProtocol[_T]

class _AssociationList(_AssociationSingleItem[_T], MutableSequence[_T]):
    col: MutableSequence[_T]
    @overload
    def __getitem__(self, index: int) -> _T: ...
    @overload
    def __getitem__(self, index: slice) -> MutableSequence[_T]: ...
    @overload
    def __setitem__(self, index: int, value: _T) -> None: ...
    @overload
    def __setitem__(self, index: slice, value: Iterable[_T]) -> None: ...
    @overload
    def __delitem__(self, index: int) -> None: ...
    @overload
    def __delitem__(self, index: slice) -> None: ...
    def __contains__(self, value: object) -> bool: ...
    def __iter__(self) -> Iterator[_T]: ...
    def append(self, value: _T) -> None: ...
    def count(self, value: Any) -> int: ...
    def extend(self, values: Iterable[_T]) -> None: ...
    def insert(self, index: int, value: _T) -> None: ...
    def pop(self, index: int = ...) -> _T: ...
    def remove(self, value: _T) -> None: ...
    def reverse(self) -> NoReturn: ...
    def sort(self) -> NoReturn: ...
    def clear(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: List[_T]) -> bool: ...
    def __le__(self, other: List[_T]) -> bool: ...
    def __gt__(self, other: List[_T]) -> bool: ...
    def __ge__(self, other: List[_T]) -> bool: ...
    def __add__(self, other: List[_T]) -> List[_T]: ...
    def __radd__(self, other: List[_T]) -> List[_T]: ...
    def __mul__(self, n: SupportsIndex) -> List[_T]: ...
    def __rmul__(self, n: SupportsIndex) -> List[_T]: ...
    def __iadd__(self, iterable: Iterable[_T]) -> Self: ...
    def __imul__(self, n: SupportsIndex) -> Self: ...
    def index(self, value: Any, start: int = ..., stop: int = ...) -> int: ...
    def copy(self) -> List[_T]: ...
    def __hash__(self) -> NoReturn: ...

class _AssociationDict(_AssociationCollection[_VT], MutableMapping[_KT, _VT]):
    setter: _DictSetterProtocol[_VT]
    creator: _KeyCreatorProtocol[_VT]
    col: MutableMapping[_KT, Optional[_VT]]
    def __getitem__(self, key: _KT) -> _VT: ...
    def __setitem__(self, key: _KT, value: _VT) -> None: ...
    def __delitem__(self, key: _KT) -> None: ...
    def __contains__(self, key: object) -> bool: ...
    def __iter__(self) -> Iterator[_KT]: ...
    def clear(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def get(self, __key: _KT) -> Optional[_VT]: ...
    @overload
    def get(self, __key: _KT, default: Union[_VT, _T]) -> Union[_VT, _T]: ...
    def setdefault(self, key: _KT, default: Optional[_VT] = ...) -> _VT: ...
    def keys(self) -> KeysView[_KT]: ...
    def items(self) -> ItemsView[_KT, _VT]: ...
    def values(self) -> ValuesView[_VT]: ...
    @overload
    def pop(self, __key: _KT) -> _VT: ...
    @overload
    def pop(self, __key: _KT, default: Union[_VT, _T] = ...) -> Union[_VT, _T]: ...
    def popitem(self) -> Tuple[_KT, _VT]: ...
    @overload
    def update(self, __m: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT) -> None: ...
    @overload
    def update(self, __m: Iterable[tuple[_KT, _VT]], **kwargs: _VT) -> None: ...
    @overload
    def update(self, **kwargs: _VT) -> None: ...
    def copy(self) -> Dict[_KT, _VT]: ...
    def __hash__(self) -> NoReturn: ...

class _AssociationSet(_AssociationSingleItem[_T], MutableSet[_T]):
    col: MutableSet[_T]
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, __o: object) -> bool: ...
    def __iter__(self) -> Iterator[_T]: ...
    def add(self, __element: _T) -> None: ...
    def discard(self, __element: _T) -> None: ...
    def remove(self, __element: _T) -> None: ...
    def pop(self) -> _T: ...
    def update(self, *s: Iterable[_T]) -> None: ...
    def __ior__(self, other: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...
    def union(self, *s: Iterable[_S]) -> MutableSet[Union[_T, _S]]: ...
    def __or__(self, __s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...
    def difference(self, *s: Iterable[Any]) -> MutableSet[_T]: ...
    def __sub__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...
    def difference_update(self, *s: Iterable[Any]) -> None: ...
    def __isub__(self, s: AbstractSet[Any]) -> Self: ...
    def intersection(self, *s: Iterable[Any]) -> MutableSet[_T]: ...
    def __and__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...
    def intersection_update(self, *s: Iterable[Any]) -> None: ...
    def __iand__(self, s: AbstractSet[Any]) -> Self: ...
    def symmetric_difference(self, __s: Iterable[_T]) -> MutableSet[_T]: ...
    def __xor__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...
    def symmetric_difference_update(self, other: Iterable[Any]) -> None: ...
    def __ixor__(self, other: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...
    def issubset(self, __s: Iterable[Any]) -> bool: ...
    def issuperset(self, __s: Iterable[Any]) -> bool: ...
    def clear(self) -> None: ...
    def copy(self) -> AbstractSet[_T]: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: AbstractSet[Any]) -> bool: ...
    def __le__(self, other: AbstractSet[Any]) -> bool: ...
    def __gt__(self, other: AbstractSet[Any]) -> bool: ...
    def __ge__(self, other: AbstractSet[Any]) -> bool: ...
    def __hash__(self) -> NoReturn: ...
