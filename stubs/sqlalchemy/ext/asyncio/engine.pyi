from ... import exc as exc, inspection as inspection, util as util
from ...engine import Connection as Connection, Engine as Engine
from ...engine.base import NestedTransaction as NestedTransaction, Transaction as Transaction
from ...engine.cursor import CursorResult as CursorResult
from ...engine.interfaces import CompiledCacheType as CompiledCacheType, CoreExecuteOptionsParameter as CoreExecuteOptionsParameter, Dialect as Dialect, IsolationLevel as IsolationLevel, SchemaTranslateMapType as SchemaTranslateMapType, _CoreAnyExecuteParams, _CoreSingleExecuteParams, _DBAPIAnyExecuteParams, _ExecuteOptions
from ...engine.result import ScalarResult as ScalarResult
from ...engine.url import URL as URL
from ...exc import ArgumentError as ArgumentError
from ...pool import Pool as Pool, PoolProxiedConnection as PoolProxiedConnection
from ...sql._typing import _InfoType
from ...sql.base import Executable as Executable
from ...sql.selectable import TypedReturnsRows as TypedReturnsRows
from ...util.concurrency import greenlet_spawn as greenlet_spawn
from .base import GeneratorStartableContext as GeneratorStartableContext, ProxyComparable as ProxyComparable, StartableContext as StartableContext, asyncstartablecontext as asyncstartablecontext
from .result import AsyncResult as AsyncResult, AsyncScalarResult as AsyncScalarResult
from _typeshed import Incomplete
from typing import Any, AsyncIterator, Callable, Dict, Generator, NoReturn, Optional, Tuple, Union, overload

def create_async_engine(url: Union[str, URL], **kw: Any) -> AsyncEngine: ...
def async_engine_from_config(configuration: Dict[str, Any], prefix: str = ..., **kwargs: Any) -> AsyncEngine: ...
def create_async_pool_from_url(url: Union[str, URL], **kwargs: Any) -> Pool: ...

class AsyncConnectable: ...

class AsyncConnection(ProxyComparable[Connection], StartableContext['AsyncConnection'], AsyncConnectable):
    engine: Incomplete
    sync_engine: Incomplete
    sync_connection: Incomplete
    def __init__(self, async_engine: AsyncEngine, sync_connection: Optional[Connection] = ...) -> None: ...
    async def start(self, is_ctxmanager: bool = ...) -> AsyncConnection: ...
    @property
    def connection(self) -> NoReturn: ...
    async def get_raw_connection(self) -> PoolProxiedConnection: ...
    def info(self) -> _InfoType: ...
    def begin(self) -> AsyncTransaction: ...
    def begin_nested(self) -> AsyncTransaction: ...
    async def invalidate(self, exception: Optional[BaseException] = ...) -> None: ...
    async def get_isolation_level(self) -> IsolationLevel: ...
    def in_transaction(self) -> bool: ...
    def in_nested_transaction(self) -> bool: ...
    def get_transaction(self) -> Optional[AsyncTransaction]: ...
    def get_nested_transaction(self) -> Optional[AsyncTransaction]: ...
    @overload
    async def execution_options(self, *, compiled_cache: Optional[CompiledCacheType] = ..., logging_token: str = ..., isolation_level: IsolationLevel = ..., no_parameters: bool = ..., stream_results: bool = ..., max_row_buffer: int = ..., yield_per: int = ..., insertmanyvalues_page_size: int = ..., schema_translate_map: Optional[SchemaTranslateMapType] = ..., **opt: Any) -> AsyncConnection: ...
    @overload
    async def execution_options(self, **opt: Any) -> AsyncConnection: ...
    async def commit(self) -> None: ...
    async def rollback(self) -> None: ...
    async def close(self) -> None: ...
    async def aclose(self) -> None: ...
    async def exec_driver_sql(self, statement: str, parameters: Optional[_DBAPIAnyExecuteParams] = ..., execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> CursorResult[Any]: ...
    @overload
    def stream(self, statement: TypedReturnsRows[_T], parameters: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> GeneratorStartableContext[AsyncResult[_T]]: ...
    @overload
    def stream(self, statement: Executable, parameters: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> GeneratorStartableContext[AsyncResult[Any]]: ...
    @overload
    async def execute(self, statement: TypedReturnsRows[_T], parameters: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> CursorResult[_T]: ...
    @overload
    async def execute(self, statement: Executable, parameters: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> CursorResult[Any]: ...
    @overload
    async def scalar(self, statement: TypedReturnsRows[Tuple[_T]], parameters: Optional[_CoreSingleExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> Optional[_T]: ...
    @overload
    async def scalar(self, statement: Executable, parameters: Optional[_CoreSingleExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> Any: ...
    @overload
    async def scalars(self, statement: TypedReturnsRows[Tuple[_T]], parameters: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> ScalarResult[_T]: ...
    @overload
    async def scalars(self, statement: Executable, parameters: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> ScalarResult[Any]: ...
    @overload
    def stream_scalars(self, statement: TypedReturnsRows[Tuple[_T]], parameters: Optional[_CoreSingleExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> GeneratorStartableContext[AsyncScalarResult[_T]]: ...
    @overload
    def stream_scalars(self, statement: Executable, parameters: Optional[_CoreSingleExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> GeneratorStartableContext[AsyncScalarResult[Any]]: ...
    async def run_sync(self, fn: Callable[..., _T], *arg: Any, **kw: Any) -> _T: ...
    def __await__(self) -> Generator[Any, None, AsyncConnection]: ...
    async def __aexit__(self, type_: Any, value: Any, traceback: Any) -> None: ...
    @property
    def closed(self) -> Any: ...
    @property
    def invalidated(self) -> Any: ...
    @property
    def dialect(self) -> Any: ...
    @dialect.setter
    def dialect(self, attr: Any) -> None: ...
    @property
    def default_isolation_level(self) -> Any: ...

class AsyncEngine(ProxyComparable[Engine], AsyncConnectable):
    sync_engine: Engine
    def __init__(self, sync_engine: Engine) -> None: ...
    async def begin(self) -> AsyncIterator[AsyncConnection]: ...
    def connect(self) -> AsyncConnection: ...
    async def raw_connection(self) -> PoolProxiedConnection: ...
    @overload
    def execution_options(self, *, compiled_cache: Optional[CompiledCacheType] = ..., logging_token: str = ..., isolation_level: IsolationLevel = ..., insertmanyvalues_page_size: int = ..., schema_translate_map: Optional[SchemaTranslateMapType] = ..., **opt: Any) -> AsyncEngine: ...
    @overload
    def execution_options(self, **opt: Any) -> AsyncEngine: ...
    async def dispose(self, close: bool = ...) -> None: ...
    def clear_compiled_cache(self) -> None: ...
    def update_execution_options(self, **opt: Any) -> None: ...
    def get_execution_options(self) -> _ExecuteOptions: ...
    @property
    def url(self) -> URL: ...
    @url.setter
    def url(self, attr: URL) -> None: ...
    @property
    def pool(self) -> Pool: ...
    @pool.setter
    def pool(self, attr: Pool) -> None: ...
    @property
    def dialect(self) -> Dialect: ...
    @dialect.setter
    def dialect(self, attr: Dialect) -> None: ...
    @property
    def engine(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def driver(self) -> Any: ...
    @property
    def echo(self) -> Any: ...
    @echo.setter
    def echo(self, attr: Any) -> None: ...

class AsyncTransaction(ProxyComparable[Transaction], StartableContext['AsyncTransaction']):
    sync_transaction: Optional[Transaction]
    connection: AsyncConnection
    nested: bool
    def __init__(self, connection: AsyncConnection, nested: bool = ...) -> None: ...
    @property
    def is_valid(self) -> bool: ...
    @property
    def is_active(self) -> bool: ...
    async def close(self) -> None: ...
    async def rollback(self) -> None: ...
    async def commit(self) -> None: ...
    async def start(self, is_ctxmanager: bool = ...) -> AsyncTransaction: ...
    async def __aexit__(self, type_: Any, value: Any, traceback: Any) -> None: ...
