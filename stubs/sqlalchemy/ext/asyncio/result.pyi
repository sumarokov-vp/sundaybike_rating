from ... import util as util
from ...engine import CursorResult as CursorResult, Result as Result
from ...engine.result import FilterResult as FilterResult, FrozenResult as FrozenResult, ResultMetaData as ResultMetaData, _KeyIndexType, _R, _UniqueFilterType, _WithKeys
from ...engine.row import Row as Row, RowMapping as RowMapping
from ...util.concurrency import greenlet_spawn as greenlet_spawn
from ...util.typing import Literal as Literal, Self as Self
from typing import Any, AsyncIterator, Optional, Sequence, overload

class AsyncCommon(FilterResult[_R]):
    async def close(self) -> None: ...
    @property
    def closed(self) -> bool: ...

class AsyncResult(_WithKeys, AsyncCommon[Row[_TP]]):
    def __init__(self, real_result: Result[_TP]) -> None: ...
    @property
    def t(self) -> AsyncTupleResult[_TP]: ...
    def tuples(self) -> AsyncTupleResult[_TP]: ...
    def unique(self, strategy: Optional[_UniqueFilterType] = ...) -> Self: ...
    def columns(self, *col_expressions: _KeyIndexType) -> Self: ...
    async def partitions(self, size: Optional[int] = ...) -> AsyncIterator[Sequence[Row[_TP]]]: ...
    async def fetchall(self) -> Sequence[Row[_TP]]: ...
    async def fetchone(self) -> Optional[Row[_TP]]: ...
    async def fetchmany(self, size: Optional[int] = ...) -> Sequence[Row[_TP]]: ...
    async def all(self) -> Sequence[Row[_TP]]: ...
    def __aiter__(self) -> AsyncResult[_TP]: ...
    async def __anext__(self) -> Row[_TP]: ...
    async def first(self) -> Optional[Row[_TP]]: ...
    async def one_or_none(self) -> Optional[Row[_TP]]: ...
    @overload
    async def scalar_one(self) -> _T: ...
    @overload
    async def scalar_one(self) -> Any: ...
    @overload
    async def scalar_one_or_none(self) -> Optional[_T]: ...
    @overload
    async def scalar_one_or_none(self) -> Optional[Any]: ...
    async def one(self) -> Row[_TP]: ...
    @overload
    async def scalar(self) -> Optional[_T]: ...
    @overload
    async def scalar(self) -> Any: ...
    async def freeze(self) -> FrozenResult[_TP]: ...
    @overload
    def scalars(self, index: Literal[0]) -> AsyncScalarResult[_T]: ...
    @overload
    def scalars(self) -> AsyncScalarResult[_T]: ...
    @overload
    def scalars(self, index: _KeyIndexType = ...) -> AsyncScalarResult[Any]: ...
    def mappings(self) -> AsyncMappingResult: ...

class AsyncScalarResult(AsyncCommon[_R]):
    def __init__(self, real_result: Result[Any], index: _KeyIndexType) -> None: ...
    def unique(self, strategy: Optional[_UniqueFilterType] = ...) -> Self: ...
    async def partitions(self, size: Optional[int] = ...) -> AsyncIterator[Sequence[_R]]: ...
    async def fetchall(self) -> Sequence[_R]: ...
    async def fetchmany(self, size: Optional[int] = ...) -> Sequence[_R]: ...
    async def all(self) -> Sequence[_R]: ...
    def __aiter__(self) -> AsyncScalarResult[_R]: ...
    async def __anext__(self) -> _R: ...
    async def first(self) -> Optional[_R]: ...
    async def one_or_none(self) -> Optional[_R]: ...
    async def one(self) -> _R: ...

class AsyncMappingResult(_WithKeys, AsyncCommon[RowMapping]):
    def __init__(self, result: Result[Any]) -> None: ...
    def unique(self, strategy: Optional[_UniqueFilterType] = ...) -> Self: ...
    def columns(self, *col_expressions: _KeyIndexType) -> Self: ...
    async def partitions(self, size: Optional[int] = ...) -> AsyncIterator[Sequence[RowMapping]]: ...
    async def fetchall(self) -> Sequence[RowMapping]: ...
    async def fetchone(self) -> Optional[RowMapping]: ...
    async def fetchmany(self, size: Optional[int] = ...) -> Sequence[RowMapping]: ...
    async def all(self) -> Sequence[RowMapping]: ...
    def __aiter__(self) -> AsyncMappingResult: ...
    async def __anext__(self) -> RowMapping: ...
    async def first(self) -> Optional[RowMapping]: ...
    async def one_or_none(self) -> Optional[RowMapping]: ...
    async def one(self) -> RowMapping: ...

class AsyncTupleResult(AsyncCommon[_R], util.TypingOnly):
    async def partitions(self, size: Optional[int] = ...) -> AsyncIterator[Sequence[_R]]: ...
    async def fetchone(self) -> Optional[_R]: ...
    async def fetchall(self) -> Sequence[_R]: ...
    async def fetchmany(self, size: Optional[int] = ...) -> Sequence[_R]: ...
    async def all(self) -> Sequence[_R]: ...
    async def __aiter__(self) -> AsyncIterator[_R]: ...
    async def __anext__(self) -> _R: ...
    async def first(self) -> Optional[_R]: ...
    async def one_or_none(self) -> Optional[_R]: ...
    async def one(self) -> _R: ...
    @overload
    async def scalar_one(self) -> _T: ...
    @overload
    async def scalar_one(self) -> Any: ...
    @overload
    async def scalar_one_or_none(self) -> Optional[_T]: ...
    @overload
    async def scalar_one_or_none(self) -> Optional[Any]: ...
    @overload
    async def scalar(self) -> Optional[_T]: ...
    @overload
    async def scalar(self) -> Any: ...
