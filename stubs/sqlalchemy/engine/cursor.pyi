from .. import exc as exc, util as util
from ..sql import elements as elements, sqltypes as sqltypes
from ..sql.compiler import RM_NAME as RM_NAME, RM_OBJECTS as RM_OBJECTS, RM_RENDERED_NAME as RM_RENDERED_NAME, RM_TYPE as RM_TYPE, ResultColumnsEntry as ResultColumnsEntry
from ..sql.type_api import TypeEngine as TypeEngine
from ..util import compat as compat
from ..util.typing import Literal as Literal, Self as Self
from .base import Connection as Connection
from .default import DefaultExecutionContext as DefaultExecutionContext
from .interfaces import DBAPICursor as DBAPICursor, Dialect as Dialect, ExecutionContext as ExecutionContext, _DBAPICursorDescription
from .result import IteratorResult as IteratorResult, MergedResult as MergedResult, Result as Result, ResultMetaData as ResultMetaData, SimpleResultMetaData as SimpleResultMetaData, tuplegetter as tuplegetter
from .row import Row as Row
from _typeshed import Incomplete
from typing import Any, ClassVar, NoReturn, Optional

MD_INDEX: Literal[0]
MD_RESULT_MAP_INDEX: Literal[1]
MD_OBJECTS: Literal[2]
MD_LOOKUP_KEY: Literal[3]
MD_RENDERED_NAME: Literal[4]
MD_PROCESSOR: Literal[5]
MD_UNTRANSLATED: Literal[6]

class CursorResultMetaData(ResultMetaData):
    returns_rows: ClassVar[bool]
    def __init__(self, parent: CursorResult[Any], cursor_description: _DBAPICursorDescription) -> None: ...

class ResultFetchStrategy:
    alternate_cursor_description: Optional[_DBAPICursorDescription]
    def soft_close(self, result: CursorResult[Any], dbapi_cursor: Optional[DBAPICursor]) -> None: ...
    def hard_close(self, result: CursorResult[Any], dbapi_cursor: Optional[DBAPICursor]) -> None: ...
    def yield_per(self, result: CursorResult[Any], dbapi_cursor: Optional[DBAPICursor], num: int) -> None: ...
    def fetchone(self, result: CursorResult[Any], dbapi_cursor: DBAPICursor, hard_close: bool = ...) -> Any: ...
    def fetchmany(self, result: CursorResult[Any], dbapi_cursor: DBAPICursor, size: Optional[int] = ...) -> Any: ...
    def fetchall(self, result: CursorResult[Any], dbapi_cursor: DBAPICursor) -> Any: ...
    def handle_exception(self, result: CursorResult[Any], dbapi_cursor: Optional[DBAPICursor], err: BaseException) -> NoReturn: ...

class NoCursorFetchStrategy(ResultFetchStrategy):
    def soft_close(self, result, dbapi_cursor) -> None: ...
    def hard_close(self, result, dbapi_cursor) -> None: ...
    def fetchone(self, result, dbapi_cursor, hard_close: bool = ...): ...
    def fetchmany(self, result, dbapi_cursor, size: Incomplete | None = ...): ...
    def fetchall(self, result, dbapi_cursor): ...

class NoCursorDQLFetchStrategy(NoCursorFetchStrategy): ...
class NoCursorDMLFetchStrategy(NoCursorFetchStrategy): ...

class CursorFetchStrategy(ResultFetchStrategy):
    def soft_close(self, result: CursorResult[Any], dbapi_cursor: Optional[DBAPICursor]) -> None: ...
    def hard_close(self, result: CursorResult[Any], dbapi_cursor: Optional[DBAPICursor]) -> None: ...
    def handle_exception(self, result: CursorResult[Any], dbapi_cursor: Optional[DBAPICursor], err: BaseException) -> NoReturn: ...
    def yield_per(self, result: CursorResult[Any], dbapi_cursor: Optional[DBAPICursor], num: int) -> None: ...
    def fetchone(self, result: CursorResult[Any], dbapi_cursor: DBAPICursor, hard_close: bool = ...) -> Any: ...
    def fetchmany(self, result: CursorResult[Any], dbapi_cursor: DBAPICursor, size: Optional[int] = ...) -> Any: ...
    def fetchall(self, result: CursorResult[Any], dbapi_cursor: DBAPICursor) -> Any: ...

class BufferedRowCursorFetchStrategy(CursorFetchStrategy):
    def __init__(self, dbapi_cursor, execution_options, growth_factor: int = ..., initial_buffer: Incomplete | None = ...) -> None: ...
    @classmethod
    def create(cls, result): ...
    def yield_per(self, result, dbapi_cursor, num) -> None: ...
    def soft_close(self, result, dbapi_cursor) -> None: ...
    def hard_close(self, result, dbapi_cursor) -> None: ...
    def fetchone(self, result, dbapi_cursor, hard_close: bool = ...): ...
    def fetchmany(self, result, dbapi_cursor, size: Incomplete | None = ...): ...
    def fetchall(self, result, dbapi_cursor): ...

class FullyBufferedCursorFetchStrategy(CursorFetchStrategy):
    alternate_cursor_description: Incomplete
    def __init__(self, dbapi_cursor, alternate_description: Incomplete | None = ..., initial_buffer: Incomplete | None = ...) -> None: ...
    def yield_per(self, result, dbapi_cursor, num) -> None: ...
    def soft_close(self, result, dbapi_cursor) -> None: ...
    def hard_close(self, result, dbapi_cursor) -> None: ...
    def fetchone(self, result, dbapi_cursor, hard_close: bool = ...): ...
    def fetchmany(self, result, dbapi_cursor, size: Incomplete | None = ...): ...
    def fetchall(self, result, dbapi_cursor): ...

class _NoResultMetaData(ResultMetaData):
    returns_rows: bool
    @property
    def keys(self) -> None: ...

def null_dml_result() -> IteratorResult[Any]: ...

class CursorResult(Result[_T]):
    closed: bool
    context: DefaultExecutionContext
    dialect: Dialect
    cursor_strategy: ResultFetchStrategy
    connection: Connection
    cursor: Incomplete
    def __init__(self, context: DefaultExecutionContext, cursor_strategy: ResultFetchStrategy, cursor_description: Optional[_DBAPICursorDescription]) -> None: ...
    @property
    def inserted_primary_key_rows(self): ...
    @property
    def inserted_primary_key(self): ...
    def last_updated_params(self): ...
    def last_inserted_params(self): ...
    @property
    def returned_defaults_rows(self): ...
    def splice_horizontally(self, other): ...
    def splice_vertically(self, other): ...
    @property
    def returned_defaults(self): ...
    def lastrow_has_defaults(self): ...
    def postfetch_cols(self): ...
    def prefetch_cols(self): ...
    def supports_sane_rowcount(self): ...
    def supports_sane_multi_rowcount(self): ...
    def rowcount(self) -> int: ...
    @property
    def lastrowid(self): ...
    @property
    def returns_rows(self): ...
    @property
    def is_insert(self): ...
    def merge(self, *others: Result[Any]) -> MergedResult[Any]: ...
    def close(self) -> Any: ...
    def yield_per(self, num: int) -> Self: ...
ResultProxy = CursorResult
