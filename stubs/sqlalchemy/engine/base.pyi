from . import CursorResult as CursorResult, ScalarResult as ScalarResult
from .. import exc as exc, inspection as inspection, log as log, util as util
from ..event import dispatcher as dispatcher
from ..log import _EchoFlagType
from ..pool import Pool as Pool, PoolProxiedConnection as PoolProxiedConnection
from ..sql import Executable as Executable, compiler as compiler
from ..sql._typing import _InfoType
from ..sql.compiler import Compiled as Compiled
from ..sql.ddl import ExecutableDDLElement as ExecutableDDLElement, SchemaDropper as SchemaDropper, SchemaGenerator as SchemaGenerator
from ..sql.functions import FunctionElement as FunctionElement
from ..sql.schema import DefaultGenerator as DefaultGenerator, HasSchemaAttr as HasSchemaAttr, SchemaItem as SchemaItem
from ..sql.selectable import TypedReturnsRows as TypedReturnsRows
from .interfaces import BindTyping as BindTyping, CompiledCacheType as CompiledCacheType, ConnectionEventsTarget as ConnectionEventsTarget, CoreExecuteOptionsParameter as CoreExecuteOptionsParameter, DBAPICursor as DBAPICursor, Dialect as Dialect, ExceptionContext as ExceptionContext, ExecuteStyle as ExecuteStyle, ExecutionContext as ExecutionContext, IsolationLevel as IsolationLevel, SchemaTranslateMapType as SchemaTranslateMapType, _CoreAnyExecuteParams, _CoreSingleExecuteParams, _DBAPIAnyExecuteParams, _ExecuteOptions
from .reflection import Inspector as Inspector
from .url import URL as URL
from .util import TransactionalContext as TransactionalContext
from _typeshed import Incomplete
from typing import Any, Iterator, List, Mapping, Optional, Tuple, overload

NO_OPTIONS: Mapping[str, Any]

class Connection(ConnectionEventsTarget, inspection.Inspectable['Inspector']):
    dispatch: dispatcher[ConnectionEventsTarget]
    should_close_with_result: bool
    engine: Incomplete
    dialect: Incomplete
    def __init__(self, engine: Engine, connection: Optional[PoolProxiedConnection] = ..., _has_events: Optional[bool] = ..., _allow_revalidate: bool = ..., _allow_autobegin: bool = ...) -> None: ...
    def schema_for_object(self, obj: HasSchemaAttr) -> Optional[str]: ...
    def __enter__(self) -> Connection: ...
    def __exit__(self, type_: Any, value: Any, traceback: Any) -> None: ...
    @overload
    def execution_options(self, *, compiled_cache: Optional[CompiledCacheType] = ..., logging_token: str = ..., isolation_level: IsolationLevel = ..., no_parameters: bool = ..., stream_results: bool = ..., max_row_buffer: int = ..., yield_per: int = ..., insertmanyvalues_page_size: int = ..., schema_translate_map: Optional[SchemaTranslateMapType] = ..., **opt: Any) -> Connection: ...
    @overload
    def execution_options(self, **opt: Any) -> Connection: ...
    def get_execution_options(self) -> _ExecuteOptions: ...
    @property
    def closed(self) -> bool: ...
    @property
    def invalidated(self) -> bool: ...
    @property
    def connection(self) -> PoolProxiedConnection: ...
    def get_isolation_level(self) -> IsolationLevel: ...
    @property
    def default_isolation_level(self) -> Optional[IsolationLevel]: ...
    @property
    def info(self) -> _InfoType: ...
    def invalidate(self, exception: Optional[BaseException] = ...) -> None: ...
    def detach(self) -> None: ...
    def begin(self) -> RootTransaction: ...
    def begin_nested(self) -> NestedTransaction: ...
    def begin_twophase(self, xid: Optional[Any] = ...) -> TwoPhaseTransaction: ...
    def commit(self) -> None: ...
    def rollback(self) -> None: ...
    def recover_twophase(self) -> List[Any]: ...
    def rollback_prepared(self, xid: Any, recover: bool = ...) -> None: ...
    def commit_prepared(self, xid: Any, recover: bool = ...) -> None: ...
    def in_transaction(self) -> bool: ...
    def in_nested_transaction(self) -> bool: ...
    def get_transaction(self) -> Optional[RootTransaction]: ...
    def get_nested_transaction(self) -> Optional[NestedTransaction]: ...
    def close(self) -> None: ...
    @overload
    def scalar(self, statement: TypedReturnsRows[Tuple[_T]], parameters: Optional[_CoreSingleExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> Optional[_T]: ...
    @overload
    def scalar(self, statement: Executable, parameters: Optional[_CoreSingleExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> Any: ...
    @overload
    def scalars(self, statement: TypedReturnsRows[Tuple[_T]], parameters: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> ScalarResult[_T]: ...
    @overload
    def scalars(self, statement: Executable, parameters: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> ScalarResult[Any]: ...
    @overload
    def execute(self, statement: TypedReturnsRows[_T], parameters: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> CursorResult[_T]: ...
    @overload
    def execute(self, statement: Executable, parameters: Optional[_CoreAnyExecuteParams] = ..., *, execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> CursorResult[Any]: ...
    def exec_driver_sql(self, statement: str, parameters: Optional[_DBAPIAnyExecuteParams] = ..., execution_options: Optional[CoreExecuteOptionsParameter] = ...) -> CursorResult[Any]: ...

class ExceptionContextImpl(ExceptionContext):
    engine: Incomplete
    dialect: Incomplete
    connection: Incomplete
    sqlalchemy_exception: Incomplete
    original_exception: Incomplete
    execution_context: Incomplete
    statement: Incomplete
    parameters: Incomplete
    is_disconnect: Incomplete
    invalidate_pool_on_disconnect: Incomplete
    is_pre_ping: Incomplete
    def __init__(self, exception: BaseException, sqlalchemy_exception: Optional[exc.StatementError], engine: Optional[Engine], dialect: Dialect, connection: Optional[Connection], cursor: Optional[DBAPICursor], statement: Optional[str], parameters: Optional[_DBAPIAnyExecuteParams], context: Optional[ExecutionContext], is_disconnect: bool, invalidate_pool_on_disconnect: bool, is_pre_ping: bool) -> None: ...

class Transaction(TransactionalContext):
    is_active: bool
    connection: Connection
    def __init__(self, connection: Connection) -> None: ...
    @property
    def is_valid(self) -> bool: ...
    def close(self) -> None: ...
    def rollback(self) -> None: ...
    def commit(self) -> None: ...

class RootTransaction(Transaction):
    connection: Incomplete
    is_active: bool
    def __init__(self, connection: Connection) -> None: ...

class NestedTransaction(Transaction):
    connection: Incomplete
    is_active: bool
    def __init__(self, connection: Connection) -> None: ...

class TwoPhaseTransaction(RootTransaction):
    xid: Any
    def __init__(self, connection: Connection, xid: Any) -> None: ...
    def prepare(self) -> None: ...

class Engine(ConnectionEventsTarget, log.Identified, inspection.Inspectable['Inspector']):
    dispatch: dispatcher[ConnectionEventsTarget]
    dialect: Dialect
    pool: Pool
    url: URL
    hide_parameters: bool
    logging_name: Incomplete
    echo: Incomplete
    def __init__(self, pool: Pool, dialect: Dialect, url: URL, logging_name: Optional[str] = ..., echo: Optional[_EchoFlagType] = ..., query_cache_size: int = ..., execution_options: Optional[Mapping[str, Any]] = ..., hide_parameters: bool = ...) -> None: ...
    @property
    def engine(self) -> Engine: ...
    def clear_compiled_cache(self) -> None: ...
    def update_execution_options(self, **opt: Any) -> None: ...
    @overload
    def execution_options(self, *, compiled_cache: Optional[CompiledCacheType] = ..., logging_token: str = ..., isolation_level: IsolationLevel = ..., insertmanyvalues_page_size: int = ..., schema_translate_map: Optional[SchemaTranslateMapType] = ..., **opt: Any) -> OptionEngine: ...
    @overload
    def execution_options(self, **opt: Any) -> OptionEngine: ...
    def get_execution_options(self) -> _ExecuteOptions: ...
    @property
    def name(self) -> str: ...
    @property
    def driver(self) -> str: ...
    def dispose(self, close: bool = ...) -> None: ...
    def begin(self) -> Iterator[Connection]: ...
    def connect(self) -> Connection: ...
    def raw_connection(self) -> PoolProxiedConnection: ...

class OptionEngineMixin(log.Identified):
    dispatch: dispatcher[ConnectionEventsTarget]
    dialect: Dialect
    pool: Pool
    url: URL
    hide_parameters: bool
    echo: log.echo_property
    logging_name: Incomplete
    def __init__(self, proxied: Engine, execution_options: CoreExecuteOptionsParameter) -> None: ...
    def update_execution_options(self, **opt: Any) -> None: ...

class OptionEngine(OptionEngineMixin, Engine):
    def update_execution_options(self, **opt: Any) -> None: ...
