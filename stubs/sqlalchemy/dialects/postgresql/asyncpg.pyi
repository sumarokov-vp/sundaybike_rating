from . import json as json, ranges as ranges
from ... import exc as exc, pool as pool, util as util
from ...engine import AdaptedConnection as AdaptedConnection, processors as processors
from ...sql import sqltypes as sqltypes
from ...util.concurrency import asyncio as asyncio, await_fallback as await_fallback, await_only as await_only
from .array import ARRAY as PGARRAY
from .base import ENUM as ENUM, INTERVAL as INTERVAL, OID as OID, PGCompiler as PGCompiler, PGDialect as PGDialect, PGExecutionContext as PGExecutionContext, PGIdentifierPreparer as PGIdentifierPreparer, REGCLASS as REGCLASS, REGCONFIG as REGCONFIG
from .types import BIT as BIT, BYTEA as BYTEA, CITEXT as CITEXT
from _typeshed import Incomplete
from collections.abc import Generator

class AsyncpgARRAY(PGARRAY):
    render_bind_cast: bool

class AsyncpgString(sqltypes.String):
    render_bind_cast: bool

class AsyncpgREGCONFIG(REGCONFIG):
    render_bind_cast: bool

class AsyncpgTime(sqltypes.Time):
    render_bind_cast: bool

class AsyncpgBit(BIT):
    render_bind_cast: bool

class AsyncpgByteA(BYTEA):
    render_bind_cast: bool

class AsyncpgDate(sqltypes.Date):
    render_bind_cast: bool

class AsyncpgDateTime(sqltypes.DateTime):
    render_bind_cast: bool

class AsyncpgBoolean(sqltypes.Boolean):
    render_bind_cast: bool

class AsyncPgInterval(INTERVAL):
    render_bind_cast: bool
    @classmethod
    def adapt_emulated_to_native(cls, interval, **kw): ...

class AsyncPgEnum(ENUM):
    render_bind_cast: bool

class AsyncpgInteger(sqltypes.Integer):
    render_bind_cast: bool

class AsyncpgBigInteger(sqltypes.BigInteger):
    render_bind_cast: bool

class AsyncpgJSON(json.JSON):
    render_bind_cast: bool
    def result_processor(self, dialect, coltype) -> None: ...

class AsyncpgJSONB(json.JSONB):
    render_bind_cast: bool
    def result_processor(self, dialect, coltype) -> None: ...

class AsyncpgJSONIndexType(sqltypes.JSON.JSONIndexType): ...

class AsyncpgJSONIntIndexType(sqltypes.JSON.JSONIntIndexType):
    __visit_name__: str
    render_bind_cast: bool

class AsyncpgJSONStrIndexType(sqltypes.JSON.JSONStrIndexType):
    __visit_name__: str
    render_bind_cast: bool

class AsyncpgJSONPathType(json.JSONPathType):
    def bind_processor(self, dialect): ...

class AsyncpgNumeric(sqltypes.Numeric):
    render_bind_cast: bool
    def bind_processor(self, dialect) -> None: ...
    def result_processor(self, dialect, coltype): ...

class AsyncpgFloat(AsyncpgNumeric, sqltypes.Float):
    __visit_name__: str
    render_bind_cast: bool

class AsyncpgREGCLASS(REGCLASS):
    render_bind_cast: bool

class AsyncpgOID(OID):
    render_bind_cast: bool

class AsyncpgCHAR(sqltypes.CHAR):
    render_bind_cast: bool

class _AsyncpgRange(ranges.AbstractRangeImpl):
    def bind_processor(self, dialect): ...
    def result_processor(self, dialect, coltype): ...

class _AsyncpgMultiRange(ranges.AbstractMultiRangeImpl):
    def bind_processor(self, dialect): ...
    def result_processor(self, dialect, coltype): ...

class PGExecutionContext_asyncpg(PGExecutionContext):
    def handle_dbapi_exception(self, e) -> None: ...
    def pre_exec(self) -> None: ...
    def create_server_side_cursor(self): ...

class PGCompiler_asyncpg(PGCompiler): ...
class PGIdentifierPreparer_asyncpg(PGIdentifierPreparer): ...

class AsyncAdapt_asyncpg_cursor:
    server_side: bool
    description: Incomplete
    arraysize: int
    rowcount: int
    def __init__(self, adapt_connection) -> None: ...
    def close(self) -> None: ...
    def execute(self, operation, parameters: Incomplete | None = ...) -> None: ...
    def executemany(self, operation, seq_of_parameters): ...
    def setinputsizes(self, *inputsizes) -> None: ...
    def __iter__(self): ...
    def fetchone(self): ...
    def fetchmany(self, size: Incomplete | None = ...): ...
    def fetchall(self): ...

class AsyncAdapt_asyncpg_ss_cursor(AsyncAdapt_asyncpg_cursor):
    server_side: bool
    def __init__(self, adapt_connection) -> None: ...
    def close(self) -> None: ...
    def __aiter__(self): ...
    async def __anext__(self) -> Generator[Incomplete, None, None]: ...
    def fetchone(self): ...
    def fetchmany(self, size: Incomplete | None = ...): ...
    def fetchall(self): ...
    def executemany(self, operation, seq_of_parameters) -> None: ...

class AsyncAdapt_asyncpg_connection(AdaptedConnection):
    await_: Incomplete
    dbapi: Incomplete
    isolation_level: str
    readonly: bool
    deferrable: bool
    def __init__(self, dbapi, connection, prepared_statement_cache_size: int = ..., prepared_statement_name_func: Incomplete | None = ...) -> None: ...
    @property
    def autocommit(self): ...
    @autocommit.setter
    def autocommit(self, value) -> None: ...
    def ping(self) -> None: ...
    def set_isolation_level(self, level) -> None: ...
    def cursor(self, server_side: bool = ...): ...
    def rollback(self) -> None: ...
    def commit(self) -> None: ...
    def close(self) -> None: ...
    def terminate(self) -> None: ...

class AsyncAdaptFallback_asyncpg_connection(AsyncAdapt_asyncpg_connection):
    await_: Incomplete

class AsyncAdapt_asyncpg_dbapi:
    asyncpg: Incomplete
    paramstyle: str
    def __init__(self, asyncpg) -> None: ...
    def connect(self, *arg, **kw): ...
    class Error(Exception): ...
    class Warning(Exception): ...
    class InterfaceError(Error): ...
    class DatabaseError(Error): ...
    class InternalError(DatabaseError): ...
    class OperationalError(DatabaseError): ...
    class ProgrammingError(DatabaseError): ...
    class IntegrityError(DatabaseError): ...
    class DataError(DatabaseError): ...
    class NotSupportedError(DatabaseError): ...
    class InternalServerError(InternalError): ...
    class InvalidCachedStatementError(NotSupportedError):
        def __init__(self, message) -> None: ...
    STRING: Incomplete
    NUMBER: Incomplete
    DATETIME: Incomplete
    def Binary(self, value): ...

class PGDialect_asyncpg(PGDialect):
    driver: str
    supports_statement_cache: bool
    supports_server_side_cursors: bool
    render_bind_cast: bool
    has_terminate: bool
    default_paramstyle: str
    supports_sane_multi_rowcount: bool
    execution_ctx_cls = PGExecutionContext_asyncpg
    statement_compiler = PGCompiler_asyncpg
    preparer = PGIdentifierPreparer_asyncpg
    colspecs: Incomplete
    is_async: bool
    @classmethod
    def import_dbapi(cls): ...
    def get_isolation_level_values(self, dbapi_connection): ...
    def set_isolation_level(self, dbapi_connection, level) -> None: ...
    def set_readonly(self, connection, value) -> None: ...
    def get_readonly(self, connection): ...
    def set_deferrable(self, connection, value) -> None: ...
    def get_deferrable(self, connection): ...
    def do_terminate(self, dbapi_connection) -> None: ...
    def create_connect_args(self, url): ...
    def do_ping(self, dbapi_connection): ...
    @classmethod
    def get_pool_class(cls, url): ...
    def is_disconnect(self, e, connection, cursor): ...
    async def setup_asyncpg_json_codec(self, conn): ...
    async def setup_asyncpg_jsonb_codec(self, conn): ...
    def on_connect(self): ...
    def get_driver_connection(self, connection): ...
dialect = PGDialect_asyncpg
